// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pb/cmd0x352/cmd0x352.proto

package cmd0x352

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DelImgReq struct {
	SrcUin          int64  `protobuf:"varint,1,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
	DstUin          int64  `protobuf:"varint,2,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	ReqTerm         int32  `protobuf:"varint,3,opt,name=reqTerm,proto3" json:"reqTerm,omitempty"`
	ReqPlatformType int32  `protobuf:"varint,4,opt,name=reqPlatformType,proto3" json:"reqPlatformType,omitempty"`
	BuType          int32  `protobuf:"varint,5,opt,name=buType,proto3" json:"buType,omitempty"`
	BuildVer        []byte `protobuf:"bytes,6,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	FileResid       []byte `protobuf:"bytes,7,opt,name=fileResid,proto3" json:"fileResid,omitempty"`
	PicWidth        int32  `protobuf:"varint,8,opt,name=picWidth,proto3" json:"picWidth,omitempty"`
	PicHeight       int32  `protobuf:"varint,9,opt,name=picHeight,proto3" json:"picHeight,omitempty"`
}

func (m *DelImgReq) Reset()         { *m = DelImgReq{} }
func (m *DelImgReq) String() string { return proto.CompactTextString(m) }
func (*DelImgReq) ProtoMessage()    {}
func (*DelImgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{0}
}
func (m *DelImgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelImgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelImgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelImgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelImgReq.Merge(m, src)
}
func (m *DelImgReq) XXX_Size() int {
	return m.Size()
}
func (m *DelImgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DelImgReq.DiscardUnknown(m)
}

var xxx_messageInfo_DelImgReq proto.InternalMessageInfo

func (m *DelImgReq) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *DelImgReq) GetDstUin() int64 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *DelImgReq) GetReqTerm() int32 {
	if m != nil {
		return m.ReqTerm
	}
	return 0
}

func (m *DelImgReq) GetReqPlatformType() int32 {
	if m != nil {
		return m.ReqPlatformType
	}
	return 0
}

func (m *DelImgReq) GetBuType() int32 {
	if m != nil {
		return m.BuType
	}
	return 0
}

func (m *DelImgReq) GetBuildVer() []byte {
	if m != nil {
		return m.BuildVer
	}
	return nil
}

func (m *DelImgReq) GetFileResid() []byte {
	if m != nil {
		return m.FileResid
	}
	return nil
}

func (m *DelImgReq) GetPicWidth() int32 {
	if m != nil {
		return m.PicWidth
	}
	return 0
}

func (m *DelImgReq) GetPicHeight() int32 {
	if m != nil {
		return m.PicHeight
	}
	return 0
}

type DelImgRsp struct {
	Result    int32  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	FailMsg   []byte `protobuf:"bytes,2,opt,name=failMsg,proto3" json:"failMsg,omitempty"`
	FileResid []byte `protobuf:"bytes,3,opt,name=fileResid,proto3" json:"fileResid,omitempty"`
}

func (m *DelImgRsp) Reset()         { *m = DelImgRsp{} }
func (m *DelImgRsp) String() string { return proto.CompactTextString(m) }
func (*DelImgRsp) ProtoMessage()    {}
func (*DelImgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{1}
}
func (m *DelImgRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelImgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelImgRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelImgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelImgRsp.Merge(m, src)
}
func (m *DelImgRsp) XXX_Size() int {
	return m.Size()
}
func (m *DelImgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_DelImgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_DelImgRsp proto.InternalMessageInfo

func (m *DelImgRsp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *DelImgRsp) GetFailMsg() []byte {
	if m != nil {
		return m.FailMsg
	}
	return nil
}

func (m *DelImgRsp) GetFileResid() []byte {
	if m != nil {
		return m.FileResid
	}
	return nil
}

type GetImgUrlReq struct {
	SrcUin          int64  `protobuf:"varint,1,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
	DstUin          int64  `protobuf:"varint,2,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	FileResid       []byte `protobuf:"bytes,3,opt,name=fileResid,proto3" json:"fileResid,omitempty"`
	UrlFlag         int32  `protobuf:"varint,4,opt,name=urlFlag,proto3" json:"urlFlag,omitempty"`
	UrlType         int32  `protobuf:"varint,6,opt,name=urlType,proto3" json:"urlType,omitempty"`
	ReqTerm         int32  `protobuf:"varint,7,opt,name=reqTerm,proto3" json:"reqTerm,omitempty"`
	ReqPlatformType int32  `protobuf:"varint,8,opt,name=reqPlatformType,proto3" json:"reqPlatformType,omitempty"`
	SrcFileType     int32  `protobuf:"varint,9,opt,name=srcFileType,proto3" json:"srcFileType,omitempty"`
	InnerIp         int32  `protobuf:"varint,10,opt,name=innerIp,proto3" json:"innerIp,omitempty"`
	BoolAddressBook bool   `protobuf:"varint,11,opt,name=boolAddressBook,proto3" json:"boolAddressBook,omitempty"`
	BuType          int32  `protobuf:"varint,12,opt,name=buType,proto3" json:"buType,omitempty"`
	BuildVer        []byte `protobuf:"bytes,13,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	PicUpTimestamp  int32  `protobuf:"varint,14,opt,name=picUpTimestamp,proto3" json:"picUpTimestamp,omitempty"`
	ReqTransferType int32  `protobuf:"varint,15,opt,name=reqTransferType,proto3" json:"reqTransferType,omitempty"`
}

func (m *GetImgUrlReq) Reset()         { *m = GetImgUrlReq{} }
func (m *GetImgUrlReq) String() string { return proto.CompactTextString(m) }
func (*GetImgUrlReq) ProtoMessage()    {}
func (*GetImgUrlReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{2}
}
func (m *GetImgUrlReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImgUrlReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImgUrlReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImgUrlReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImgUrlReq.Merge(m, src)
}
func (m *GetImgUrlReq) XXX_Size() int {
	return m.Size()
}
func (m *GetImgUrlReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImgUrlReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetImgUrlReq proto.InternalMessageInfo

func (m *GetImgUrlReq) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *GetImgUrlReq) GetDstUin() int64 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *GetImgUrlReq) GetFileResid() []byte {
	if m != nil {
		return m.FileResid
	}
	return nil
}

func (m *GetImgUrlReq) GetUrlFlag() int32 {
	if m != nil {
		return m.UrlFlag
	}
	return 0
}

func (m *GetImgUrlReq) GetUrlType() int32 {
	if m != nil {
		return m.UrlType
	}
	return 0
}

func (m *GetImgUrlReq) GetReqTerm() int32 {
	if m != nil {
		return m.ReqTerm
	}
	return 0
}

func (m *GetImgUrlReq) GetReqPlatformType() int32 {
	if m != nil {
		return m.ReqPlatformType
	}
	return 0
}

func (m *GetImgUrlReq) GetSrcFileType() int32 {
	if m != nil {
		return m.SrcFileType
	}
	return 0
}

func (m *GetImgUrlReq) GetInnerIp() int32 {
	if m != nil {
		return m.InnerIp
	}
	return 0
}

func (m *GetImgUrlReq) GetBoolAddressBook() bool {
	if m != nil {
		return m.BoolAddressBook
	}
	return false
}

func (m *GetImgUrlReq) GetBuType() int32 {
	if m != nil {
		return m.BuType
	}
	return 0
}

func (m *GetImgUrlReq) GetBuildVer() []byte {
	if m != nil {
		return m.BuildVer
	}
	return nil
}

func (m *GetImgUrlReq) GetPicUpTimestamp() int32 {
	if m != nil {
		return m.PicUpTimestamp
	}
	return 0
}

func (m *GetImgUrlReq) GetReqTransferType() int32 {
	if m != nil {
		return m.ReqTransferType
	}
	return 0
}

type GetImgUrlRsp struct {
	FileResid            []byte       `protobuf:"bytes,1,opt,name=fileResid,proto3" json:"fileResid,omitempty"`
	ClientIp             int32        `protobuf:"varint,2,opt,name=clientIp,proto3" json:"clientIp,omitempty"`
	Result               int32        `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
	FailMsg              []byte       `protobuf:"bytes,4,opt,name=failMsg,proto3" json:"failMsg,omitempty"`
	BytesThumbDownUrl    []byte       `protobuf:"bytes,5,opt,name=bytesThumbDownUrl,proto3" json:"bytesThumbDownUrl,omitempty"`
	BytesOriginalDownUrl []byte       `protobuf:"bytes,6,opt,name=bytesOriginalDownUrl,proto3" json:"bytesOriginalDownUrl,omitempty"`
	MsgImgInfo           *D352ImgInfo `protobuf:"bytes,7,opt,name=msgImgInfo,proto3" json:"msgImgInfo,omitempty"`
	Uint32DownIp         []int32      `protobuf:"varint,8,rep,packed,name=uint32DownIp,proto3" json:"uint32DownIp,omitempty"`
	Uint32DownPort       []int32      `protobuf:"varint,9,rep,packed,name=uint32DownPort,proto3" json:"uint32DownPort,omitempty"`
	ThumbDownPara        []byte       `protobuf:"bytes,10,opt,name=thumbDownPara,proto3" json:"thumbDownPara,omitempty"`
	OriginalDownPara     []byte       `protobuf:"bytes,11,opt,name=originalDownPara,proto3" json:"originalDownPara,omitempty"`
	DownDomain           []byte       `protobuf:"bytes,12,opt,name=downDomain,proto3" json:"downDomain,omitempty"`
	BytesBigDownUrl      []byte       `protobuf:"bytes,13,opt,name=bytesBigDownUrl,proto3" json:"bytesBigDownUrl,omitempty"`
	BigDownPara          []byte       `protobuf:"bytes,14,opt,name=bigDownPara,proto3" json:"bigDownPara,omitempty"`
	BigThumbDownPara     []byte       `protobuf:"bytes,15,opt,name=bigThumbDownPara,proto3" json:"bigThumbDownPara,omitempty"`
	HttpsUrlFlag         int32        `protobuf:"varint,16,opt,name=httpsUrlFlag,proto3" json:"httpsUrlFlag,omitempty"`
	MsgDownIp6           []*IPv6Info  `protobuf:"bytes,26,rep,name=msgDownIp6,proto3" json:"msgDownIp6,omitempty"`
	ClientIp6            []byte       `protobuf:"bytes,27,opt,name=clientIp6,proto3" json:"clientIp6,omitempty"`
}

func (m *GetImgUrlRsp) Reset()         { *m = GetImgUrlRsp{} }
func (m *GetImgUrlRsp) String() string { return proto.CompactTextString(m) }
func (*GetImgUrlRsp) ProtoMessage()    {}
func (*GetImgUrlRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{3}
}
func (m *GetImgUrlRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImgUrlRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImgUrlRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImgUrlRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImgUrlRsp.Merge(m, src)
}
func (m *GetImgUrlRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetImgUrlRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImgUrlRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetImgUrlRsp proto.InternalMessageInfo

func (m *GetImgUrlRsp) GetFileResid() []byte {
	if m != nil {
		return m.FileResid
	}
	return nil
}

func (m *GetImgUrlRsp) GetClientIp() int32 {
	if m != nil {
		return m.ClientIp
	}
	return 0
}

func (m *GetImgUrlRsp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *GetImgUrlRsp) GetFailMsg() []byte {
	if m != nil {
		return m.FailMsg
	}
	return nil
}

func (m *GetImgUrlRsp) GetBytesThumbDownUrl() []byte {
	if m != nil {
		return m.BytesThumbDownUrl
	}
	return nil
}

func (m *GetImgUrlRsp) GetBytesOriginalDownUrl() []byte {
	if m != nil {
		return m.BytesOriginalDownUrl
	}
	return nil
}

func (m *GetImgUrlRsp) GetMsgImgInfo() *D352ImgInfo {
	if m != nil {
		return m.MsgImgInfo
	}
	return nil
}

func (m *GetImgUrlRsp) GetUint32DownIp() []int32 {
	if m != nil {
		return m.Uint32DownIp
	}
	return nil
}

func (m *GetImgUrlRsp) GetUint32DownPort() []int32 {
	if m != nil {
		return m.Uint32DownPort
	}
	return nil
}

func (m *GetImgUrlRsp) GetThumbDownPara() []byte {
	if m != nil {
		return m.ThumbDownPara
	}
	return nil
}

func (m *GetImgUrlRsp) GetOriginalDownPara() []byte {
	if m != nil {
		return m.OriginalDownPara
	}
	return nil
}

func (m *GetImgUrlRsp) GetDownDomain() []byte {
	if m != nil {
		return m.DownDomain
	}
	return nil
}

func (m *GetImgUrlRsp) GetBytesBigDownUrl() []byte {
	if m != nil {
		return m.BytesBigDownUrl
	}
	return nil
}

func (m *GetImgUrlRsp) GetBigDownPara() []byte {
	if m != nil {
		return m.BigDownPara
	}
	return nil
}

func (m *GetImgUrlRsp) GetBigThumbDownPara() []byte {
	if m != nil {
		return m.BigThumbDownPara
	}
	return nil
}

func (m *GetImgUrlRsp) GetHttpsUrlFlag() int32 {
	if m != nil {
		return m.HttpsUrlFlag
	}
	return 0
}

func (m *GetImgUrlRsp) GetMsgDownIp6() []*IPv6Info {
	if m != nil {
		return m.MsgDownIp6
	}
	return nil
}

func (m *GetImgUrlRsp) GetClientIp6() []byte {
	if m != nil {
		return m.ClientIp6
	}
	return nil
}

type D352ImgInfo struct {
	FileMd5    []byte `protobuf:"bytes,1,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	FileType   int32  `protobuf:"varint,2,opt,name=fileType,proto3" json:"fileType,omitempty"`
	FileSize   int64  `protobuf:"varint,3,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileWidth  int32  `protobuf:"varint,4,opt,name=fileWidth,proto3" json:"fileWidth,omitempty"`
	FileHeight int32  `protobuf:"varint,5,opt,name=fileHeight,proto3" json:"fileHeight,omitempty"`
	FileFlag   int64  `protobuf:"varint,6,opt,name=fileFlag,proto3" json:"fileFlag,omitempty"`
	FileCutPos int32  `protobuf:"varint,7,opt,name=fileCutPos,proto3" json:"fileCutPos,omitempty"`
}

func (m *D352ImgInfo) Reset()         { *m = D352ImgInfo{} }
func (m *D352ImgInfo) String() string { return proto.CompactTextString(m) }
func (*D352ImgInfo) ProtoMessage()    {}
func (*D352ImgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{4}
}
func (m *D352ImgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D352ImgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D352ImgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D352ImgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D352ImgInfo.Merge(m, src)
}
func (m *D352ImgInfo) XXX_Size() int {
	return m.Size()
}
func (m *D352ImgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_D352ImgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_D352ImgInfo proto.InternalMessageInfo

func (m *D352ImgInfo) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *D352ImgInfo) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *D352ImgInfo) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *D352ImgInfo) GetFileWidth() int32 {
	if m != nil {
		return m.FileWidth
	}
	return 0
}

func (m *D352ImgInfo) GetFileHeight() int32 {
	if m != nil {
		return m.FileHeight
	}
	return 0
}

func (m *D352ImgInfo) GetFileFlag() int64 {
	if m != nil {
		return m.FileFlag
	}
	return 0
}

func (m *D352ImgInfo) GetFileCutPos() int32 {
	if m != nil {
		return m.FileCutPos
	}
	return 0
}

type IPv6Info struct {
	Ip6  []byte `protobuf:"bytes,1,opt,name=ip6,proto3" json:"ip6,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *IPv6Info) Reset()         { *m = IPv6Info{} }
func (m *IPv6Info) String() string { return proto.CompactTextString(m) }
func (*IPv6Info) ProtoMessage()    {}
func (*IPv6Info) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{5}
}
func (m *IPv6Info) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPv6Info) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPv6Info.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPv6Info) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPv6Info.Merge(m, src)
}
func (m *IPv6Info) XXX_Size() int {
	return m.Size()
}
func (m *IPv6Info) XXX_DiscardUnknown() {
	xxx_messageInfo_IPv6Info.DiscardUnknown(m)
}

var xxx_messageInfo_IPv6Info proto.InternalMessageInfo

func (m *IPv6Info) GetIp6() []byte {
	if m != nil {
		return m.Ip6
	}
	return nil
}

func (m *IPv6Info) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ReqBody struct {
	Subcmd          int32              `protobuf:"varint,1,opt,name=subcmd,proto3" json:"subcmd,omitempty"`
	MsgTryupImgReq  []*D352TryUpImgReq `protobuf:"bytes,2,rep,name=msgTryupImgReq,proto3" json:"msgTryupImgReq,omitempty"`
	MsgGetimgUrlReq []*GetImgUrlReq    `protobuf:"bytes,3,rep,name=msgGetimgUrlReq,proto3" json:"msgGetimgUrlReq,omitempty"`
	MsgDelImgReq    []*DelImgReq       `protobuf:"bytes,4,rep,name=msgDelImgReq,proto3" json:"msgDelImgReq,omitempty"`
	NetType         int32              `protobuf:"varint,10,opt,name=netType,proto3" json:"netType,omitempty"`
}

func (m *ReqBody) Reset()         { *m = ReqBody{} }
func (m *ReqBody) String() string { return proto.CompactTextString(m) }
func (*ReqBody) ProtoMessage()    {}
func (*ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{6}
}
func (m *ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqBody.Merge(m, src)
}
func (m *ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_ReqBody proto.InternalMessageInfo

func (m *ReqBody) GetSubcmd() int32 {
	if m != nil {
		return m.Subcmd
	}
	return 0
}

func (m *ReqBody) GetMsgTryupImgReq() []*D352TryUpImgReq {
	if m != nil {
		return m.MsgTryupImgReq
	}
	return nil
}

func (m *ReqBody) GetMsgGetimgUrlReq() []*GetImgUrlReq {
	if m != nil {
		return m.MsgGetimgUrlReq
	}
	return nil
}

func (m *ReqBody) GetMsgDelImgReq() []*DelImgReq {
	if m != nil {
		return m.MsgDelImgReq
	}
	return nil
}

func (m *ReqBody) GetNetType() int32 {
	if m != nil {
		return m.NetType
	}
	return 0
}

type RspBody struct {
	Subcmd          int32           `protobuf:"varint,1,opt,name=subcmd,proto3" json:"subcmd,omitempty"`
	MsgTryupImgRsp  []*TryUpImgRsp  `protobuf:"bytes,2,rep,name=msgTryupImgRsp,proto3" json:"msgTryupImgRsp,omitempty"`
	MsgGetimgUrlRsp []*GetImgUrlRsp `protobuf:"bytes,3,rep,name=msgGetimgUrlRsp,proto3" json:"msgGetimgUrlRsp,omitempty"`
	BoolNewBigchan  bool            `protobuf:"varint,4,opt,name=boolNewBigchan,proto3" json:"boolNewBigchan,omitempty"`
	MsgDelImgRsp    []*DelImgRsp    `protobuf:"bytes,5,rep,name=msgDelImgRsp,proto3" json:"msgDelImgRsp,omitempty"`
	FailMsg         string          `protobuf:"bytes,10,opt,name=failMsg,proto3" json:"failMsg,omitempty"`
}

func (m *RspBody) Reset()         { *m = RspBody{} }
func (m *RspBody) String() string { return proto.CompactTextString(m) }
func (*RspBody) ProtoMessage()    {}
func (*RspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{7}
}
func (m *RspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspBody.Merge(m, src)
}
func (m *RspBody) XXX_Size() int {
	return m.Size()
}
func (m *RspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_RspBody.DiscardUnknown(m)
}

var xxx_messageInfo_RspBody proto.InternalMessageInfo

func (m *RspBody) GetSubcmd() int32 {
	if m != nil {
		return m.Subcmd
	}
	return 0
}

func (m *RspBody) GetMsgTryupImgRsp() []*TryUpImgRsp {
	if m != nil {
		return m.MsgTryupImgRsp
	}
	return nil
}

func (m *RspBody) GetMsgGetimgUrlRsp() []*GetImgUrlRsp {
	if m != nil {
		return m.MsgGetimgUrlRsp
	}
	return nil
}

func (m *RspBody) GetBoolNewBigchan() bool {
	if m != nil {
		return m.BoolNewBigchan
	}
	return false
}

func (m *RspBody) GetMsgDelImgRsp() []*DelImgRsp {
	if m != nil {
		return m.MsgDelImgRsp
	}
	return nil
}

func (m *RspBody) GetFailMsg() string {
	if m != nil {
		return m.FailMsg
	}
	return ""
}

type D352TryUpImgReq struct {
	SrcUin        int32  `protobuf:"varint,1,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
	DstUin        int32  `protobuf:"varint,2,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	FileId        int32  `protobuf:"varint,3,opt,name=fileId,proto3" json:"fileId,omitempty"`
	FileMd5       []byte `protobuf:"bytes,4,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	FileSize      int32  `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	Filename      string `protobuf:"bytes,6,opt,name=filename,proto3" json:"filename,omitempty"`
	SrcTerm       int32  `protobuf:"varint,7,opt,name=srcTerm,proto3" json:"srcTerm,omitempty"`
	PlatformType  int32  `protobuf:"varint,8,opt,name=platformType,proto3" json:"platformType,omitempty"`
	InnerIP       int32  `protobuf:"varint,9,opt,name=innerIP,proto3" json:"innerIP,omitempty"`
	AddressBook   int32  `protobuf:"varint,10,opt,name=addressBook,proto3" json:"addressBook,omitempty"`
	Retry         int32  `protobuf:"varint,11,opt,name=retry,proto3" json:"retry,omitempty"`
	BuType        int32  `protobuf:"varint,12,opt,name=buType,proto3" json:"buType,omitempty"`
	ImgOriginal   int32  `protobuf:"varint,13,opt,name=imgOriginal,proto3" json:"imgOriginal,omitempty"`
	ImgWidth      int32  `protobuf:"varint,14,opt,name=imgWidth,proto3" json:"imgWidth,omitempty"`
	ImgHeight     int32  `protobuf:"varint,15,opt,name=imgHeight,proto3" json:"imgHeight,omitempty"`
	ImgType       int32  `protobuf:"varint,16,opt,name=imgType,proto3" json:"imgType,omitempty"`
	BuildVer      string `protobuf:"bytes,17,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	FileIndex     []byte `protobuf:"bytes,18,opt,name=fileIndex,proto3" json:"fileIndex,omitempty"`
	FileStoreDays int32  `protobuf:"varint,19,opt,name=fileStoreDays,proto3" json:"fileStoreDays,omitempty"`
	StepFlag      int32  `protobuf:"varint,20,opt,name=stepFlag,proto3" json:"stepFlag,omitempty"`
	RejectTryFast int32  `protobuf:"varint,21,opt,name=rejectTryFast,proto3" json:"rejectTryFast,omitempty"`
	SrvUpload     int32  `protobuf:"varint,22,opt,name=srvUpload,proto3" json:"srvUpload,omitempty"`
	TransferUrl   []byte `protobuf:"bytes,23,opt,name=transferUrl,proto3" json:"transferUrl,omitempty"`
}

func (m *D352TryUpImgReq) Reset()         { *m = D352TryUpImgReq{} }
func (m *D352TryUpImgReq) String() string { return proto.CompactTextString(m) }
func (*D352TryUpImgReq) ProtoMessage()    {}
func (*D352TryUpImgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{8}
}
func (m *D352TryUpImgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D352TryUpImgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D352TryUpImgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D352TryUpImgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D352TryUpImgReq.Merge(m, src)
}
func (m *D352TryUpImgReq) XXX_Size() int {
	return m.Size()
}
func (m *D352TryUpImgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_D352TryUpImgReq.DiscardUnknown(m)
}

var xxx_messageInfo_D352TryUpImgReq proto.InternalMessageInfo

func (m *D352TryUpImgReq) GetSrcUin() int32 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *D352TryUpImgReq) GetDstUin() int32 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *D352TryUpImgReq) GetFileId() int32 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *D352TryUpImgReq) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *D352TryUpImgReq) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *D352TryUpImgReq) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *D352TryUpImgReq) GetSrcTerm() int32 {
	if m != nil {
		return m.SrcTerm
	}
	return 0
}

func (m *D352TryUpImgReq) GetPlatformType() int32 {
	if m != nil {
		return m.PlatformType
	}
	return 0
}

func (m *D352TryUpImgReq) GetInnerIP() int32 {
	if m != nil {
		return m.InnerIP
	}
	return 0
}

func (m *D352TryUpImgReq) GetAddressBook() int32 {
	if m != nil {
		return m.AddressBook
	}
	return 0
}

func (m *D352TryUpImgReq) GetRetry() int32 {
	if m != nil {
		return m.Retry
	}
	return 0
}

func (m *D352TryUpImgReq) GetBuType() int32 {
	if m != nil {
		return m.BuType
	}
	return 0
}

func (m *D352TryUpImgReq) GetImgOriginal() int32 {
	if m != nil {
		return m.ImgOriginal
	}
	return 0
}

func (m *D352TryUpImgReq) GetImgWidth() int32 {
	if m != nil {
		return m.ImgWidth
	}
	return 0
}

func (m *D352TryUpImgReq) GetImgHeight() int32 {
	if m != nil {
		return m.ImgHeight
	}
	return 0
}

func (m *D352TryUpImgReq) GetImgType() int32 {
	if m != nil {
		return m.ImgType
	}
	return 0
}

func (m *D352TryUpImgReq) GetBuildVer() string {
	if m != nil {
		return m.BuildVer
	}
	return ""
}

func (m *D352TryUpImgReq) GetFileIndex() []byte {
	if m != nil {
		return m.FileIndex
	}
	return nil
}

func (m *D352TryUpImgReq) GetFileStoreDays() int32 {
	if m != nil {
		return m.FileStoreDays
	}
	return 0
}

func (m *D352TryUpImgReq) GetStepFlag() int32 {
	if m != nil {
		return m.StepFlag
	}
	return 0
}

func (m *D352TryUpImgReq) GetRejectTryFast() int32 {
	if m != nil {
		return m.RejectTryFast
	}
	return 0
}

func (m *D352TryUpImgReq) GetSrvUpload() int32 {
	if m != nil {
		return m.SrvUpload
	}
	return 0
}

func (m *D352TryUpImgReq) GetTransferUrl() []byte {
	if m != nil {
		return m.TransferUrl
	}
	return nil
}

type TryUpImgRsp struct {
	FileId           int64           `protobuf:"varint,1,opt,name=fileId,proto3" json:"fileId,omitempty"`
	ClientIp         int32           `protobuf:"varint,2,opt,name=clientIp,proto3" json:"clientIp,omitempty"`
	Result           int32           `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
	FailMsg          string          `protobuf:"bytes,4,opt,name=failMsg,proto3" json:"failMsg,omitempty"`
	BoolFileExit     bool            `protobuf:"varint,5,opt,name=boolFileExit,proto3" json:"boolFileExit,omitempty"`
	MsgImgInfo       *D352ImgInfo    `protobuf:"bytes,6,opt,name=msgImgInfo,proto3" json:"msgImgInfo,omitempty"`
	Uint32UpIp       []int32         `protobuf:"varint,7,rep,packed,name=uint32UpIp,proto3" json:"uint32UpIp,omitempty"`
	Uint32UpPort     []int32         `protobuf:"varint,8,rep,packed,name=uint32UpPort,proto3" json:"uint32UpPort,omitempty"`
	UpUkey           []byte          `protobuf:"bytes,9,opt,name=upUkey,proto3" json:"upUkey,omitempty"`
	UpResid          string          `protobuf:"bytes,10,opt,name=upResid,proto3" json:"upResid,omitempty"`
	UpUuid           string          `protobuf:"bytes,11,opt,name=upUuid,proto3" json:"upUuid,omitempty"`
	UpOffset         int64           `protobuf:"varint,12,opt,name=upOffset,proto3" json:"upOffset,omitempty"`
	BlockSize        int64           `protobuf:"varint,13,opt,name=blockSize,proto3" json:"blockSize,omitempty"`
	EncryptDstip     []byte          `protobuf:"bytes,14,opt,name=encryptDstip,proto3" json:"encryptDstip,omitempty"`
	Roamdays         int32           `protobuf:"varint,15,opt,name=roamdays,proto3" json:"roamdays,omitempty"`
	MsgUpIp6         []*IPv6Info     `protobuf:"bytes,26,rep,name=msgUpIp6,proto3" json:"msgUpIp6,omitempty"`
	ClientIp6        []byte          `protobuf:"bytes,27,opt,name=clientIp6,proto3" json:"clientIp6,omitempty"`
	ThumbDownPara    []byte          `protobuf:"bytes,60,opt,name=thumbDownPara,proto3" json:"thumbDownPara,omitempty"`
	OriginalDownPara []byte          `protobuf:"bytes,61,opt,name=originalDownPara,proto3" json:"originalDownPara,omitempty"`
	DownDomain       []byte          `protobuf:"bytes,62,opt,name=downDomain,proto3" json:"downDomain,omitempty"`
	BigDownPara      []byte          `protobuf:"bytes,64,opt,name=bigDownPara,proto3" json:"bigDownPara,omitempty"`
	BigThumbDownPara []byte          `protobuf:"bytes,65,opt,name=bigThumbDownPara,proto3" json:"bigThumbDownPara,omitempty"`
	HttpsUrlFlag     int32           `protobuf:"varint,66,opt,name=httpsUrlFlag,proto3" json:"httpsUrlFlag,omitempty"`
	MsgInfo4Busi     *TryUpInfo4Busi `protobuf:"bytes,1001,opt,name=msgInfo4busi,proto3" json:"msgInfo4busi,omitempty"`
}

func (m *TryUpImgRsp) Reset()         { *m = TryUpImgRsp{} }
func (m *TryUpImgRsp) String() string { return proto.CompactTextString(m) }
func (*TryUpImgRsp) ProtoMessage()    {}
func (*TryUpImgRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{9}
}
func (m *TryUpImgRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TryUpImgRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TryUpImgRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TryUpImgRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TryUpImgRsp.Merge(m, src)
}
func (m *TryUpImgRsp) XXX_Size() int {
	return m.Size()
}
func (m *TryUpImgRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TryUpImgRsp.DiscardUnknown(m)
}

var xxx_messageInfo_TryUpImgRsp proto.InternalMessageInfo

func (m *TryUpImgRsp) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *TryUpImgRsp) GetClientIp() int32 {
	if m != nil {
		return m.ClientIp
	}
	return 0
}

func (m *TryUpImgRsp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *TryUpImgRsp) GetFailMsg() string {
	if m != nil {
		return m.FailMsg
	}
	return ""
}

func (m *TryUpImgRsp) GetBoolFileExit() bool {
	if m != nil {
		return m.BoolFileExit
	}
	return false
}

func (m *TryUpImgRsp) GetMsgImgInfo() *D352ImgInfo {
	if m != nil {
		return m.MsgImgInfo
	}
	return nil
}

func (m *TryUpImgRsp) GetUint32UpIp() []int32 {
	if m != nil {
		return m.Uint32UpIp
	}
	return nil
}

func (m *TryUpImgRsp) GetUint32UpPort() []int32 {
	if m != nil {
		return m.Uint32UpPort
	}
	return nil
}

func (m *TryUpImgRsp) GetUpUkey() []byte {
	if m != nil {
		return m.UpUkey
	}
	return nil
}

func (m *TryUpImgRsp) GetUpResid() string {
	if m != nil {
		return m.UpResid
	}
	return ""
}

func (m *TryUpImgRsp) GetUpUuid() string {
	if m != nil {
		return m.UpUuid
	}
	return ""
}

func (m *TryUpImgRsp) GetUpOffset() int64 {
	if m != nil {
		return m.UpOffset
	}
	return 0
}

func (m *TryUpImgRsp) GetBlockSize() int64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *TryUpImgRsp) GetEncryptDstip() []byte {
	if m != nil {
		return m.EncryptDstip
	}
	return nil
}

func (m *TryUpImgRsp) GetRoamdays() int32 {
	if m != nil {
		return m.Roamdays
	}
	return 0
}

func (m *TryUpImgRsp) GetMsgUpIp6() []*IPv6Info {
	if m != nil {
		return m.MsgUpIp6
	}
	return nil
}

func (m *TryUpImgRsp) GetClientIp6() []byte {
	if m != nil {
		return m.ClientIp6
	}
	return nil
}

func (m *TryUpImgRsp) GetThumbDownPara() []byte {
	if m != nil {
		return m.ThumbDownPara
	}
	return nil
}

func (m *TryUpImgRsp) GetOriginalDownPara() []byte {
	if m != nil {
		return m.OriginalDownPara
	}
	return nil
}

func (m *TryUpImgRsp) GetDownDomain() []byte {
	if m != nil {
		return m.DownDomain
	}
	return nil
}

func (m *TryUpImgRsp) GetBigDownPara() []byte {
	if m != nil {
		return m.BigDownPara
	}
	return nil
}

func (m *TryUpImgRsp) GetBigThumbDownPara() []byte {
	if m != nil {
		return m.BigThumbDownPara
	}
	return nil
}

func (m *TryUpImgRsp) GetHttpsUrlFlag() int32 {
	if m != nil {
		return m.HttpsUrlFlag
	}
	return 0
}

func (m *TryUpImgRsp) GetMsgInfo4Busi() *TryUpInfo4Busi {
	if m != nil {
		return m.MsgInfo4Busi
	}
	return nil
}

type TryUpInfo4Busi struct {
	FileResid       []byte `protobuf:"bytes,1,opt,name=fileResid,proto3" json:"fileResid,omitempty"`
	DownDomain      []byte `protobuf:"bytes,2,opt,name=downDomain,proto3" json:"downDomain,omitempty"`
	ThumbDownUrl    []byte `protobuf:"bytes,3,opt,name=thumbDownUrl,proto3" json:"thumbDownUrl,omitempty"`
	OriginalDownUrl []byte `protobuf:"bytes,4,opt,name=originalDownUrl,proto3" json:"originalDownUrl,omitempty"`
	BigDownUrl      []byte `protobuf:"bytes,5,opt,name=bigDownUrl,proto3" json:"bigDownUrl,omitempty"`
}

func (m *TryUpInfo4Busi) Reset()         { *m = TryUpInfo4Busi{} }
func (m *TryUpInfo4Busi) String() string { return proto.CompactTextString(m) }
func (*TryUpInfo4Busi) ProtoMessage()    {}
func (*TryUpInfo4Busi) Descriptor() ([]byte, []int) {
	return fileDescriptor_a4be105753910fd1, []int{10}
}
func (m *TryUpInfo4Busi) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TryUpInfo4Busi) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TryUpInfo4Busi.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TryUpInfo4Busi) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TryUpInfo4Busi.Merge(m, src)
}
func (m *TryUpInfo4Busi) XXX_Size() int {
	return m.Size()
}
func (m *TryUpInfo4Busi) XXX_DiscardUnknown() {
	xxx_messageInfo_TryUpInfo4Busi.DiscardUnknown(m)
}

var xxx_messageInfo_TryUpInfo4Busi proto.InternalMessageInfo

func (m *TryUpInfo4Busi) GetFileResid() []byte {
	if m != nil {
		return m.FileResid
	}
	return nil
}

func (m *TryUpInfo4Busi) GetDownDomain() []byte {
	if m != nil {
		return m.DownDomain
	}
	return nil
}

func (m *TryUpInfo4Busi) GetThumbDownUrl() []byte {
	if m != nil {
		return m.ThumbDownUrl
	}
	return nil
}

func (m *TryUpInfo4Busi) GetOriginalDownUrl() []byte {
	if m != nil {
		return m.OriginalDownUrl
	}
	return nil
}

func (m *TryUpInfo4Busi) GetBigDownUrl() []byte {
	if m != nil {
		return m.BigDownUrl
	}
	return nil
}

func init() {
	proto.RegisterType((*DelImgReq)(nil), "DelImgReq")
	proto.RegisterType((*DelImgRsp)(nil), "DelImgRsp")
	proto.RegisterType((*GetImgUrlReq)(nil), "GetImgUrlReq")
	proto.RegisterType((*GetImgUrlRsp)(nil), "GetImgUrlRsp")
	proto.RegisterType((*D352ImgInfo)(nil), "D352ImgInfo")
	proto.RegisterType((*IPv6Info)(nil), "IPv6Info")
	proto.RegisterType((*ReqBody)(nil), "ReqBody")
	proto.RegisterType((*RspBody)(nil), "RspBody")
	proto.RegisterType((*D352TryUpImgReq)(nil), "D352TryUpImgReq")
	proto.RegisterType((*TryUpImgRsp)(nil), "TryUpImgRsp")
	proto.RegisterType((*TryUpInfo4Busi)(nil), "TryUpInfo4Busi")
}

func init() { proto.RegisterFile("client/pb/cmd0x352/cmd0x352.proto", fileDescriptor_a4be105753910fd1) }

var fileDescriptor_a4be105753910fd1 = []byte{
	// 1463 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4b, 0x8f, 0x1b, 0xc5,
	0x16, 0x8e, 0xc7, 0xd3, 0x1e, 0x4f, 0xd9, 0xf3, 0x48, 0xdf, 0xdc, 0xdc, 0x56, 0xee, 0x95, 0xe5,
	0x6b, 0x05, 0x64, 0x50, 0xe4, 0x44, 0x33, 0xc9, 0x80, 0xc4, 0x43, 0xc4, 0x0c, 0x09, 0x5e, 0x84,
	0x8c, 0x0a, 0x1b, 0x24, 0x58, 0xb5, 0xdd, 0xe5, 0x9e, 0x22, 0xfd, 0xa8, 0xa9, 0xea, 0x4e, 0x62,
	0x96, 0x6c, 0xd9, 0xf0, 0x3f, 0x80, 0x7f, 0xc0, 0x82, 0x25, 0xcb, 0x2c, 0x61, 0x83, 0x50, 0xb2,
	0xe2, 0x5f, 0xa0, 0x73, 0xaa, 0xba, 0xdd, 0xdd, 0xf6, 0x24, 0x23, 0xc4, 0xce, 0xdf, 0x57, 0x8f,
	0xae, 0x73, 0xce, 0x77, 0x1e, 0x26, 0xff, 0x9f, 0x05, 0x9c, 0x45, 0xc9, 0x4d, 0x31, 0xbd, 0x39,
	0x0b, 0xbd, 0x5b, 0x4f, 0x0f, 0xef, 0x1c, 0xe4, 0x3f, 0x06, 0x42, 0xc6, 0x49, 0xdc, 0xfb, 0x76,
	0x83, 0x6c, 0x1f, 0xb3, 0x60, 0x14, 0xfa, 0x94, 0x9d, 0xd9, 0x57, 0x49, 0x43, 0xc9, 0xd9, 0x84,
	0x47, 0x4e, 0xad, 0x5b, 0xeb, 0xd7, 0xa9, 0x41, 0xc0, 0x7b, 0x2a, 0x01, 0x7e, 0x43, 0xf3, 0x1a,
	0xd9, 0x0e, 0xd9, 0x92, 0xec, 0x6c, 0xcc, 0x64, 0xe8, 0xd4, 0xbb, 0xb5, 0xbe, 0x45, 0x33, 0x68,
	0xf7, 0xc9, 0x9e, 0x64, 0x67, 0x27, 0x81, 0x9b, 0xcc, 0x63, 0x19, 0x8e, 0x17, 0x82, 0x39, 0x9b,
	0xb8, 0xa3, 0x4a, 0xc3, 0xdd, 0xd3, 0x14, 0x37, 0x58, 0xb8, 0xc1, 0x20, 0xfb, 0x1a, 0x69, 0x4e,
	0x53, 0x1e, 0x78, 0x9f, 0x31, 0xe9, 0x34, 0xba, 0xb5, 0x7e, 0x9b, 0xe6, 0xd8, 0xfe, 0x1f, 0xd9,
	0x9e, 0xf3, 0x80, 0x51, 0xa6, 0xb8, 0xe7, 0x6c, 0xe1, 0xe2, 0x92, 0x80, 0x93, 0x82, 0xcf, 0x3e,
	0xe7, 0x5e, 0x72, 0xea, 0x34, 0xf1, 0xce, 0x1c, 0xc3, 0x49, 0xc1, 0x67, 0x1f, 0x33, 0xee, 0x9f,
	0x26, 0xce, 0x36, 0x2e, 0x2e, 0x89, 0xde, 0x97, 0xb9, 0x33, 0x94, 0x80, 0x87, 0x49, 0xa6, 0xd2,
	0x20, 0x41, 0x67, 0x58, 0xd4, 0x20, 0x30, 0x7a, 0xee, 0xf2, 0xe0, 0x81, 0xf2, 0xd1, 0x1b, 0x6d,
	0x9a, 0xc1, 0xf2, 0xb3, 0xea, 0x95, 0x67, 0xf5, 0x7e, 0xae, 0x93, 0xf6, 0x7d, 0x96, 0x8c, 0x42,
	0x7f, 0x22, 0x83, 0xbf, 0xe3, 0xed, 0x97, 0x5e, 0x0f, 0xcf, 0x4a, 0x65, 0x70, 0x2f, 0x70, 0x7d,
	0xe3, 0xe9, 0x0c, 0x9a, 0x15, 0x74, 0x71, 0x23, 0x5f, 0x41, 0x1f, 0x17, 0xe2, 0xb7, 0xf5, 0xca,
	0xf8, 0x35, 0xd7, 0xc7, 0xaf, 0x4b, 0x5a, 0x4a, 0xce, 0xee, 0xf1, 0x80, 0xe1, 0x2e, 0xed, 0xd3,
	0x22, 0x05, 0x5f, 0xe1, 0x51, 0xc4, 0xe4, 0x48, 0x38, 0x44, 0x7f, 0xc5, 0x40, 0xf8, 0xca, 0x34,
	0x8e, 0x83, 0xbb, 0x9e, 0x27, 0x99, 0x52, 0xc3, 0x38, 0x7e, 0xe4, 0xb4, 0xba, 0xb5, 0x7e, 0x93,
	0x56, 0xe9, 0x82, 0x4a, 0xda, 0xe7, 0xaa, 0x64, 0xa7, 0xa2, 0x92, 0xd7, 0xc9, 0xae, 0xe0, 0xb3,
	0x89, 0x18, 0xf3, 0x90, 0xa9, 0xc4, 0x0d, 0x85, 0xb3, 0x8b, 0x67, 0x2b, 0xac, 0xb1, 0x75, 0x2c,
	0xdd, 0x48, 0xcd, 0x99, 0xc4, 0x8f, 0xec, 0xe5, 0xb6, 0x16, 0xe9, 0xde, 0x8f, 0x56, 0x31, 0x84,
	0x4a, 0x94, 0x43, 0x52, 0x5b, 0x23, 0x44, 0x9d, 0x81, 0x23, 0x81, 0xa1, 0xb4, 0x68, 0x8e, 0x0b,
	0xea, 0xaa, 0x9f, 0xa7, 0xae, 0xcd, 0xb2, 0xba, 0x6e, 0x90, 0xcb, 0xd3, 0x45, 0xc2, 0xd4, 0xf8,
	0x34, 0x0d, 0xa7, 0xc7, 0xf1, 0x93, 0x68, 0x22, 0x03, 0xcc, 0x99, 0x36, 0x5d, 0x5d, 0xb0, 0x0f,
	0xc8, 0x15, 0x24, 0x1f, 0x4a, 0xee, 0xf3, 0xc8, 0x0d, 0xb2, 0x03, 0x3a, 0x95, 0xd6, 0xae, 0xd9,
	0x37, 0x08, 0x09, 0x95, 0x3f, 0x0a, 0xfd, 0x51, 0x34, 0x8f, 0x51, 0x11, 0xad, 0x83, 0xf6, 0xe0,
	0xf8, 0xf0, 0xce, 0x81, 0xe1, 0x68, 0x61, 0xdd, 0xee, 0x91, 0x76, 0xca, 0xa3, 0xe4, 0xf0, 0x00,
	0x8e, 0x8f, 0x84, 0xd3, 0xec, 0xd6, 0xfb, 0x16, 0x2d, 0x71, 0x10, 0x82, 0x25, 0x3e, 0x89, 0x25,
	0xe4, 0x1c, 0xec, 0xaa, 0xb0, 0xf6, 0x75, 0xb2, 0x93, 0x64, 0xaf, 0x3f, 0x71, 0xa5, 0x8b, 0x42,
	0x69, 0xd3, 0x32, 0x69, 0xbf, 0x49, 0xf6, 0xe3, 0xc2, 0x93, 0x71, 0x63, 0x0b, 0x37, 0xae, 0xf0,
	0x76, 0x87, 0x10, 0x2f, 0x7e, 0x12, 0x1d, 0xc7, 0xa1, 0xcb, 0x23, 0x14, 0x4d, 0x9b, 0x16, 0x18,
	0x94, 0x1e, 0xf8, 0x60, 0xc8, 0xfd, 0xcc, 0x35, 0x5a, 0x3f, 0x55, 0x1a, 0x04, 0x3e, 0xd5, 0x08,
	0x3f, 0xb8, 0x8b, 0xbb, 0x8a, 0x14, 0xbc, 0x6b, 0xca, 0xfd, 0x71, 0xc9, 0x80, 0x3d, 0xfd, 0xae,
	0x2a, 0x0f, 0x5e, 0x3b, 0x4d, 0x12, 0xa1, 0x26, 0x26, 0x57, 0xf7, 0x31, 0xfa, 0x25, 0xce, 0x7e,
	0x03, 0xe3, 0xa0, 0x5d, 0x78, 0xe4, 0x5c, 0xeb, 0xd6, 0xfb, 0xad, 0x83, 0xed, 0xc1, 0xe8, 0xe4,
	0xf1, 0x51, 0x1e, 0x04, 0xb3, 0x08, 0x02, 0xcc, 0x24, 0x75, 0xe4, 0xfc, 0x57, 0x0b, 0x30, 0x27,
	0x7a, 0xbf, 0xd5, 0x48, 0xab, 0x10, 0x3e, 0x14, 0x17, 0x0f, 0xd8, 0x03, 0xef, 0x8e, 0x11, 0x6b,
	0x06, 0x41, 0xaa, 0xf3, 0x2c, 0x85, 0x8d, 0x54, 0x33, 0x9c, 0xad, 0x7d, 0xca, 0xbf, 0x66, 0x28,
	0xd6, 0x3a, 0xcd, 0x71, 0x96, 0x00, 0xba, 0xd8, 0xea, 0xba, 0xb3, 0x24, 0x20, 0x08, 0x00, 0x4c,
	0xb9, 0xd5, 0xf5, 0xbd, 0xc0, 0x64, 0x37, 0xa3, 0x23, 0x1a, 0xcb, 0x9b, 0xd1, 0x09, 0xe6, 0xec,
	0x87, 0x69, 0x72, 0x12, 0x2b, 0x53, 0x9e, 0x0a, 0x4c, 0xef, 0x16, 0x69, 0x66, 0x1e, 0xb1, 0xf7,
	0x49, 0x9d, 0x8b, 0x23, 0x63, 0x13, 0xfc, 0xb4, 0x6d, 0xb2, 0x29, 0x40, 0x6e, 0xda, 0x16, 0xfc,
	0xdd, 0xfb, 0xbd, 0x46, 0xb6, 0x28, 0x3b, 0x1b, 0xc6, 0xde, 0x02, 0x6b, 0x6f, 0x3a, 0x9d, 0x85,
	0x5e, 0x56, 0xdc, 0x35, 0xb2, 0xdf, 0x26, 0xbb, 0xa1, 0xf2, 0xc7, 0x72, 0x91, 0x0a, 0xdd, 0x13,
	0x9d, 0x0d, 0x74, 0xff, 0x3e, 0xa6, 0xc1, 0x58, 0x2e, 0x26, 0x86, 0xa7, 0x95, 0x7d, 0xf6, 0x5b,
	0x64, 0x2f, 0x54, 0xfe, 0x7d, 0x96, 0xf0, 0xac, 0xc0, 0x3b, 0x75, 0x3c, 0xba, 0x33, 0x28, 0x56,
	0x7d, 0x5a, 0xdd, 0x65, 0x0f, 0x48, 0x1b, 0x02, 0x9a, 0x35, 0x61, 0x67, 0x13, 0x4f, 0x91, 0x41,
	0xce, 0xd0, 0xd2, 0x3a, 0x04, 0x31, 0x62, 0x09, 0x46, 0xca, 0x94, 0x53, 0x03, 0x7b, 0xdf, 0x6c,
	0x90, 0x2d, 0xaa, 0xc4, 0x4b, 0x0d, 0xbc, 0x5d, 0x36, 0x50, 0x09, 0x63, 0x60, 0x7b, 0x90, 0x1b,
	0xa7, 0x04, 0xad, 0xec, 0x59, 0x31, 0x4e, 0x89, 0x35, 0xc6, 0x29, 0x41, 0xab, 0xbb, 0xa0, 0x00,
	0x40, 0x29, 0xff, 0x84, 0x3d, 0x19, 0x72, 0x7f, 0x76, 0xea, 0x46, 0x28, 0x92, 0x26, 0xad, 0xb0,
	0x65, 0x27, 0x28, 0xe1, 0x58, 0x65, 0x27, 0x28, 0x41, 0x4b, 0xeb, 0xc5, 0x32, 0x09, 0x4e, 0xd8,
	0xce, 0xcb, 0x64, 0xef, 0x7b, 0x8b, 0xec, 0x55, 0x62, 0x55, 0xe9, 0xb4, 0xd6, 0x39, 0x9d, 0xd6,
	0xca, 0x3b, 0xed, 0x55, 0xd2, 0x00, 0xa5, 0x8d, 0xbc, 0xac, 0x38, 0x6b, 0x54, 0xcc, 0x9f, 0xcd,
	0xb5, 0xf9, 0x83, 0x39, 0x62, 0x2d, 0xf3, 0x07, 0x73, 0xc4, 0xac, 0x45, 0x6e, 0xa8, 0x1b, 0xf0,
	0x36, 0xcd, 0x31, 0xdc, 0xa8, 0xe4, 0xac, 0xd8, 0x81, 0x0d, 0x84, 0x42, 0x21, 0x56, 0xdb, 0x6f,
	0x89, 0x5b, 0x76, 0xd6, 0x13, 0xd3, 0x77, 0x33, 0x08, 0x45, 0xcb, 0x2d, 0x74, 0x55, 0x2d, 0x94,
	0x22, 0x65, 0x5f, 0x21, 0x96, 0x64, 0x89, 0x5c, 0x60, 0x05, 0xb5, 0xa8, 0x06, 0xe7, 0xf6, 0xd9,
	0x2e, 0x69, 0xf1, 0xd0, 0xcf, 0x1a, 0x06, 0x96, 0x4a, 0x8b, 0x16, 0x29, 0xb0, 0x92, 0x87, 0xbe,
	0x2e, 0x04, 0xba, 0xcf, 0xe6, 0x18, 0xaa, 0x04, 0x0f, 0x7d, 0x53, 0x06, 0x74, 0x6f, 0x5d, 0x12,
	0x68, 0x45, 0xe8, 0xe3, 0x47, 0xf7, 0x8d, 0x15, 0x1a, 0x96, 0xba, 0xfb, 0x65, 0xed, 0xb9, 0xea,
	0x0c, 0x38, 0x8a, 0x3c, 0xf6, 0xd4, 0xb1, 0x97, 0xad, 0x17, 0x09, 0x68, 0x28, 0xe8, 0xff, 0x24,
	0x96, 0xec, 0xd8, 0x5d, 0x28, 0xe7, 0x5f, 0x78, 0x73, 0x99, 0x84, 0xfb, 0x55, 0xc2, 0x04, 0xd6,
	0x9f, 0x2b, 0xfa, 0xcd, 0x19, 0x86, 0x1b, 0x24, 0xfb, 0x8a, 0xcd, 0x92, 0xb1, 0x5c, 0xdc, 0x73,
	0x55, 0xe2, 0xfc, 0x5b, 0xdf, 0x50, 0x22, 0xe1, 0x15, 0x4a, 0x3e, 0x9e, 0x88, 0x20, 0x76, 0x3d,
	0xe7, 0xaa, 0xb6, 0x2c, 0x27, 0xc0, 0x6b, 0x89, 0x99, 0x1f, 0xa0, 0xc1, 0xfc, 0x47, 0xb7, 0x8e,
	0x02, 0xd5, 0xfb, 0xa1, 0x41, 0x5a, 0x85, 0xc4, 0x2b, 0x28, 0xcf, 0xcc, 0x84, 0x46, 0x79, 0xff,
	0xc0, 0x28, 0xb1, 0xcc, 0x11, 0xd0, 0x16, 0xe4, 0x1f, 0x4c, 0x68, 0x1f, 0x3d, 0xe5, 0xba, 0x32,
	0x37, 0x69, 0x89, 0xab, 0x0c, 0x03, 0x8d, 0x57, 0x0c, 0x03, 0x1d, 0x42, 0x74, 0x4b, 0x9f, 0x88,
	0x91, 0x70, 0xb6, 0xb0, 0xc9, 0x17, 0x98, 0xe5, 0xb0, 0x30, 0x11, 0x38, 0x06, 0x94, 0x86, 0x05,
	0xcd, 0x81, 0x1d, 0xa9, 0x98, 0x3c, 0x62, 0x0b, 0x14, 0x73, 0x9b, 0x1a, 0x84, 0xf3, 0xab, 0xd0,
	0x23, 0x96, 0xc9, 0x75, 0x03, 0xcd, 0x89, 0x94, 0x7b, 0x28, 0xe2, 0x6d, 0x6a, 0x10, 0x78, 0x2b,
	0x15, 0x0f, 0xe7, 0x73, 0xc5, 0x12, 0xd4, 0x71, 0x9d, 0xe6, 0x18, 0x22, 0x36, 0x0d, 0xe2, 0xd9,
	0x23, 0x4c, 0xd5, 0x1d, 0x5c, 0x5c, 0x12, 0xf0, 0x4e, 0x16, 0xcd, 0xe4, 0x42, 0x24, 0xc7, 0x2a,
	0xe1, 0xc2, 0x74, 0xfb, 0x12, 0x07, 0xb7, 0xcb, 0xd8, 0x0d, 0x3d, 0x90, 0x95, 0x16, 0x73, 0x8e,
	0xed, 0xd7, 0x48, 0x33, 0x54, 0x3e, 0x98, 0xbc, 0xa6, 0x71, 0xe7, 0x4b, 0x2f, 0x6f, 0xdb, 0xab,
	0xd3, 0xd0, 0xbb, 0x17, 0x9d, 0x86, 0xde, 0xbb, 0xd0, 0x34, 0xf4, 0xfe, 0xca, 0x34, 0x54, 0x99,
	0x71, 0x3e, 0xb8, 0xd8, 0x8c, 0x73, 0xf7, 0x82, 0x33, 0xce, 0x70, 0xcd, 0x8c, 0x73, 0x1b, 0x0b,
	0x3e, 0xb8, 0xe5, 0xf6, 0x34, 0x55, 0xdc, 0xf9, 0x53, 0x8f, 0x9b, 0x7b, 0xa6, 0x0d, 0x01, 0x3f,
	0x4c, 0x15, 0xa7, 0xa5, 0x5d, 0xbd, 0x9f, 0x6a, 0x64, 0xb7, 0xbc, 0xe1, 0x15, 0x23, 0x78, 0xd9,
	0xf0, 0x8d, 0x15, 0xc3, 0x7b, 0xa4, 0x9d, 0x14, 0xe7, 0x69, 0xfd, 0xb7, 0xaa, 0xc4, 0xc1, 0xa8,
	0x18, 0x57, 0xa6, 0x68, 0x5d, 0xfd, 0xab, 0x34, 0x7c, 0x6d, 0xba, 0x9c, 0x27, 0xf5, 0x6c, 0x5e,
	0x60, 0x86, 0xd7, 0x7f, 0x79, 0xde, 0xa9, 0x3d, 0x7b, 0xde, 0xa9, 0xfd, 0xf1, 0xbc, 0x53, 0xfb,
	0xee, 0x45, 0xe7, 0xd2, 0xb3, 0x17, 0x9d, 0x4b, 0xbf, 0xbe, 0xe8, 0x5c, 0xfa, 0x82, 0x0c, 0xde,
	0xc9, 0xfe, 0x99, 0x4f, 0x1b, 0xf8, 0xd7, 0xfc, 0xf0, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x75,
	0x53, 0xc8, 0xed, 0xbf, 0x0f, 0x00, 0x00,
}

func (m *DelImgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelImgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelImgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PicHeight != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.PicHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.PicWidth != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.PicWidth))
		i--
		dAtA[i] = 0x40
	}
	if len(m.FileResid) > 0 {
		i -= len(m.FileResid)
		copy(dAtA[i:], m.FileResid)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileResid)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x32
	}
	if m.BuType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.BuType))
		i--
		dAtA[i] = 0x28
	}
	if m.ReqPlatformType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ReqPlatformType))
		i--
		dAtA[i] = 0x20
	}
	if m.ReqTerm != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ReqTerm))
		i--
		dAtA[i] = 0x18
	}
	if m.DstUin != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcUin != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelImgRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelImgRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelImgRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileResid) > 0 {
		i -= len(m.FileResid)
		copy(dAtA[i:], m.FileResid)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileResid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FailMsg) > 0 {
		i -= len(m.FailMsg)
		copy(dAtA[i:], m.FailMsg)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FailMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetImgUrlReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImgUrlReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImgUrlReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqTransferType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ReqTransferType))
		i--
		dAtA[i] = 0x78
	}
	if m.PicUpTimestamp != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.PicUpTimestamp))
		i--
		dAtA[i] = 0x70
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x6a
	}
	if m.BuType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.BuType))
		i--
		dAtA[i] = 0x60
	}
	if m.BoolAddressBook {
		i--
		if m.BoolAddressBook {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.InnerIp != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.InnerIp))
		i--
		dAtA[i] = 0x50
	}
	if m.SrcFileType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.SrcFileType))
		i--
		dAtA[i] = 0x48
	}
	if m.ReqPlatformType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ReqPlatformType))
		i--
		dAtA[i] = 0x40
	}
	if m.ReqTerm != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ReqTerm))
		i--
		dAtA[i] = 0x38
	}
	if m.UrlType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.UrlType))
		i--
		dAtA[i] = 0x30
	}
	if m.UrlFlag != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.UrlFlag))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FileResid) > 0 {
		i -= len(m.FileResid)
		copy(dAtA[i:], m.FileResid)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileResid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstUin != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcUin != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetImgUrlRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImgUrlRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImgUrlRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientIp6) > 0 {
		i -= len(m.ClientIp6)
		copy(dAtA[i:], m.ClientIp6)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.ClientIp6)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.MsgDownIp6) > 0 {
		for iNdEx := len(m.MsgDownIp6) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgDownIp6[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.HttpsUrlFlag != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.HttpsUrlFlag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.BigThumbDownPara) > 0 {
		i -= len(m.BigThumbDownPara)
		copy(dAtA[i:], m.BigThumbDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BigThumbDownPara)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.BigDownPara) > 0 {
		i -= len(m.BigDownPara)
		copy(dAtA[i:], m.BigDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BigDownPara)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.BytesBigDownUrl) > 0 {
		i -= len(m.BytesBigDownUrl)
		copy(dAtA[i:], m.BytesBigDownUrl)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BytesBigDownUrl)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.DownDomain) > 0 {
		i -= len(m.DownDomain)
		copy(dAtA[i:], m.DownDomain)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.DownDomain)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.OriginalDownPara) > 0 {
		i -= len(m.OriginalDownPara)
		copy(dAtA[i:], m.OriginalDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.OriginalDownPara)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ThumbDownPara) > 0 {
		i -= len(m.ThumbDownPara)
		copy(dAtA[i:], m.ThumbDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.ThumbDownPara)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Uint32DownPort) > 0 {
		dAtA2 := make([]byte, len(m.Uint32DownPort)*10)
		var j1 int
		for _, num1 := range m.Uint32DownPort {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintCmd0X352(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Uint32DownIp) > 0 {
		dAtA4 := make([]byte, len(m.Uint32DownIp)*10)
		var j3 int
		for _, num1 := range m.Uint32DownIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintCmd0X352(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x42
	}
	if m.MsgImgInfo != nil {
		{
			size, err := m.MsgImgInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X352(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BytesOriginalDownUrl) > 0 {
		i -= len(m.BytesOriginalDownUrl)
		copy(dAtA[i:], m.BytesOriginalDownUrl)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BytesOriginalDownUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BytesThumbDownUrl) > 0 {
		i -= len(m.BytesThumbDownUrl)
		copy(dAtA[i:], m.BytesThumbDownUrl)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BytesThumbDownUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FailMsg) > 0 {
		i -= len(m.FailMsg)
		copy(dAtA[i:], m.FailMsg)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FailMsg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Result != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientIp != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ClientIp))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FileResid) > 0 {
		i -= len(m.FileResid)
		copy(dAtA[i:], m.FileResid)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileResid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *D352ImgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D352ImgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D352ImgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileCutPos != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileCutPos))
		i--
		dAtA[i] = 0x38
	}
	if m.FileFlag != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileFlag))
		i--
		dAtA[i] = 0x30
	}
	if m.FileHeight != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.FileWidth != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileWidth))
		i--
		dAtA[i] = 0x20
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if m.FileType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IPv6Info) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPv6Info) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPv6Info) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Ip6) > 0 {
		i -= len(m.Ip6)
		copy(dAtA[i:], m.Ip6)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.Ip6)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NetType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.NetType))
		i--
		dAtA[i] = 0x50
	}
	if len(m.MsgDelImgReq) > 0 {
		for iNdEx := len(m.MsgDelImgReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgDelImgReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MsgGetimgUrlReq) > 0 {
		for iNdEx := len(m.MsgGetimgUrlReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgGetimgUrlReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MsgTryupImgReq) > 0 {
		for iNdEx := len(m.MsgTryupImgReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgTryupImgReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Subcmd != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Subcmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailMsg) > 0 {
		i -= len(m.FailMsg)
		copy(dAtA[i:], m.FailMsg)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FailMsg)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MsgDelImgRsp) > 0 {
		for iNdEx := len(m.MsgDelImgRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgDelImgRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.BoolNewBigchan {
		i--
		if m.BoolNewBigchan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.MsgGetimgUrlRsp) > 0 {
		for iNdEx := len(m.MsgGetimgUrlRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgGetimgUrlRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MsgTryupImgRsp) > 0 {
		for iNdEx := len(m.MsgTryupImgRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgTryupImgRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Subcmd != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Subcmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D352TryUpImgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D352TryUpImgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D352TryUpImgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransferUrl) > 0 {
		i -= len(m.TransferUrl)
		copy(dAtA[i:], m.TransferUrl)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.TransferUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.SrvUpload != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.SrvUpload))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RejectTryFast != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.RejectTryFast))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.StepFlag != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.StepFlag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.FileStoreDays != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileStoreDays))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.FileIndex) > 0 {
		i -= len(m.FileIndex)
		copy(dAtA[i:], m.FileIndex)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileIndex)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.ImgType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ImgType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ImgHeight != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ImgHeight))
		i--
		dAtA[i] = 0x78
	}
	if m.ImgWidth != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ImgWidth))
		i--
		dAtA[i] = 0x70
	}
	if m.ImgOriginal != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ImgOriginal))
		i--
		dAtA[i] = 0x68
	}
	if m.BuType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.BuType))
		i--
		dAtA[i] = 0x60
	}
	if m.Retry != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Retry))
		i--
		dAtA[i] = 0x58
	}
	if m.AddressBook != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.AddressBook))
		i--
		dAtA[i] = 0x50
	}
	if m.InnerIP != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.InnerIP))
		i--
		dAtA[i] = 0x48
	}
	if m.PlatformType != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.PlatformType))
		i--
		dAtA[i] = 0x40
	}
	if m.SrcTerm != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.SrcTerm))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x32
	}
	if m.FileSize != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileId != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x18
	}
	if m.DstUin != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcUin != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TryUpImgRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryUpImgRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TryUpImgRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgInfo4Busi != nil {
		{
			size, err := m.MsgInfo4Busi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X352(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.HttpsUrlFlag != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.HttpsUrlFlag))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x90
	}
	if len(m.BigThumbDownPara) > 0 {
		i -= len(m.BigThumbDownPara)
		copy(dAtA[i:], m.BigThumbDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BigThumbDownPara)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x8a
	}
	if len(m.BigDownPara) > 0 {
		i -= len(m.BigDownPara)
		copy(dAtA[i:], m.BigDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BigDownPara)))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0x82
	}
	if len(m.DownDomain) > 0 {
		i -= len(m.DownDomain)
		copy(dAtA[i:], m.DownDomain)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.DownDomain)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf2
	}
	if len(m.OriginalDownPara) > 0 {
		i -= len(m.OriginalDownPara)
		copy(dAtA[i:], m.OriginalDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.OriginalDownPara)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xea
	}
	if len(m.ThumbDownPara) > 0 {
		i -= len(m.ThumbDownPara)
		copy(dAtA[i:], m.ThumbDownPara)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.ThumbDownPara)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xe2
	}
	if len(m.ClientIp6) > 0 {
		i -= len(m.ClientIp6)
		copy(dAtA[i:], m.ClientIp6)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.ClientIp6)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.MsgUpIp6) > 0 {
		for iNdEx := len(m.MsgUpIp6) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgUpIp6[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCmd0X352(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xd2
		}
	}
	if m.Roamdays != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Roamdays))
		i--
		dAtA[i] = 0x78
	}
	if len(m.EncryptDstip) > 0 {
		i -= len(m.EncryptDstip)
		copy(dAtA[i:], m.EncryptDstip)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.EncryptDstip)))
		i--
		dAtA[i] = 0x72
	}
	if m.BlockSize != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.BlockSize))
		i--
		dAtA[i] = 0x68
	}
	if m.UpOffset != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.UpOffset))
		i--
		dAtA[i] = 0x60
	}
	if len(m.UpUuid) > 0 {
		i -= len(m.UpUuid)
		copy(dAtA[i:], m.UpUuid)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.UpUuid)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.UpResid) > 0 {
		i -= len(m.UpResid)
		copy(dAtA[i:], m.UpResid)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.UpResid)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.UpUkey) > 0 {
		i -= len(m.UpUkey)
		copy(dAtA[i:], m.UpUkey)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.UpUkey)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Uint32UpPort) > 0 {
		dAtA8 := make([]byte, len(m.Uint32UpPort)*10)
		var j7 int
		for _, num1 := range m.Uint32UpPort {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintCmd0X352(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Uint32UpIp) > 0 {
		dAtA10 := make([]byte, len(m.Uint32UpIp)*10)
		var j9 int
		for _, num1 := range m.Uint32UpIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintCmd0X352(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x3a
	}
	if m.MsgImgInfo != nil {
		{
			size, err := m.MsgImgInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCmd0X352(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BoolFileExit {
		i--
		if m.BoolFileExit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.FailMsg) > 0 {
		i -= len(m.FailMsg)
		copy(dAtA[i:], m.FailMsg)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FailMsg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Result != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x18
	}
	if m.ClientIp != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.ClientIp))
		i--
		dAtA[i] = 0x10
	}
	if m.FileId != 0 {
		i = encodeVarintCmd0X352(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TryUpInfo4Busi) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryUpInfo4Busi) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TryUpInfo4Busi) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BigDownUrl) > 0 {
		i -= len(m.BigDownUrl)
		copy(dAtA[i:], m.BigDownUrl)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.BigDownUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OriginalDownUrl) > 0 {
		i -= len(m.OriginalDownUrl)
		copy(dAtA[i:], m.OriginalDownUrl)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.OriginalDownUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ThumbDownUrl) > 0 {
		i -= len(m.ThumbDownUrl)
		copy(dAtA[i:], m.ThumbDownUrl)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.ThumbDownUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DownDomain) > 0 {
		i -= len(m.DownDomain)
		copy(dAtA[i:], m.DownDomain)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.DownDomain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FileResid) > 0 {
		i -= len(m.FileResid)
		copy(dAtA[i:], m.FileResid)
		i = encodeVarintCmd0X352(dAtA, i, uint64(len(m.FileResid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCmd0X352(dAtA []byte, offset int, v uint64) int {
	offset -= sovCmd0X352(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DelImgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcUin != 0 {
		n += 1 + sovCmd0X352(uint64(m.SrcUin))
	}
	if m.DstUin != 0 {
		n += 1 + sovCmd0X352(uint64(m.DstUin))
	}
	if m.ReqTerm != 0 {
		n += 1 + sovCmd0X352(uint64(m.ReqTerm))
	}
	if m.ReqPlatformType != 0 {
		n += 1 + sovCmd0X352(uint64(m.ReqPlatformType))
	}
	if m.BuType != 0 {
		n += 1 + sovCmd0X352(uint64(m.BuType))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.FileResid)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.PicWidth != 0 {
		n += 1 + sovCmd0X352(uint64(m.PicWidth))
	}
	if m.PicHeight != 0 {
		n += 1 + sovCmd0X352(uint64(m.PicHeight))
	}
	return n
}

func (m *DelImgRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovCmd0X352(uint64(m.Result))
	}
	l = len(m.FailMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.FileResid)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	return n
}

func (m *GetImgUrlReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcUin != 0 {
		n += 1 + sovCmd0X352(uint64(m.SrcUin))
	}
	if m.DstUin != 0 {
		n += 1 + sovCmd0X352(uint64(m.DstUin))
	}
	l = len(m.FileResid)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.UrlFlag != 0 {
		n += 1 + sovCmd0X352(uint64(m.UrlFlag))
	}
	if m.UrlType != 0 {
		n += 1 + sovCmd0X352(uint64(m.UrlType))
	}
	if m.ReqTerm != 0 {
		n += 1 + sovCmd0X352(uint64(m.ReqTerm))
	}
	if m.ReqPlatformType != 0 {
		n += 1 + sovCmd0X352(uint64(m.ReqPlatformType))
	}
	if m.SrcFileType != 0 {
		n += 1 + sovCmd0X352(uint64(m.SrcFileType))
	}
	if m.InnerIp != 0 {
		n += 1 + sovCmd0X352(uint64(m.InnerIp))
	}
	if m.BoolAddressBook {
		n += 2
	}
	if m.BuType != 0 {
		n += 1 + sovCmd0X352(uint64(m.BuType))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.PicUpTimestamp != 0 {
		n += 1 + sovCmd0X352(uint64(m.PicUpTimestamp))
	}
	if m.ReqTransferType != 0 {
		n += 1 + sovCmd0X352(uint64(m.ReqTransferType))
	}
	return n
}

func (m *GetImgUrlRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileResid)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.ClientIp != 0 {
		n += 1 + sovCmd0X352(uint64(m.ClientIp))
	}
	if m.Result != 0 {
		n += 1 + sovCmd0X352(uint64(m.Result))
	}
	l = len(m.FailMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BytesThumbDownUrl)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BytesOriginalDownUrl)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.MsgImgInfo != nil {
		l = m.MsgImgInfo.Size()
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if len(m.Uint32DownIp) > 0 {
		l = 0
		for _, e := range m.Uint32DownIp {
			l += sovCmd0X352(uint64(e))
		}
		n += 1 + sovCmd0X352(uint64(l)) + l
	}
	if len(m.Uint32DownPort) > 0 {
		l = 0
		for _, e := range m.Uint32DownPort {
			l += sovCmd0X352(uint64(e))
		}
		n += 1 + sovCmd0X352(uint64(l)) + l
	}
	l = len(m.ThumbDownPara)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.OriginalDownPara)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.DownDomain)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BytesBigDownUrl)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BigDownPara)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BigThumbDownPara)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.HttpsUrlFlag != 0 {
		n += 2 + sovCmd0X352(uint64(m.HttpsUrlFlag))
	}
	if len(m.MsgDownIp6) > 0 {
		for _, e := range m.MsgDownIp6 {
			l = e.Size()
			n += 2 + l + sovCmd0X352(uint64(l))
		}
	}
	l = len(m.ClientIp6)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	return n
}

func (m *D352ImgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.FileType != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileType))
	}
	if m.FileSize != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileSize))
	}
	if m.FileWidth != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileWidth))
	}
	if m.FileHeight != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileHeight))
	}
	if m.FileFlag != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileFlag))
	}
	if m.FileCutPos != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileCutPos))
	}
	return n
}

func (m *IPv6Info) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ip6)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovCmd0X352(uint64(m.Port))
	}
	return n
}

func (m *ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subcmd != 0 {
		n += 1 + sovCmd0X352(uint64(m.Subcmd))
	}
	if len(m.MsgTryupImgReq) > 0 {
		for _, e := range m.MsgTryupImgReq {
			l = e.Size()
			n += 1 + l + sovCmd0X352(uint64(l))
		}
	}
	if len(m.MsgGetimgUrlReq) > 0 {
		for _, e := range m.MsgGetimgUrlReq {
			l = e.Size()
			n += 1 + l + sovCmd0X352(uint64(l))
		}
	}
	if len(m.MsgDelImgReq) > 0 {
		for _, e := range m.MsgDelImgReq {
			l = e.Size()
			n += 1 + l + sovCmd0X352(uint64(l))
		}
	}
	if m.NetType != 0 {
		n += 1 + sovCmd0X352(uint64(m.NetType))
	}
	return n
}

func (m *RspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Subcmd != 0 {
		n += 1 + sovCmd0X352(uint64(m.Subcmd))
	}
	if len(m.MsgTryupImgRsp) > 0 {
		for _, e := range m.MsgTryupImgRsp {
			l = e.Size()
			n += 1 + l + sovCmd0X352(uint64(l))
		}
	}
	if len(m.MsgGetimgUrlRsp) > 0 {
		for _, e := range m.MsgGetimgUrlRsp {
			l = e.Size()
			n += 1 + l + sovCmd0X352(uint64(l))
		}
	}
	if m.BoolNewBigchan {
		n += 2
	}
	if len(m.MsgDelImgRsp) > 0 {
		for _, e := range m.MsgDelImgRsp {
			l = e.Size()
			n += 1 + l + sovCmd0X352(uint64(l))
		}
	}
	l = len(m.FailMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	return n
}

func (m *D352TryUpImgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcUin != 0 {
		n += 1 + sovCmd0X352(uint64(m.SrcUin))
	}
	if m.DstUin != 0 {
		n += 1 + sovCmd0X352(uint64(m.DstUin))
	}
	if m.FileId != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileId))
	}
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileSize))
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.SrcTerm != 0 {
		n += 1 + sovCmd0X352(uint64(m.SrcTerm))
	}
	if m.PlatformType != 0 {
		n += 1 + sovCmd0X352(uint64(m.PlatformType))
	}
	if m.InnerIP != 0 {
		n += 1 + sovCmd0X352(uint64(m.InnerIP))
	}
	if m.AddressBook != 0 {
		n += 1 + sovCmd0X352(uint64(m.AddressBook))
	}
	if m.Retry != 0 {
		n += 1 + sovCmd0X352(uint64(m.Retry))
	}
	if m.BuType != 0 {
		n += 1 + sovCmd0X352(uint64(m.BuType))
	}
	if m.ImgOriginal != 0 {
		n += 1 + sovCmd0X352(uint64(m.ImgOriginal))
	}
	if m.ImgWidth != 0 {
		n += 1 + sovCmd0X352(uint64(m.ImgWidth))
	}
	if m.ImgHeight != 0 {
		n += 1 + sovCmd0X352(uint64(m.ImgHeight))
	}
	if m.ImgType != 0 {
		n += 2 + sovCmd0X352(uint64(m.ImgType))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.FileIndex)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	if m.FileStoreDays != 0 {
		n += 2 + sovCmd0X352(uint64(m.FileStoreDays))
	}
	if m.StepFlag != 0 {
		n += 2 + sovCmd0X352(uint64(m.StepFlag))
	}
	if m.RejectTryFast != 0 {
		n += 2 + sovCmd0X352(uint64(m.RejectTryFast))
	}
	if m.SrvUpload != 0 {
		n += 2 + sovCmd0X352(uint64(m.SrvUpload))
	}
	l = len(m.TransferUrl)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	return n
}

func (m *TryUpImgRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovCmd0X352(uint64(m.FileId))
	}
	if m.ClientIp != 0 {
		n += 1 + sovCmd0X352(uint64(m.ClientIp))
	}
	if m.Result != 0 {
		n += 1 + sovCmd0X352(uint64(m.Result))
	}
	l = len(m.FailMsg)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.BoolFileExit {
		n += 2
	}
	if m.MsgImgInfo != nil {
		l = m.MsgImgInfo.Size()
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if len(m.Uint32UpIp) > 0 {
		l = 0
		for _, e := range m.Uint32UpIp {
			l += sovCmd0X352(uint64(e))
		}
		n += 1 + sovCmd0X352(uint64(l)) + l
	}
	if len(m.Uint32UpPort) > 0 {
		l = 0
		for _, e := range m.Uint32UpPort {
			l += sovCmd0X352(uint64(e))
		}
		n += 1 + sovCmd0X352(uint64(l)) + l
	}
	l = len(m.UpUkey)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.UpResid)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.UpUuid)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.UpOffset != 0 {
		n += 1 + sovCmd0X352(uint64(m.UpOffset))
	}
	if m.BlockSize != 0 {
		n += 1 + sovCmd0X352(uint64(m.BlockSize))
	}
	l = len(m.EncryptDstip)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	if m.Roamdays != 0 {
		n += 1 + sovCmd0X352(uint64(m.Roamdays))
	}
	if len(m.MsgUpIp6) > 0 {
		for _, e := range m.MsgUpIp6 {
			l = e.Size()
			n += 2 + l + sovCmd0X352(uint64(l))
		}
	}
	l = len(m.ClientIp6)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.ThumbDownPara)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.OriginalDownPara)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.DownDomain)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BigDownPara)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BigThumbDownPara)
	if l > 0 {
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	if m.HttpsUrlFlag != 0 {
		n += 2 + sovCmd0X352(uint64(m.HttpsUrlFlag))
	}
	if m.MsgInfo4Busi != nil {
		l = m.MsgInfo4Busi.Size()
		n += 2 + l + sovCmd0X352(uint64(l))
	}
	return n
}

func (m *TryUpInfo4Busi) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileResid)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.DownDomain)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.ThumbDownUrl)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.OriginalDownUrl)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	l = len(m.BigDownUrl)
	if l > 0 {
		n += 1 + l + sovCmd0X352(uint64(l))
	}
	return n
}

func sovCmd0X352(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCmd0X352(x uint64) (n int) {
	return sovCmd0X352(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DelImgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelImgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelImgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqTerm", wireType)
			}
			m.ReqTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqTerm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqPlatformType", wireType)
			}
			m.ReqPlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqPlatformType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuType", wireType)
			}
			m.BuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = append(m.BuildVer[:0], dAtA[iNdEx:postIndex]...)
			if m.BuildVer == nil {
				m.BuildVer = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileResid = append(m.FileResid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileResid == nil {
				m.FileResid = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicWidth", wireType)
			}
			m.PicWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicHeight", wireType)
			}
			m.PicHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelImgRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelImgRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelImgRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailMsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailMsg = append(m.FailMsg[:0], dAtA[iNdEx:postIndex]...)
			if m.FailMsg == nil {
				m.FailMsg = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileResid = append(m.FileResid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileResid == nil {
				m.FileResid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImgUrlReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImgUrlReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImgUrlReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileResid = append(m.FileResid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileResid == nil {
				m.FileResid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlFlag", wireType)
			}
			m.UrlFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrlFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlType", wireType)
			}
			m.UrlType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UrlType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqTerm", wireType)
			}
			m.ReqTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqTerm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqPlatformType", wireType)
			}
			m.ReqPlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqPlatformType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcFileType", wireType)
			}
			m.SrcFileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcFileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIp", wireType)
			}
			m.InnerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolAddressBook", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolAddressBook = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuType", wireType)
			}
			m.BuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = append(m.BuildVer[:0], dAtA[iNdEx:postIndex]...)
			if m.BuildVer == nil {
				m.BuildVer = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicUpTimestamp", wireType)
			}
			m.PicUpTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicUpTimestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqTransferType", wireType)
			}
			m.ReqTransferType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqTransferType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImgUrlRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImgUrlRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImgUrlRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileResid = append(m.FileResid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileResid == nil {
				m.FileResid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			m.ClientIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailMsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailMsg = append(m.FailMsg[:0], dAtA[iNdEx:postIndex]...)
			if m.FailMsg == nil {
				m.FailMsg = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesThumbDownUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesThumbDownUrl = append(m.BytesThumbDownUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesThumbDownUrl == nil {
				m.BytesThumbDownUrl = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOriginalDownUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesOriginalDownUrl = append(m.BytesOriginalDownUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesOriginalDownUrl == nil {
				m.BytesOriginalDownUrl = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgImgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgImgInfo == nil {
				m.MsgImgInfo = &D352ImgInfo{}
			}
			if err := m.MsgImgInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32DownIp = append(m.Uint32DownIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCmd0X352
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCmd0X352
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32DownIp) == 0 {
					m.Uint32DownIp = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd0X352
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32DownIp = append(m.Uint32DownIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32DownIp", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32DownPort = append(m.Uint32DownPort, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCmd0X352
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCmd0X352
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32DownPort) == 0 {
					m.Uint32DownPort = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd0X352
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32DownPort = append(m.Uint32DownPort, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32DownPort", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbDownPara = append(m.ThumbDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.ThumbDownPara == nil {
				m.ThumbDownPara = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalDownPara = append(m.OriginalDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalDownPara == nil {
				m.OriginalDownPara = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownDomain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownDomain = append(m.DownDomain[:0], dAtA[iNdEx:postIndex]...)
			if m.DownDomain == nil {
				m.DownDomain = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesBigDownUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesBigDownUrl = append(m.BytesBigDownUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesBigDownUrl == nil {
				m.BytesBigDownUrl = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigDownPara = append(m.BigDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.BigDownPara == nil {
				m.BigDownPara = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigThumbDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigThumbDownPara = append(m.BigThumbDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.BigThumbDownPara == nil {
				m.BigThumbDownPara = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsUrlFlag", wireType)
			}
			m.HttpsUrlFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpsUrlFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgDownIp6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgDownIp6 = append(m.MsgDownIp6, &IPv6Info{})
			if err := m.MsgDownIp6[len(m.MsgDownIp6)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp6", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp6 = append(m.ClientIp6[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientIp6 == nil {
				m.ClientIp6 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D352ImgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D352ImgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D352ImgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileWidth", wireType)
			}
			m.FileWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHeight", wireType)
			}
			m.FileHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFlag", wireType)
			}
			m.FileFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileFlag |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCutPos", wireType)
			}
			m.FileCutPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileCutPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPv6Info) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPv6Info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPv6Info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6 = append(m.Ip6[:0], dAtA[iNdEx:postIndex]...)
			if m.Ip6 == nil {
				m.Ip6 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcmd", wireType)
			}
			m.Subcmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subcmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTryupImgReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTryupImgReq = append(m.MsgTryupImgReq, &D352TryUpImgReq{})
			if err := m.MsgTryupImgReq[len(m.MsgTryupImgReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgGetimgUrlReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgGetimgUrlReq = append(m.MsgGetimgUrlReq, &GetImgUrlReq{})
			if err := m.MsgGetimgUrlReq[len(m.MsgGetimgUrlReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgDelImgReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgDelImgReq = append(m.MsgDelImgReq, &DelImgReq{})
			if err := m.MsgDelImgReq[len(m.MsgDelImgReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			m.NetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcmd", wireType)
			}
			m.Subcmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subcmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTryupImgRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTryupImgRsp = append(m.MsgTryupImgRsp, &TryUpImgRsp{})
			if err := m.MsgTryupImgRsp[len(m.MsgTryupImgRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgGetimgUrlRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgGetimgUrlRsp = append(m.MsgGetimgUrlRsp, &GetImgUrlRsp{})
			if err := m.MsgGetimgUrlRsp[len(m.MsgGetimgUrlRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolNewBigchan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolNewBigchan = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgDelImgRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgDelImgRsp = append(m.MsgDelImgRsp, &DelImgRsp{})
			if err := m.MsgDelImgRsp[len(m.MsgDelImgRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D352TryUpImgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D352TryUpImgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D352TryUpImgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTerm", wireType)
			}
			m.SrcTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcTerm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIP", wireType)
			}
			m.InnerIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressBook", wireType)
			}
			m.AddressBook = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddressBook |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			m.Retry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuType", wireType)
			}
			m.BuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgOriginal", wireType)
			}
			m.ImgOriginal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImgOriginal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgWidth", wireType)
			}
			m.ImgWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImgWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgHeight", wireType)
			}
			m.ImgHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImgHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImgType", wireType)
			}
			m.ImgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIndex = append(m.FileIndex[:0], dAtA[iNdEx:postIndex]...)
			if m.FileIndex == nil {
				m.FileIndex = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStoreDays", wireType)
			}
			m.FileStoreDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileStoreDays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepFlag", wireType)
			}
			m.StepFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectTryFast", wireType)
			}
			m.RejectTryFast = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RejectTryFast |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvUpload", wireType)
			}
			m.SrvUpload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrvUpload |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferUrl = append(m.TransferUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.TransferUrl == nil {
				m.TransferUrl = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryUpImgRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryUpImgRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryUpImgRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			m.ClientIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolFileExit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolFileExit = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgImgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgImgInfo == nil {
				m.MsgImgInfo = &D352ImgInfo{}
			}
			if err := m.MsgImgInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpIp = append(m.Uint32UpIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCmd0X352
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCmd0X352
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpIp) == 0 {
					m.Uint32UpIp = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd0X352
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpIp = append(m.Uint32UpIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpIp", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpPort = append(m.Uint32UpPort, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmd0X352
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCmd0X352
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCmd0X352
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpPort) == 0 {
					m.Uint32UpPort = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmd0X352
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpPort = append(m.Uint32UpPort, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpPort", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpUkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpUkey = append(m.UpUkey[:0], dAtA[iNdEx:postIndex]...)
			if m.UpUkey == nil {
				m.UpUkey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpResid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpResid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpOffset", wireType)
			}
			m.UpOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptDstip", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptDstip = append(m.EncryptDstip[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptDstip == nil {
				m.EncryptDstip = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roamdays", wireType)
			}
			m.Roamdays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Roamdays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUpIp6", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgUpIp6 = append(m.MsgUpIp6, &IPv6Info{})
			if err := m.MsgUpIp6[len(m.MsgUpIp6)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp6", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp6 = append(m.ClientIp6[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientIp6 == nil {
				m.ClientIp6 = []byte{}
			}
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbDownPara = append(m.ThumbDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.ThumbDownPara == nil {
				m.ThumbDownPara = []byte{}
			}
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalDownPara = append(m.OriginalDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalDownPara == nil {
				m.OriginalDownPara = []byte{}
			}
			iNdEx = postIndex
		case 62:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownDomain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownDomain = append(m.DownDomain[:0], dAtA[iNdEx:postIndex]...)
			if m.DownDomain == nil {
				m.DownDomain = []byte{}
			}
			iNdEx = postIndex
		case 64:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigDownPara = append(m.BigDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.BigDownPara == nil {
				m.BigDownPara = []byte{}
			}
			iNdEx = postIndex
		case 65:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigThumbDownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigThumbDownPara = append(m.BigThumbDownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.BigThumbDownPara == nil {
				m.BigThumbDownPara = []byte{}
			}
			iNdEx = postIndex
		case 66:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsUrlFlag", wireType)
			}
			m.HttpsUrlFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpsUrlFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgInfo4Busi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgInfo4Busi == nil {
				m.MsgInfo4Busi = &TryUpInfo4Busi{}
			}
			if err := m.MsgInfo4Busi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryUpInfo4Busi) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryUpInfo4Busi: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryUpInfo4Busi: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileResid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileResid = append(m.FileResid[:0], dAtA[iNdEx:postIndex]...)
			if m.FileResid == nil {
				m.FileResid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownDomain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownDomain = append(m.DownDomain[:0], dAtA[iNdEx:postIndex]...)
			if m.DownDomain == nil {
				m.DownDomain = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbDownUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ThumbDownUrl = append(m.ThumbDownUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.ThumbDownUrl == nil {
				m.ThumbDownUrl = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalDownUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalDownUrl = append(m.OriginalDownUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginalDownUrl == nil {
				m.OriginalDownUrl = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BigDownUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmd0X352
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BigDownUrl = append(m.BigDownUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.BigDownUrl == nil {
				m.BigDownUrl = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmd0X352(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmd0X352
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmd0X352(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmd0X352
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmd0X352
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCmd0X352
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCmd0X352
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCmd0X352
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCmd0X352        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmd0X352          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCmd0X352 = fmt.Errorf("proto: unexpected end of group")
)
