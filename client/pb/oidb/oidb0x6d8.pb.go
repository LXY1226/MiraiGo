// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oidb0x6d8.proto

package oidb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type D6D8ReqBody struct {
	FileInfoReq       *GetFileInfoReqBody  `protobuf:"bytes,1,opt,name=fileInfoReq" json:"fileInfoReq,omitempty"`
	FileListInfoReq   *GetFileListReqBody  `protobuf:"bytes,2,opt,name=fileListInfoReq" json:"fileListInfoReq,omitempty"`
	GroupFileCountReq *GetFileCountReqBody `protobuf:"bytes,3,opt,name=groupFileCountReq" json:"groupFileCountReq,omitempty"`
	GroupSpaceReq     *GetSpaceReqBody     `protobuf:"bytes,4,opt,name=groupSpaceReq" json:"groupSpaceReq,omitempty"`
}

func (m *D6D8ReqBody) Reset()         { *m = D6D8ReqBody{} }
func (m *D6D8ReqBody) String() string { return proto.CompactTextString(m) }
func (*D6D8ReqBody) ProtoMessage()    {}
func (*D6D8ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{0}
}
func (m *D6D8ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D6D8ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D6D8ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D6D8ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D6D8ReqBody.Merge(m, src)
}
func (m *D6D8ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *D6D8ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D6D8ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_D6D8ReqBody proto.InternalMessageInfo

func (m *D6D8ReqBody) GetFileInfoReq() *GetFileInfoReqBody {
	if m != nil {
		return m.FileInfoReq
	}
	return nil
}

func (m *D6D8ReqBody) GetFileListInfoReq() *GetFileListReqBody {
	if m != nil {
		return m.FileListInfoReq
	}
	return nil
}

func (m *D6D8ReqBody) GetGroupFileCountReq() *GetFileCountReqBody {
	if m != nil {
		return m.GroupFileCountReq
	}
	return nil
}

func (m *D6D8ReqBody) GetGroupSpaceReq() *GetSpaceReqBody {
	if m != nil {
		return m.GroupSpaceReq
	}
	return nil
}

type D6D8RspBody struct {
	FileInfoRsp     *GetFileInfoRspBody  `protobuf:"bytes,1,opt,name=fileInfoRsp" json:"fileInfoRsp,omitempty"`
	FileListInfoRsp *GetFileListRspBody  `protobuf:"bytes,2,opt,name=fileListInfoRsp" json:"fileListInfoRsp,omitempty"`
	FileCountRsp    *GetFileCountRspBody `protobuf:"bytes,3,opt,name=fileCountRsp" json:"fileCountRsp,omitempty"`
	GroupSpaceRsp   *GetSpaceRspBody     `protobuf:"bytes,4,opt,name=groupSpaceRsp" json:"groupSpaceRsp,omitempty"`
}

func (m *D6D8RspBody) Reset()         { *m = D6D8RspBody{} }
func (m *D6D8RspBody) String() string { return proto.CompactTextString(m) }
func (*D6D8RspBody) ProtoMessage()    {}
func (*D6D8RspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{1}
}
func (m *D6D8RspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D6D8RspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D6D8RspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D6D8RspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D6D8RspBody.Merge(m, src)
}
func (m *D6D8RspBody) XXX_Size() int {
	return m.Size()
}
func (m *D6D8RspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D6D8RspBody.DiscardUnknown(m)
}

var xxx_messageInfo_D6D8RspBody proto.InternalMessageInfo

func (m *D6D8RspBody) GetFileInfoRsp() *GetFileInfoRspBody {
	if m != nil {
		return m.FileInfoRsp
	}
	return nil
}

func (m *D6D8RspBody) GetFileListInfoRsp() *GetFileListRspBody {
	if m != nil {
		return m.FileListInfoRsp
	}
	return nil
}

func (m *D6D8RspBody) GetFileCountRsp() *GetFileCountRspBody {
	if m != nil {
		return m.FileCountRsp
	}
	return nil
}

func (m *D6D8RspBody) GetGroupSpaceRsp() *GetSpaceRspBody {
	if m != nil {
		return m.GroupSpaceRsp
	}
	return nil
}

type GetFileInfoReqBody struct {
	GroupCode uint64 `protobuf:"varint,1,opt,name=groupCode" json:"groupCode"`
	AppId     uint32 `protobuf:"varint,2,opt,name=appId" json:"appId"`
	BusId     uint32 `protobuf:"varint,3,opt,name=busId" json:"busId"`
	FileId    string `protobuf:"bytes,4,opt,name=fileId" json:"fileId"`
	FieldFlag uint32 `protobuf:"varint,5,opt,name=fieldFlag" json:"fieldFlag"`
}

func (m *GetFileInfoReqBody) Reset()         { *m = GetFileInfoReqBody{} }
func (m *GetFileInfoReqBody) String() string { return proto.CompactTextString(m) }
func (*GetFileInfoReqBody) ProtoMessage()    {}
func (*GetFileInfoReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{2}
}
func (m *GetFileInfoReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileInfoReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileInfoReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileInfoReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileInfoReqBody.Merge(m, src)
}
func (m *GetFileInfoReqBody) XXX_Size() int {
	return m.Size()
}
func (m *GetFileInfoReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileInfoReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileInfoReqBody proto.InternalMessageInfo

func (m *GetFileInfoReqBody) GetGroupCode() uint64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GetFileInfoReqBody) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *GetFileInfoReqBody) GetBusId() uint32 {
	if m != nil {
		return m.BusId
	}
	return 0
}

func (m *GetFileInfoReqBody) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *GetFileInfoReqBody) GetFieldFlag() uint32 {
	if m != nil {
		return m.FieldFlag
	}
	return 0
}

type GetFileInfoRspBody struct {
	RetCode       int32          `protobuf:"varint,1,opt,name=retCode" json:"retCode"`
	RetMsg        string         `protobuf:"bytes,2,opt,name=retMsg" json:"retMsg"`
	ClientWording string         `protobuf:"bytes,3,opt,name=clientWording" json:"clientWording"`
	FileInfo      *GroupFileInfo `protobuf:"bytes,4,opt,name=fileInfo" json:"fileInfo,omitempty"`
}

func (m *GetFileInfoRspBody) Reset()         { *m = GetFileInfoRspBody{} }
func (m *GetFileInfoRspBody) String() string { return proto.CompactTextString(m) }
func (*GetFileInfoRspBody) ProtoMessage()    {}
func (*GetFileInfoRspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{3}
}
func (m *GetFileInfoRspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileInfoRspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileInfoRspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileInfoRspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileInfoRspBody.Merge(m, src)
}
func (m *GetFileInfoRspBody) XXX_Size() int {
	return m.Size()
}
func (m *GetFileInfoRspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileInfoRspBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileInfoRspBody proto.InternalMessageInfo

func (m *GetFileInfoRspBody) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *GetFileInfoRspBody) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *GetFileInfoRspBody) GetClientWording() string {
	if m != nil {
		return m.ClientWording
	}
	return ""
}

func (m *GetFileInfoRspBody) GetFileInfo() *GroupFileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

type GetFileListRspBody struct {
	RetCode       int32                      `protobuf:"varint,1,opt,name=retCode" json:"retCode"`
	RetMsg        string                     `protobuf:"bytes,2,opt,name=retMsg" json:"retMsg"`
	ClientWording string                     `protobuf:"bytes,3,opt,name=clientWording" json:"clientWording"`
	IsEnd         bool                       `protobuf:"varint,4,opt,name=isEnd" json:"isEnd"`
	ItemList      []*GetFileListRspBody_Item `protobuf:"bytes,5,rep,name=itemList" json:"itemList,omitempty"`
	MaxTimestamp  *FileTimeStamp             `protobuf:"bytes,6,opt,name=maxTimestamp" json:"maxTimestamp,omitempty"`
	AllFileCount  uint32                     `protobuf:"varint,7,opt,name=allFileCount" json:"allFileCount"`
	FilterCode    uint32                     `protobuf:"varint,8,opt,name=filterCode" json:"filterCode"`
	SafeCheckFlag bool                       `protobuf:"varint,11,opt,name=safeCheckFlag" json:"safeCheckFlag"`
	SafeCheckRes  uint32                     `protobuf:"varint,12,opt,name=safeCheckRes" json:"safeCheckRes"`
	NextIndex     uint32                     `protobuf:"varint,13,opt,name=nextIndex" json:"nextIndex"`
	Context       []byte                     `protobuf:"bytes,14,opt,name=context" json:"context"`
	Role          uint32                     `protobuf:"varint,15,opt,name=role" json:"role"`
	OpenFlag      uint32                     `protobuf:"varint,16,opt,name=openFlag" json:"openFlag"`
}

func (m *GetFileListRspBody) Reset()         { *m = GetFileListRspBody{} }
func (m *GetFileListRspBody) String() string { return proto.CompactTextString(m) }
func (*GetFileListRspBody) ProtoMessage()    {}
func (*GetFileListRspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{4}
}
func (m *GetFileListRspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileListRspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileListRspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileListRspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileListRspBody.Merge(m, src)
}
func (m *GetFileListRspBody) XXX_Size() int {
	return m.Size()
}
func (m *GetFileListRspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileListRspBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileListRspBody proto.InternalMessageInfo

func (m *GetFileListRspBody) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *GetFileListRspBody) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *GetFileListRspBody) GetClientWording() string {
	if m != nil {
		return m.ClientWording
	}
	return ""
}

func (m *GetFileListRspBody) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *GetFileListRspBody) GetItemList() []*GetFileListRspBody_Item {
	if m != nil {
		return m.ItemList
	}
	return nil
}

func (m *GetFileListRspBody) GetMaxTimestamp() *FileTimeStamp {
	if m != nil {
		return m.MaxTimestamp
	}
	return nil
}

func (m *GetFileListRspBody) GetAllFileCount() uint32 {
	if m != nil {
		return m.AllFileCount
	}
	return 0
}

func (m *GetFileListRspBody) GetFilterCode() uint32 {
	if m != nil {
		return m.FilterCode
	}
	return 0
}

func (m *GetFileListRspBody) GetSafeCheckFlag() bool {
	if m != nil {
		return m.SafeCheckFlag
	}
	return false
}

func (m *GetFileListRspBody) GetSafeCheckRes() uint32 {
	if m != nil {
		return m.SafeCheckRes
	}
	return 0
}

func (m *GetFileListRspBody) GetNextIndex() uint32 {
	if m != nil {
		return m.NextIndex
	}
	return 0
}

func (m *GetFileListRspBody) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *GetFileListRspBody) GetRole() uint32 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *GetFileListRspBody) GetOpenFlag() uint32 {
	if m != nil {
		return m.OpenFlag
	}
	return 0
}

type GetFileListRspBody_Item struct {
	Type       uint32           `protobuf:"varint,1,opt,name=type" json:"type"`
	FolderInfo *GroupFolderInfo `protobuf:"bytes,2,opt,name=folderInfo" json:"folderInfo,omitempty"`
	FileInfo   *GroupFileInfo   `protobuf:"bytes,3,opt,name=fileInfo" json:"fileInfo,omitempty"`
}

func (m *GetFileListRspBody_Item) Reset()         { *m = GetFileListRspBody_Item{} }
func (m *GetFileListRspBody_Item) String() string { return proto.CompactTextString(m) }
func (*GetFileListRspBody_Item) ProtoMessage()    {}
func (*GetFileListRspBody_Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{4, 0}
}
func (m *GetFileListRspBody_Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileListRspBody_Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileListRspBody_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileListRspBody_Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileListRspBody_Item.Merge(m, src)
}
func (m *GetFileListRspBody_Item) XXX_Size() int {
	return m.Size()
}
func (m *GetFileListRspBody_Item) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileListRspBody_Item.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileListRspBody_Item proto.InternalMessageInfo

func (m *GetFileListRspBody_Item) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *GetFileListRspBody_Item) GetFolderInfo() *GroupFolderInfo {
	if m != nil {
		return m.FolderInfo
	}
	return nil
}

func (m *GetFileListRspBody_Item) GetFileInfo() *GroupFileInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

type GroupFileInfo struct {
	FileId         string `protobuf:"bytes,1,opt,name=fileId" json:"fileId"`
	FileName       string `protobuf:"bytes,2,opt,name=fileName" json:"fileName"`
	FileSize       uint64 `protobuf:"varint,3,opt,name=fileSize" json:"fileSize"`
	BusId          uint32 `protobuf:"varint,4,opt,name=busId" json:"busId"`
	UploadedSize   uint64 `protobuf:"varint,5,opt,name=uploadedSize" json:"uploadedSize"`
	UploadTime     uint32 `protobuf:"varint,6,opt,name=uploadTime" json:"uploadTime"`
	DeadTime       uint32 `protobuf:"varint,7,opt,name=deadTime" json:"deadTime"`
	ModifyTime     uint32 `protobuf:"varint,8,opt,name=modifyTime" json:"modifyTime"`
	DownloadTimes  uint32 `protobuf:"varint,9,opt,name=downloadTimes" json:"downloadTimes"`
	Sha            []byte `protobuf:"bytes,10,opt,name=sha" json:"sha"`
	Sha3           []byte `protobuf:"bytes,11,opt,name=sha3" json:"sha3"`
	Md5            []byte `protobuf:"bytes,12,opt,name=md5" json:"md5"`
	LocalPath      string `protobuf:"bytes,13,opt,name=localPath" json:"localPath"`
	UploaderName   string `protobuf:"bytes,14,opt,name=uploaderName" json:"uploaderName"`
	UploaderUin    uint64 `protobuf:"varint,15,opt,name=uploaderUin" json:"uploaderUin"`
	ParentFolderId string `protobuf:"bytes,16,opt,name=parentFolderId" json:"parentFolderId"`
}

func (m *GroupFileInfo) Reset()         { *m = GroupFileInfo{} }
func (m *GroupFileInfo) String() string { return proto.CompactTextString(m) }
func (*GroupFileInfo) ProtoMessage()    {}
func (*GroupFileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{5}
}
func (m *GroupFileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupFileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupFileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupFileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupFileInfo.Merge(m, src)
}
func (m *GroupFileInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupFileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupFileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupFileInfo proto.InternalMessageInfo

func (m *GroupFileInfo) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func (m *GroupFileInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *GroupFileInfo) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *GroupFileInfo) GetBusId() uint32 {
	if m != nil {
		return m.BusId
	}
	return 0
}

func (m *GroupFileInfo) GetUploadedSize() uint64 {
	if m != nil {
		return m.UploadedSize
	}
	return 0
}

func (m *GroupFileInfo) GetUploadTime() uint32 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

func (m *GroupFileInfo) GetDeadTime() uint32 {
	if m != nil {
		return m.DeadTime
	}
	return 0
}

func (m *GroupFileInfo) GetModifyTime() uint32 {
	if m != nil {
		return m.ModifyTime
	}
	return 0
}

func (m *GroupFileInfo) GetDownloadTimes() uint32 {
	if m != nil {
		return m.DownloadTimes
	}
	return 0
}

func (m *GroupFileInfo) GetSha() []byte {
	if m != nil {
		return m.Sha
	}
	return nil
}

func (m *GroupFileInfo) GetSha3() []byte {
	if m != nil {
		return m.Sha3
	}
	return nil
}

func (m *GroupFileInfo) GetMd5() []byte {
	if m != nil {
		return m.Md5
	}
	return nil
}

func (m *GroupFileInfo) GetLocalPath() string {
	if m != nil {
		return m.LocalPath
	}
	return ""
}

func (m *GroupFileInfo) GetUploaderName() string {
	if m != nil {
		return m.UploaderName
	}
	return ""
}

func (m *GroupFileInfo) GetUploaderUin() uint64 {
	if m != nil {
		return m.UploaderUin
	}
	return 0
}

func (m *GroupFileInfo) GetParentFolderId() string {
	if m != nil {
		return m.ParentFolderId
	}
	return ""
}

type GroupFolderInfo struct {
	FolderId       string `protobuf:"bytes,1,opt,name=folderId" json:"folderId"`
	ParentFolderId string `protobuf:"bytes,2,opt,name=parentFolderId" json:"parentFolderId"`
	FolderName     string `protobuf:"bytes,3,opt,name=folderName" json:"folderName"`
	CreateTime     uint32 `protobuf:"varint,4,opt,name=createTime" json:"createTime"`
	ModifyTime     uint32 `protobuf:"varint,5,opt,name=modifyTime" json:"modifyTime"`
	CreateUin      uint64 `protobuf:"varint,6,opt,name=createUin" json:"createUin"`
	CreatorName    string `protobuf:"bytes,7,opt,name=creatorName" json:"creatorName"`
	TotalFileCount uint32 `protobuf:"varint,8,opt,name=totalFileCount" json:"totalFileCount"`
}

func (m *GroupFolderInfo) Reset()         { *m = GroupFolderInfo{} }
func (m *GroupFolderInfo) String() string { return proto.CompactTextString(m) }
func (*GroupFolderInfo) ProtoMessage()    {}
func (*GroupFolderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{6}
}
func (m *GroupFolderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupFolderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupFolderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupFolderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupFolderInfo.Merge(m, src)
}
func (m *GroupFolderInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupFolderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupFolderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupFolderInfo proto.InternalMessageInfo

func (m *GroupFolderInfo) GetFolderId() string {
	if m != nil {
		return m.FolderId
	}
	return ""
}

func (m *GroupFolderInfo) GetParentFolderId() string {
	if m != nil {
		return m.ParentFolderId
	}
	return ""
}

func (m *GroupFolderInfo) GetFolderName() string {
	if m != nil {
		return m.FolderName
	}
	return ""
}

func (m *GroupFolderInfo) GetCreateTime() uint32 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *GroupFolderInfo) GetModifyTime() uint32 {
	if m != nil {
		return m.ModifyTime
	}
	return 0
}

func (m *GroupFolderInfo) GetCreateUin() uint64 {
	if m != nil {
		return m.CreateUin
	}
	return 0
}

func (m *GroupFolderInfo) GetCreatorName() string {
	if m != nil {
		return m.CreatorName
	}
	return ""
}

func (m *GroupFolderInfo) GetTotalFileCount() uint32 {
	if m != nil {
		return m.TotalFileCount
	}
	return 0
}

type GetFileListReqBody struct {
	GroupCode      uint64         `protobuf:"varint,1,opt,name=groupCode" json:"groupCode"`
	AppId          uint32         `protobuf:"varint,2,opt,name=appId" json:"appId"`
	FolderId       string         `protobuf:"bytes,3,opt,name=folderId" json:"folderId"`
	StartTimestamp *FileTimeStamp `protobuf:"bytes,4,opt,name=startTimestamp" json:"startTimestamp,omitempty"`
	FileCount      uint32         `protobuf:"varint,5,opt,name=fileCount" json:"fileCount"`
	MaxTimestamp   *FileTimeStamp `protobuf:"bytes,6,opt,name=maxTimestamp" json:"maxTimestamp,omitempty"`
	AllFileCount   uint32         `protobuf:"varint,7,opt,name=allFileCount" json:"allFileCount"`
	ReqFrom        uint32         `protobuf:"varint,8,opt,name=reqFrom" json:"reqFrom"`
	SortBy         uint32         `protobuf:"varint,9,opt,name=sortBy" json:"sortBy"`
	FilterCode     uint32         `protobuf:"varint,10,opt,name=filterCode" json:"filterCode"`
	Uin            uint64         `protobuf:"varint,11,opt,name=uin" json:"uin"`
	FieldFlag      uint32         `protobuf:"varint,12,opt,name=fieldFlag" json:"fieldFlag"`
	StartIndex     uint32         `protobuf:"varint,13,opt,name=startIndex" json:"startIndex"`
	Context        []byte         `protobuf:"bytes,14,opt,name=context" json:"context"`
	ClientVersion  uint32         `protobuf:"varint,15,opt,name=clientVersion" json:"clientVersion"`
}

func (m *GetFileListReqBody) Reset()         { *m = GetFileListReqBody{} }
func (m *GetFileListReqBody) String() string { return proto.CompactTextString(m) }
func (*GetFileListReqBody) ProtoMessage()    {}
func (*GetFileListReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{7}
}
func (m *GetFileListReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileListReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileListReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileListReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileListReqBody.Merge(m, src)
}
func (m *GetFileListReqBody) XXX_Size() int {
	return m.Size()
}
func (m *GetFileListReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileListReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileListReqBody proto.InternalMessageInfo

func (m *GetFileListReqBody) GetGroupCode() uint64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GetFileListReqBody) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *GetFileListReqBody) GetFolderId() string {
	if m != nil {
		return m.FolderId
	}
	return ""
}

func (m *GetFileListReqBody) GetStartTimestamp() *FileTimeStamp {
	if m != nil {
		return m.StartTimestamp
	}
	return nil
}

func (m *GetFileListReqBody) GetFileCount() uint32 {
	if m != nil {
		return m.FileCount
	}
	return 0
}

func (m *GetFileListReqBody) GetMaxTimestamp() *FileTimeStamp {
	if m != nil {
		return m.MaxTimestamp
	}
	return nil
}

func (m *GetFileListReqBody) GetAllFileCount() uint32 {
	if m != nil {
		return m.AllFileCount
	}
	return 0
}

func (m *GetFileListReqBody) GetReqFrom() uint32 {
	if m != nil {
		return m.ReqFrom
	}
	return 0
}

func (m *GetFileListReqBody) GetSortBy() uint32 {
	if m != nil {
		return m.SortBy
	}
	return 0
}

func (m *GetFileListReqBody) GetFilterCode() uint32 {
	if m != nil {
		return m.FilterCode
	}
	return 0
}

func (m *GetFileListReqBody) GetUin() uint64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *GetFileListReqBody) GetFieldFlag() uint32 {
	if m != nil {
		return m.FieldFlag
	}
	return 0
}

func (m *GetFileListReqBody) GetStartIndex() uint32 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

func (m *GetFileListReqBody) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *GetFileListReqBody) GetClientVersion() uint32 {
	if m != nil {
		return m.ClientVersion
	}
	return 0
}

type GetFileCountReqBody struct {
	GroupCode uint64 `protobuf:"varint,1,opt,name=groupCode" json:"groupCode"`
	AppId     uint32 `protobuf:"varint,2,opt,name=appId" json:"appId"`
	BusId     uint32 `protobuf:"varint,3,opt,name=busId" json:"busId"`
}

func (m *GetFileCountReqBody) Reset()         { *m = GetFileCountReqBody{} }
func (m *GetFileCountReqBody) String() string { return proto.CompactTextString(m) }
func (*GetFileCountReqBody) ProtoMessage()    {}
func (*GetFileCountReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{8}
}
func (m *GetFileCountReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileCountReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileCountReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileCountReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileCountReqBody.Merge(m, src)
}
func (m *GetFileCountReqBody) XXX_Size() int {
	return m.Size()
}
func (m *GetFileCountReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileCountReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileCountReqBody proto.InternalMessageInfo

func (m *GetFileCountReqBody) GetGroupCode() uint64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GetFileCountReqBody) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *GetFileCountReqBody) GetBusId() uint32 {
	if m != nil {
		return m.BusId
	}
	return 0
}

type GetSpaceReqBody struct {
	GroupCode uint64 `protobuf:"varint,1,opt,name=groupCode" json:"groupCode"`
	AppId     uint32 `protobuf:"varint,2,opt,name=appId" json:"appId"`
}

func (m *GetSpaceReqBody) Reset()         { *m = GetSpaceReqBody{} }
func (m *GetSpaceReqBody) String() string { return proto.CompactTextString(m) }
func (*GetSpaceReqBody) ProtoMessage()    {}
func (*GetSpaceReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{9}
}
func (m *GetSpaceReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpaceReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSpaceReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSpaceReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpaceReqBody.Merge(m, src)
}
func (m *GetSpaceReqBody) XXX_Size() int {
	return m.Size()
}
func (m *GetSpaceReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpaceReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpaceReqBody proto.InternalMessageInfo

func (m *GetSpaceReqBody) GetGroupCode() uint64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GetSpaceReqBody) GetAppId() uint32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

type GetFileCountRspBody struct {
	RetCode       int32  `protobuf:"varint,1,opt,name=retCode" json:"retCode"`
	RetMsg        string `protobuf:"bytes,2,opt,name=retMsg" json:"retMsg"`
	ClientWording string `protobuf:"bytes,3,opt,name=clientWording" json:"clientWording"`
	AllFileCount  uint32 `protobuf:"varint,4,opt,name=allFileCount" json:"allFileCount"`
	FileTooMany   bool   `protobuf:"varint,5,opt,name=fileTooMany" json:"fileTooMany"`
	LimitCount    uint32 `protobuf:"varint,6,opt,name=limitCount" json:"limitCount"`
	IsFull        bool   `protobuf:"varint,7,opt,name=isFull" json:"isFull"`
}

func (m *GetFileCountRspBody) Reset()         { *m = GetFileCountRspBody{} }
func (m *GetFileCountRspBody) String() string { return proto.CompactTextString(m) }
func (*GetFileCountRspBody) ProtoMessage()    {}
func (*GetFileCountRspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{10}
}
func (m *GetFileCountRspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileCountRspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileCountRspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileCountRspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileCountRspBody.Merge(m, src)
}
func (m *GetFileCountRspBody) XXX_Size() int {
	return m.Size()
}
func (m *GetFileCountRspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileCountRspBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileCountRspBody proto.InternalMessageInfo

func (m *GetFileCountRspBody) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *GetFileCountRspBody) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *GetFileCountRspBody) GetClientWording() string {
	if m != nil {
		return m.ClientWording
	}
	return ""
}

func (m *GetFileCountRspBody) GetAllFileCount() uint32 {
	if m != nil {
		return m.AllFileCount
	}
	return 0
}

func (m *GetFileCountRspBody) GetFileTooMany() bool {
	if m != nil {
		return m.FileTooMany
	}
	return false
}

func (m *GetFileCountRspBody) GetLimitCount() uint32 {
	if m != nil {
		return m.LimitCount
	}
	return 0
}

func (m *GetFileCountRspBody) GetIsFull() bool {
	if m != nil {
		return m.IsFull
	}
	return false
}

type GetSpaceRspBody struct {
	RetCode       int32  `protobuf:"varint,1,opt,name=retCode" json:"retCode"`
	RetMsg        string `protobuf:"bytes,2,opt,name=retMsg" json:"retMsg"`
	ClientWording string `protobuf:"bytes,3,opt,name=clientWording" json:"clientWording"`
	TotalSpace    uint64 `protobuf:"varint,4,opt,name=totalSpace" json:"totalSpace"`
	UsedSpace     uint64 `protobuf:"varint,5,opt,name=usedSpace" json:"usedSpace"`
}

func (m *GetSpaceRspBody) Reset()         { *m = GetSpaceRspBody{} }
func (m *GetSpaceRspBody) String() string { return proto.CompactTextString(m) }
func (*GetSpaceRspBody) ProtoMessage()    {}
func (*GetSpaceRspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{11}
}
func (m *GetSpaceRspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSpaceRspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSpaceRspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSpaceRspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSpaceRspBody.Merge(m, src)
}
func (m *GetSpaceRspBody) XXX_Size() int {
	return m.Size()
}
func (m *GetSpaceRspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSpaceRspBody.DiscardUnknown(m)
}

var xxx_messageInfo_GetSpaceRspBody proto.InternalMessageInfo

func (m *GetSpaceRspBody) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *GetSpaceRspBody) GetRetMsg() string {
	if m != nil {
		return m.RetMsg
	}
	return ""
}

func (m *GetSpaceRspBody) GetClientWording() string {
	if m != nil {
		return m.ClientWording
	}
	return ""
}

func (m *GetSpaceRspBody) GetTotalSpace() uint64 {
	if m != nil {
		return m.TotalSpace
	}
	return 0
}

func (m *GetSpaceRspBody) GetUsedSpace() uint64 {
	if m != nil {
		return m.UsedSpace
	}
	return 0
}

type FileTimeStamp struct {
	UploadTime uint32 `protobuf:"varint,1,opt,name=uploadTime" json:"uploadTime"`
	FileId     string `protobuf:"bytes,2,opt,name=fileId" json:"fileId"`
}

func (m *FileTimeStamp) Reset()         { *m = FileTimeStamp{} }
func (m *FileTimeStamp) String() string { return proto.CompactTextString(m) }
func (*FileTimeStamp) ProtoMessage()    {}
func (*FileTimeStamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d0973e9cb680f2, []int{12}
}
func (m *FileTimeStamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileTimeStamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileTimeStamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileTimeStamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileTimeStamp.Merge(m, src)
}
func (m *FileTimeStamp) XXX_Size() int {
	return m.Size()
}
func (m *FileTimeStamp) XXX_DiscardUnknown() {
	xxx_messageInfo_FileTimeStamp.DiscardUnknown(m)
}

var xxx_messageInfo_FileTimeStamp proto.InternalMessageInfo

func (m *FileTimeStamp) GetUploadTime() uint32 {
	if m != nil {
		return m.UploadTime
	}
	return 0
}

func (m *FileTimeStamp) GetFileId() string {
	if m != nil {
		return m.FileId
	}
	return ""
}

func init() {
	proto.RegisterType((*D6D8ReqBody)(nil), "D6D8ReqBody")
	proto.RegisterType((*D6D8RspBody)(nil), "D6D8RspBody")
	proto.RegisterType((*GetFileInfoReqBody)(nil), "GetFileInfoReqBody")
	proto.RegisterType((*GetFileInfoRspBody)(nil), "GetFileInfoRspBody")
	proto.RegisterType((*GetFileListRspBody)(nil), "GetFileListRspBody")
	proto.RegisterType((*GetFileListRspBody_Item)(nil), "GetFileListRspBody.Item")
	proto.RegisterType((*GroupFileInfo)(nil), "GroupFileInfo")
	proto.RegisterType((*GroupFolderInfo)(nil), "GroupFolderInfo")
	proto.RegisterType((*GetFileListReqBody)(nil), "GetFileListReqBody")
	proto.RegisterType((*GetFileCountReqBody)(nil), "GetFileCountReqBody")
	proto.RegisterType((*GetSpaceReqBody)(nil), "GetSpaceReqBody")
	proto.RegisterType((*GetFileCountRspBody)(nil), "GetFileCountRspBody")
	proto.RegisterType((*GetSpaceRspBody)(nil), "GetSpaceRspBody")
	proto.RegisterType((*FileTimeStamp)(nil), "FileTimeStamp")
}

func init() { proto.RegisterFile("oidb0x6d8.proto", fileDescriptor_35d0973e9cb680f2) }

var fileDescriptor_35d0973e9cb680f2 = []byte{
	// 1145 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x4f, 0x6b, 0xdc, 0x46,
	0x14, 0xb7, 0x76, 0xb5, 0xfe, 0xf3, 0x76, 0xd7, 0x4e, 0x27, 0x25, 0x08, 0x53, 0xb6, 0x8b, 0x08,
	0xc1, 0x84, 0x62, 0x82, 0x5b, 0x1b, 0x43, 0xe9, 0xc5, 0x4e, 0x1d, 0x0c, 0x4d, 0x69, 0xd7, 0x69,
	0x0b, 0xbd, 0x29, 0xab, 0x59, 0x5b, 0x54, 0xd2, 0xc8, 0x9a, 0x59, 0x6a, 0xf7, 0xd0, 0xcf, 0xd0,
	0x4b, 0xbf, 0x44, 0x8e, 0xfd, 0x02, 0x85, 0x42, 0x21, 0x97, 0x42, 0x8e, 0x3d, 0x95, 0x62, 0x7f,
	0x86, 0x9e, 0x5b, 0xde, 0x93, 0x46, 0x9a, 0xd1, 0xca, 0xe4, 0xd0, 0xc4, 0x37, 0xef, 0xef, 0xfd,
	0xde, 0x9b, 0xf7, 0xe7, 0xa7, 0x79, 0x63, 0xd8, 0x10, 0x51, 0xf8, 0xfc, 0xd1, 0xc5, 0x5e, 0xb8,
	0xbf, 0x9d, 0xe5, 0x42, 0x09, 0xff, 0x5f, 0x07, 0xfa, 0x8f, 0xf7, 0x1e, 0xef, 0x4f, 0xf8, 0xf9,
	0x81, 0x08, 0x2f, 0xd9, 0x2e, 0xf4, 0x67, 0x51, 0xcc, 0x8f, 0xd3, 0x99, 0x98, 0xf0, 0x73, 0xcf,
	0x19, 0x3b, 0x5b, 0xfd, 0x9d, 0xbb, 0xdb, 0x4f, 0xb8, 0x3a, 0xaa, 0x61, 0x64, 0x4e, 0x4c, 0x1e,
	0xfb, 0x04, 0x36, 0xf0, 0xe7, 0x67, 0x91, 0x54, 0xda, 0xb5, 0x63, 0xbb, 0xa2, 0x49, 0xbb, 0x36,
	0xb9, 0xec, 0x00, 0xde, 0x39, 0xcd, 0xc5, 0x3c, 0x43, 0xe2, 0xa1, 0x98, 0xa7, 0xc8, 0xf4, 0xba,
	0x14, 0xe0, 0x5d, 0x1d, 0x40, 0xe3, 0x14, 0x61, 0x91, 0xce, 0xf6, 0x60, 0x48, 0xe0, 0x49, 0x16,
	0x4c, 0x39, 0xfa, 0xbb, 0xe4, 0x7f, 0x07, 0xfd, 0x35, 0x46, 0xbe, 0x36, 0xcd, 0xff, 0x47, 0x77,
	0x40, 0x66, 0x0b, 0x1d, 0x90, 0x59, 0x6b, 0x07, 0x0a, 0xe6, 0xc4, 0xe4, 0x2d, 0x74, 0x40, 0x66,
	0xad, 0x1d, 0x28, 0x5d, 0x9b, 0x5c, 0xb6, 0x0f, 0x83, 0x59, 0x55, 0x8d, 0xcc, 0xda, 0x8b, 0x2f,
	0x9d, 0x2d, 0x66, 0xa3, 0x6e, 0x99, 0x2d, 0xd6, 0x5d, 0xba, 0xd9, 0x34, 0xff, 0x17, 0x07, 0xd8,
	0xe2, 0x58, 0x99, 0x0f, 0x6b, 0xc4, 0x3b, 0x14, 0x21, 0xa7, 0xe2, 0xdd, 0x03, 0xf7, 0xe5, 0x5f,
	0xef, 0x2f, 0x4d, 0x6a, 0x98, 0x6d, 0x42, 0x2f, 0xc8, 0xb2, 0xe3, 0x90, 0x2a, 0x1c, 0x96, 0xf6,
	0x02, 0x42, 0xdb, 0xf3, 0xb9, 0x3c, 0x0e, 0xa9, 0x82, 0xca, 0x46, 0x10, 0x7b, 0x0f, 0x96, 0xa9,
	0x65, 0x21, 0xe5, 0xb8, 0x56, 0x1a, 0x4b, 0x0c, 0x4f, 0x9e, 0x45, 0x3c, 0x0e, 0x8f, 0xe2, 0xe0,
	0xd4, 0xeb, 0x19, 0xde, 0x35, 0xec, 0xbf, 0x68, 0x24, 0x5d, 0xce, 0x6c, 0x04, 0x2b, 0x39, 0x57,
	0x55, 0xca, 0xbd, 0xd2, 0x51, 0x83, 0x78, 0x70, 0xce, 0xd5, 0x53, 0x79, 0x4a, 0x19, 0x57, 0x07,
	0x17, 0x18, 0x7b, 0x08, 0xc3, 0x69, 0x1c, 0xf1, 0x54, 0x7d, 0x23, 0xf2, 0x30, 0x4a, 0x4f, 0x29,
	0x75, 0x4d, 0xb2, 0x4d, 0xec, 0x21, 0xac, 0xea, 0xa9, 0x97, 0x8d, 0x5e, 0xdf, 0x7e, 0xa2, 0xb5,
	0x48, 0x29, 0x55, 0x76, 0xff, 0x45, 0xaf, 0x4a, 0xd6, 0x98, 0xfd, 0x2d, 0x26, 0xbb, 0x09, 0xbd,
	0x48, 0x7e, 0x9a, 0x16, 0xed, 0x5e, 0xd5, 0xb3, 0x20, 0x88, 0x7d, 0x04, 0xab, 0x91, 0xe2, 0x09,
	0x26, 0xe6, 0xf5, 0xc6, 0xdd, 0xad, 0xfe, 0x8e, 0xd7, 0x22, 0xd4, 0xed, 0x63, 0xc5, 0x93, 0x49,
	0xc5, 0x64, 0x3b, 0x30, 0x48, 0x82, 0x8b, 0x67, 0x51, 0xc2, 0xa5, 0x0a, 0x92, 0xcc, 0x5b, 0x2e,
	0x5b, 0x80, 0x6e, 0x88, 0x9e, 0x20, 0x3a, 0xb1, 0x38, 0x6c, 0x0b, 0x06, 0x41, 0x1c, 0x57, 0x2a,
	0xf6, 0x56, 0x8c, 0xd1, 0x5a, 0x16, 0x76, 0x1f, 0x60, 0x16, 0xc5, 0x8a, 0xe7, 0xd4, 0x9c, 0x55,
	0x83, 0x67, 0xe0, 0xd8, 0x01, 0x19, 0xcc, 0xf8, 0xe1, 0x19, 0x9f, 0x7e, 0x47, 0x5a, 0xe9, 0x1b,
	0xd5, 0xd9, 0x26, 0x3c, 0xbb, 0x02, 0x26, 0x5c, 0x7a, 0x03, 0xf3, 0x6c, 0xd3, 0x82, 0xea, 0x4b,
	0xf9, 0x85, 0x3a, 0x4e, 0x43, 0x7e, 0xe1, 0x0d, 0x4d, 0xf5, 0x55, 0x30, 0x4e, 0x6e, 0x2a, 0x52,
	0xc5, 0x2f, 0x94, 0xb7, 0x3e, 0x76, 0xb6, 0x06, 0x7a, 0x72, 0x25, 0xc8, 0x3c, 0x70, 0x73, 0x11,
	0x73, 0x6f, 0xc3, 0x70, 0x27, 0x84, 0x8d, 0x61, 0x55, 0x64, 0x3c, 0xa5, 0x74, 0xef, 0x18, 0xd6,
	0x0a, 0xdd, 0xfc, 0x11, 0x5c, 0xec, 0x35, 0xc6, 0x50, 0x97, 0x59, 0x21, 0x8d, 0x2a, 0x06, 0x22,
	0xec, 0x11, 0xc0, 0x4c, 0xc4, 0x21, 0xcf, 0x49, 0x7c, 0x1d, 0xfd, 0x95, 0x93, 0xf8, 0x2a, 0x7c,
	0x62, 0x70, 0x2c, 0xb1, 0x76, 0x5f, 0x23, 0xd6, 0x5f, 0x5d, 0x18, 0x5a, 0x36, 0xe3, 0x6b, 0x75,
	0x5a, 0xbe, 0xd6, 0x71, 0x11, 0xfb, 0xf3, 0x20, 0xe1, 0x96, 0x4e, 0x2b, 0x54, 0x33, 0x4e, 0xa2,
	0x1f, 0x38, 0x9d, 0xee, 0x9a, 0x0c, 0x44, 0xeb, 0xbb, 0xc2, 0x5d, 0xbc, 0x2b, 0xb6, 0x60, 0x30,
	0xcf, 0x62, 0x11, 0x84, 0x3c, 0xa4, 0x08, 0x3d, 0x23, 0x82, 0x65, 0x41, 0xd5, 0x14, 0xbf, 0x51,
	0x72, 0xa4, 0xc8, 0x4a, 0x35, 0x35, 0x8e, 0xd9, 0x84, 0xbc, 0xe4, 0x98, 0x0a, 0xac, 0x50, 0x8c,
	0x93, 0x88, 0x30, 0x9a, 0x5d, 0x12, 0xc7, 0x52, 0x5f, 0x8d, 0xa3, 0xfa, 0x42, 0xf1, 0x7d, 0xaa,
	0xe3, 0x4a, 0x6f, 0xcd, 0x20, 0xda, 0x26, 0x76, 0x0f, 0xba, 0xf2, 0x2c, 0xf0, 0xc0, 0xd0, 0x0a,
	0x02, 0x38, 0x63, 0x79, 0x16, 0x7c, 0x48, 0xc2, 0xd5, 0x06, 0x42, 0xd0, 0x23, 0x09, 0x77, 0x49,
	0xa6, 0x95, 0x47, 0x12, 0xee, 0xa2, 0x3a, 0x63, 0x31, 0x0d, 0xe2, 0x2f, 0x02, 0x75, 0x46, 0xea,
	0xd4, 0xed, 0xae, 0x61, 0xa3, 0x63, 0x39, 0x4d, 0x65, 0xdd, 0xa0, 0x59, 0x16, 0xf6, 0x00, 0xfa,
	0xfa, 0xf7, 0x57, 0x51, 0x4a, 0x72, 0xd5, 0xad, 0x35, 0x0d, 0xec, 0x03, 0x58, 0xcf, 0x82, 0x9c,
	0xa7, 0xaa, 0xd4, 0x57, 0x48, 0xda, 0xd5, 0x31, 0x1b, 0x36, 0xff, 0x8f, 0x0e, 0x6c, 0x34, 0xd4,
	0x48, 0x1a, 0xd0, 0xbe, 0x8e, 0xa5, 0x92, 0x12, 0x6d, 0x39, 0xa3, 0x73, 0xf3, 0x19, 0x74, 0x43,
	0xd0, 0xdf, 0x54, 0xa1, 0x79, 0xf5, 0x19, 0x38, 0xb2, 0xa6, 0x39, 0x0f, 0x14, 0x5d, 0x49, 0x96,
	0xb8, 0x0c, 0xbc, 0x31, 0xef, 0xde, 0x0d, 0xf3, 0xf6, 0x61, 0xad, 0xf0, 0xc1, 0x4e, 0x2d, 0x9b,
	0xfb, 0xb0, 0x82, 0xb1, 0x9f, 0xf4, 0x43, 0x14, 0x69, 0xad, 0x18, 0x69, 0x99, 0x06, 0xac, 0x55,
	0x09, 0x15, 0x18, 0x77, 0xa1, 0xa9, 0xb2, 0x86, 0xcd, 0xff, 0xcd, 0xb5, 0xd7, 0xc7, 0x1b, 0x5a,
	0xd0, 0xe6, 0x48, 0xba, 0xad, 0x23, 0xd9, 0x83, 0x75, 0xa9, 0x82, 0x5c, 0xd5, 0xd7, 0xbc, 0xdb,
	0x7a, 0xcd, 0x37, 0x58, 0xc5, 0x02, 0xd7, 0x95, 0x35, 0x16, 0xb8, 0xbe, 0xe2, 0xdf, 0xee, 0x02,
	0xa1, 0xd5, 0x7a, 0x7e, 0x94, 0x8b, 0xc4, 0xea, 0xac, 0x06, 0xf1, 0x4a, 0x93, 0x22, 0x57, 0x07,
	0x97, 0xd6, 0x57, 0x5b, 0x62, 0x8d, 0xf5, 0x03, 0x37, 0xac, 0x9f, 0x7b, 0xd0, 0x9d, 0x47, 0x29,
	0x7d, 0xbb, 0xba, 0xf3, 0x08, 0xd8, 0xcf, 0x97, 0x41, 0xeb, 0xf3, 0x05, 0x4f, 0xa0, 0x9e, 0x2d,
	0x6e, 0x19, 0x03, 0x7f, 0xed, 0x9a, 0xa9, 0x9e, 0x00, 0x5f, 0xf3, 0x5c, 0x46, 0x22, 0xb5, 0xf6,
	0x8d, 0x6d, 0xf2, 0xcf, 0xe1, 0x6e, 0xcb, 0xfb, 0xf9, 0x6d, 0xbe, 0xf2, 0xfc, 0x2f, 0x61, 0xa3,
	0xf1, 0xe4, 0xfe, 0xbf, 0xc7, 0xf9, 0x3f, 0x77, 0x1a, 0x65, 0xdc, 0xfa, 0x53, 0xaa, 0xa9, 0x41,
	0xf7, 0x46, 0x0d, 0x3e, 0x28, 0xfe, 0x7f, 0x78, 0x26, 0xc4, 0xd3, 0x20, 0xbd, 0xa4, 0xef, 0x40,
	0x3f, 0x4e, 0x4c, 0x03, 0x6a, 0x21, 0x8e, 0x92, 0x48, 0x15, 0xf1, 0xac, 0xb5, 0x55, 0xe3, 0x58,
	0x41, 0x24, 0x8f, 0xe6, 0x71, 0x4c, 0xaa, 0xd7, 0x81, 0x4a, 0xcc, 0xff, 0xdd, 0x31, 0x7a, 0x7d,
	0xeb, 0x3d, 0xb9, 0x0f, 0x40, 0x57, 0x16, 0x1d, 0x4f, 0x1d, 0xd1, 0x63, 0x35, 0x70, 0x9c, 0xfd,
	0x5c, 0xf2, 0xb0, 0x20, 0x99, 0x5b, 0xbc, 0x86, 0xfd, 0x13, 0x18, 0x5a, 0x17, 0x40, 0x63, 0xa7,
	0x3b, 0x37, 0xec, 0xf4, 0xfa, 0x85, 0xd2, 0x59, 0x7c, 0xa1, 0x1c, 0x8c, 0x5f, 0x5e, 0x8d, 0x9c,
	0x57, 0x57, 0x23, 0xe7, 0xef, 0xab, 0x91, 0xf3, 0xd3, 0xf5, 0x68, 0xe9, 0xd5, 0xf5, 0x68, 0xe9,
	0xcf, 0xeb, 0xd1, 0xd2, 0xb7, 0xcb, 0xdb, 0x1f, 0xe3, 0xff, 0xc1, 0xff, 0x05, 0x00, 0x00, 0xff,
	0xff, 0x9c, 0x25, 0xda, 0xde, 0x0e, 0x0f, 0x00, 0x00,
}

func (m *D6D8ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D6D8ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D6D8ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupSpaceReq != nil {
		{
			size, err := m.GroupSpaceReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.GroupFileCountReq != nil {
		{
			size, err := m.GroupFileCountReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FileListInfoReq != nil {
		{
			size, err := m.FileListInfoReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FileInfoReq != nil {
		{
			size, err := m.FileInfoReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *D6D8RspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D6D8RspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D6D8RspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupSpaceRsp != nil {
		{
			size, err := m.GroupSpaceRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.FileCountRsp != nil {
		{
			size, err := m.FileCountRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FileListInfoRsp != nil {
		{
			size, err := m.FileListInfoRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FileInfoRsp != nil {
		{
			size, err := m.FileInfoRsp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFileInfoReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileInfoReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileInfoReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.FieldFlag))
	i--
	dAtA[i] = 0x28
	i -= len(m.FileId)
	copy(dAtA[i:], m.FileId)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.FileId)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.BusId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.AppId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetFileInfoRspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileInfoRspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileInfoRspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileInfo != nil {
		{
			size, err := m.FileInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.ClientWording)
	copy(dAtA[i:], m.ClientWording)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.ClientWording)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.RetMsg)
	copy(dAtA[i:], m.RetMsg)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.RetMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.RetCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetFileListRspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileListRspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileListRspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.OpenFlag))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.Role))
	i--
	dAtA[i] = 0x78
	if m.Context != nil {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x72
	}
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.NextIndex))
	i--
	dAtA[i] = 0x68
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.SafeCheckRes))
	i--
	dAtA[i] = 0x60
	i--
	if m.SafeCheckFlag {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x58
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.FilterCode))
	i--
	dAtA[i] = 0x40
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.AllFileCount))
	i--
	dAtA[i] = 0x38
	if m.MaxTimestamp != nil {
		{
			size, err := m.MaxTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ItemList) > 0 {
		for iNdEx := len(m.ItemList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	i--
	if m.IsEnd {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	i -= len(m.ClientWording)
	copy(dAtA[i:], m.ClientWording)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.ClientWording)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.RetMsg)
	copy(dAtA[i:], m.RetMsg)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.RetMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.RetCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetFileListRspBody_Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileListRspBody_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileListRspBody_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileInfo != nil {
		{
			size, err := m.FileInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FolderInfo != nil {
		{
			size, err := m.FolderInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.Type))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GroupFileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupFileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupFileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.ParentFolderId)
	copy(dAtA[i:], m.ParentFolderId)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.ParentFolderId)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.UploaderUin))
	i--
	dAtA[i] = 0x78
	i -= len(m.UploaderName)
	copy(dAtA[i:], m.UploaderName)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.UploaderName)))
	i--
	dAtA[i] = 0x72
	i -= len(m.LocalPath)
	copy(dAtA[i:], m.LocalPath)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.LocalPath)))
	i--
	dAtA[i] = 0x6a
	if m.Md5 != nil {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x62
	}
	if m.Sha3 != nil {
		i -= len(m.Sha3)
		copy(dAtA[i:], m.Sha3)
		i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.Sha3)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Sha != nil {
		i -= len(m.Sha)
		copy(dAtA[i:], m.Sha)
		i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.Sha)))
		i--
		dAtA[i] = 0x52
	}
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.DownloadTimes))
	i--
	dAtA[i] = 0x48
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.ModifyTime))
	i--
	dAtA[i] = 0x40
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.DeadTime))
	i--
	dAtA[i] = 0x38
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.UploadTime))
	i--
	dAtA[i] = 0x30
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.UploadedSize))
	i--
	dAtA[i] = 0x28
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.BusId))
	i--
	dAtA[i] = 0x20
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.FileSize))
	i--
	dAtA[i] = 0x18
	i -= len(m.FileName)
	copy(dAtA[i:], m.FileName)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.FileName)))
	i--
	dAtA[i] = 0x12
	i -= len(m.FileId)
	copy(dAtA[i:], m.FileId)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.FileId)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GroupFolderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupFolderInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupFolderInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.TotalFileCount))
	i--
	dAtA[i] = 0x40
	i -= len(m.CreatorName)
	copy(dAtA[i:], m.CreatorName)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.CreatorName)))
	i--
	dAtA[i] = 0x3a
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.CreateUin))
	i--
	dAtA[i] = 0x30
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.ModifyTime))
	i--
	dAtA[i] = 0x28
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.CreateTime))
	i--
	dAtA[i] = 0x20
	i -= len(m.FolderName)
	copy(dAtA[i:], m.FolderName)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.FolderName)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.ParentFolderId)
	copy(dAtA[i:], m.ParentFolderId)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.ParentFolderId)))
	i--
	dAtA[i] = 0x12
	i -= len(m.FolderId)
	copy(dAtA[i:], m.FolderId)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.FolderId)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetFileListReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileListReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileListReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.ClientVersion))
	i--
	dAtA[i] = 0x78
	if m.Context != nil {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x72
	}
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.StartIndex))
	i--
	dAtA[i] = 0x68
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.FieldFlag))
	i--
	dAtA[i] = 0x60
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.Uin))
	i--
	dAtA[i] = 0x58
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.FilterCode))
	i--
	dAtA[i] = 0x50
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.SortBy))
	i--
	dAtA[i] = 0x48
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.ReqFrom))
	i--
	dAtA[i] = 0x40
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.AllFileCount))
	i--
	dAtA[i] = 0x38
	if m.MaxTimestamp != nil {
		{
			size, err := m.MaxTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.FileCount))
	i--
	dAtA[i] = 0x28
	if m.StartTimestamp != nil {
		{
			size, err := m.StartTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0X6D8(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	i -= len(m.FolderId)
	copy(dAtA[i:], m.FolderId)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.FolderId)))
	i--
	dAtA[i] = 0x1a
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.AppId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetFileCountReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileCountReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileCountReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.BusId))
	i--
	dAtA[i] = 0x18
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.AppId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetSpaceReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpaceReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpaceReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.AppId))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.GroupCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetFileCountRspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileCountRspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileCountRspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.IsFull {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x38
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.LimitCount))
	i--
	dAtA[i] = 0x30
	i--
	if m.FileTooMany {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.AllFileCount))
	i--
	dAtA[i] = 0x20
	i -= len(m.ClientWording)
	copy(dAtA[i:], m.ClientWording)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.ClientWording)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.RetMsg)
	copy(dAtA[i:], m.RetMsg)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.RetMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.RetCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *GetSpaceRspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSpaceRspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSpaceRspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.UsedSpace))
	i--
	dAtA[i] = 0x28
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.TotalSpace))
	i--
	dAtA[i] = 0x20
	i -= len(m.ClientWording)
	copy(dAtA[i:], m.ClientWording)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.ClientWording)))
	i--
	dAtA[i] = 0x1a
	i -= len(m.RetMsg)
	copy(dAtA[i:], m.RetMsg)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.RetMsg)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.RetCode))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *FileTimeStamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileTimeStamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileTimeStamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.FileId)
	copy(dAtA[i:], m.FileId)
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(len(m.FileId)))
	i--
	dAtA[i] = 0x12
	i = encodeVarintOidb0X6D8(dAtA, i, uint64(m.UploadTime))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func encodeVarintOidb0X6D8(dAtA []byte, offset int, v uint64) int {
	offset -= sovOidb0X6D8(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *D6D8ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileInfoReq != nil {
		l = m.FileInfoReq.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.FileListInfoReq != nil {
		l = m.FileListInfoReq.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.GroupFileCountReq != nil {
		l = m.GroupFileCountReq.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.GroupSpaceReq != nil {
		l = m.GroupSpaceReq.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	return n
}

func (m *D6D8RspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileInfoRsp != nil {
		l = m.FileInfoRsp.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.FileListInfoRsp != nil {
		l = m.FileListInfoRsp.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.FileCountRsp != nil {
		l = m.FileCountRsp.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.GroupSpaceRsp != nil {
		l = m.GroupSpaceRsp.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	return n
}

func (m *GetFileInfoReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.GroupCode))
	n += 1 + sovOidb0X6D8(uint64(m.AppId))
	n += 1 + sovOidb0X6D8(uint64(m.BusId))
	l = len(m.FileId)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 1 + sovOidb0X6D8(uint64(m.FieldFlag))
	return n
}

func (m *GetFileInfoRspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.RetCode))
	l = len(m.RetMsg)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.ClientWording)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	if m.FileInfo != nil {
		l = m.FileInfo.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	return n
}

func (m *GetFileListRspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.RetCode))
	l = len(m.RetMsg)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.ClientWording)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 2
	if len(m.ItemList) > 0 {
		for _, e := range m.ItemList {
			l = e.Size()
			n += 1 + l + sovOidb0X6D8(uint64(l))
		}
	}
	if m.MaxTimestamp != nil {
		l = m.MaxTimestamp.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	n += 1 + sovOidb0X6D8(uint64(m.AllFileCount))
	n += 1 + sovOidb0X6D8(uint64(m.FilterCode))
	n += 2
	n += 1 + sovOidb0X6D8(uint64(m.SafeCheckRes))
	n += 1 + sovOidb0X6D8(uint64(m.NextIndex))
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	n += 1 + sovOidb0X6D8(uint64(m.Role))
	n += 2 + sovOidb0X6D8(uint64(m.OpenFlag))
	return n
}

func (m *GetFileListRspBody_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.Type))
	if m.FolderInfo != nil {
		l = m.FolderInfo.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.FileInfo != nil {
		l = m.FileInfo.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	return n
}

func (m *GroupFileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileId)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.FileName)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 1 + sovOidb0X6D8(uint64(m.FileSize))
	n += 1 + sovOidb0X6D8(uint64(m.BusId))
	n += 1 + sovOidb0X6D8(uint64(m.UploadedSize))
	n += 1 + sovOidb0X6D8(uint64(m.UploadTime))
	n += 1 + sovOidb0X6D8(uint64(m.DeadTime))
	n += 1 + sovOidb0X6D8(uint64(m.ModifyTime))
	n += 1 + sovOidb0X6D8(uint64(m.DownloadTimes))
	if m.Sha != nil {
		l = len(m.Sha)
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.Sha3 != nil {
		l = len(m.Sha3)
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	if m.Md5 != nil {
		l = len(m.Md5)
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	l = len(m.LocalPath)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.UploaderName)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 1 + sovOidb0X6D8(uint64(m.UploaderUin))
	l = len(m.ParentFolderId)
	n += 2 + l + sovOidb0X6D8(uint64(l))
	return n
}

func (m *GroupFolderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FolderId)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.ParentFolderId)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.FolderName)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 1 + sovOidb0X6D8(uint64(m.CreateTime))
	n += 1 + sovOidb0X6D8(uint64(m.ModifyTime))
	n += 1 + sovOidb0X6D8(uint64(m.CreateUin))
	l = len(m.CreatorName)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 1 + sovOidb0X6D8(uint64(m.TotalFileCount))
	return n
}

func (m *GetFileListReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.GroupCode))
	n += 1 + sovOidb0X6D8(uint64(m.AppId))
	l = len(m.FolderId)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	if m.StartTimestamp != nil {
		l = m.StartTimestamp.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	n += 1 + sovOidb0X6D8(uint64(m.FileCount))
	if m.MaxTimestamp != nil {
		l = m.MaxTimestamp.Size()
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	n += 1 + sovOidb0X6D8(uint64(m.AllFileCount))
	n += 1 + sovOidb0X6D8(uint64(m.ReqFrom))
	n += 1 + sovOidb0X6D8(uint64(m.SortBy))
	n += 1 + sovOidb0X6D8(uint64(m.FilterCode))
	n += 1 + sovOidb0X6D8(uint64(m.Uin))
	n += 1 + sovOidb0X6D8(uint64(m.FieldFlag))
	n += 1 + sovOidb0X6D8(uint64(m.StartIndex))
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovOidb0X6D8(uint64(l))
	}
	n += 1 + sovOidb0X6D8(uint64(m.ClientVersion))
	return n
}

func (m *GetFileCountReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.GroupCode))
	n += 1 + sovOidb0X6D8(uint64(m.AppId))
	n += 1 + sovOidb0X6D8(uint64(m.BusId))
	return n
}

func (m *GetSpaceReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.GroupCode))
	n += 1 + sovOidb0X6D8(uint64(m.AppId))
	return n
}

func (m *GetFileCountRspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.RetCode))
	l = len(m.RetMsg)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.ClientWording)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 1 + sovOidb0X6D8(uint64(m.AllFileCount))
	n += 2
	n += 1 + sovOidb0X6D8(uint64(m.LimitCount))
	n += 2
	return n
}

func (m *GetSpaceRspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.RetCode))
	l = len(m.RetMsg)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	l = len(m.ClientWording)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	n += 1 + sovOidb0X6D8(uint64(m.TotalSpace))
	n += 1 + sovOidb0X6D8(uint64(m.UsedSpace))
	return n
}

func (m *FileTimeStamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0X6D8(uint64(m.UploadTime))
	l = len(m.FileId)
	n += 1 + l + sovOidb0X6D8(uint64(l))
	return n
}

func sovOidb0X6D8(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOidb0X6D8(x uint64) (n int) {
	return sovOidb0X6D8(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *D6D8ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D6D8ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D6D8ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfoReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfoReq == nil {
				m.FileInfoReq = &GetFileInfoReqBody{}
			}
			if err := m.FileInfoReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileListInfoReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileListInfoReq == nil {
				m.FileListInfoReq = &GetFileListReqBody{}
			}
			if err := m.FileListInfoReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFileCountReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupFileCountReq == nil {
				m.GroupFileCountReq = &GetFileCountReqBody{}
			}
			if err := m.GroupFileCountReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSpaceReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupSpaceReq == nil {
				m.GroupSpaceReq = &GetSpaceReqBody{}
			}
			if err := m.GroupSpaceReq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D6D8RspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D6D8RspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D6D8RspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfoRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfoRsp == nil {
				m.FileInfoRsp = &GetFileInfoRspBody{}
			}
			if err := m.FileInfoRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileListInfoRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileListInfoRsp == nil {
				m.FileListInfoRsp = &GetFileListRspBody{}
			}
			if err := m.FileListInfoRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCountRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileCountRsp == nil {
				m.FileCountRsp = &GetFileCountRspBody{}
			}
			if err := m.FileCountRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSpaceRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupSpaceRsp == nil {
				m.GroupSpaceRsp = &GetSpaceRspBody{}
			}
			if err := m.GroupSpaceRsp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileInfoReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileInfoReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileInfoReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusId", wireType)
			}
			m.BusId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldFlag", wireType)
			}
			m.FieldFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileInfoRspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileInfoRspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileInfoRspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientWording", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientWording = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = &GroupFileInfo{}
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileListRspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileListRspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileListRspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientWording", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientWording = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemList = append(m.ItemList, &GetFileListRspBody_Item{})
			if err := m.ItemList[len(m.ItemList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTimestamp == nil {
				m.MaxTimestamp = &FileTimeStamp{}
			}
			if err := m.MaxTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFileCount", wireType)
			}
			m.AllFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFileCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterCode", wireType)
			}
			m.FilterCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeCheckFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SafeCheckFlag = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SafeCheckRes", wireType)
			}
			m.SafeCheckRes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SafeCheckRes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextIndex", wireType)
			}
			m.NextIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFlag", wireType)
			}
			m.OpenFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileListRspBody_Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FolderInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FolderInfo == nil {
				m.FolderInfo = &GroupFolderInfo{}
			}
			if err := m.FolderInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = &GroupFileInfo{}
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupFileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupFileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupFileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusId", wireType)
			}
			m.BusId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedSize", wireType)
			}
			m.UploadedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeadTime", wireType)
			}
			m.DeadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeadTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyTime", wireType)
			}
			m.ModifyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTimes", wireType)
			}
			m.DownloadTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadTimes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha = append(m.Sha[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha == nil {
				m.Sha = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha3", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha3 = append(m.Sha3[:0], dAtA[iNdEx:postIndex]...)
			if m.Sha3 == nil {
				m.Sha3 = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = append(m.Md5[:0], dAtA[iNdEx:postIndex]...)
			if m.Md5 == nil {
				m.Md5 = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploaderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploaderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploaderUin", wireType)
			}
			m.UploaderUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploaderUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentFolderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentFolderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupFolderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupFolderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupFolderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FolderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FolderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentFolderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentFolderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FolderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FolderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyTime", wireType)
			}
			m.ModifyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateUin", wireType)
			}
			m.CreateUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFileCount", wireType)
			}
			m.TotalFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFileCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileListReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileListReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileListReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FolderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FolderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTimestamp == nil {
				m.StartTimestamp = &FileTimeStamp{}
			}
			if err := m.StartTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCount", wireType)
			}
			m.FileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxTimestamp == nil {
				m.MaxTimestamp = &FileTimeStamp{}
			}
			if err := m.MaxTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFileCount", wireType)
			}
			m.AllFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFileCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqFrom", wireType)
			}
			m.ReqFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqFrom |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortBy", wireType)
			}
			m.SortBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SortBy |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterCode", wireType)
			}
			m.FilterCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldFlag", wireType)
			}
			m.FieldFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			m.ClientVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileCountReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileCountReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileCountReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusId", wireType)
			}
			m.BusId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpaceReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpaceReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpaceReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileCountRspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileCountRspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileCountRspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientWording", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientWording = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFileCount", wireType)
			}
			m.AllFileCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFileCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTooMany", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FileTooMany = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitCount", wireType)
			}
			m.LimitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFull = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSpaceRspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSpaceRspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSpaceRspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RetMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientWording", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientWording = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSpace", wireType)
			}
			m.TotalSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSpace", wireType)
			}
			m.UsedSpace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSpace |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileTimeStamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileTimeStamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileTimeStamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			m.UploadTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0X6D8(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0X6D8
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOidb0X6D8(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOidb0X6D8
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb0X6D8
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOidb0X6D8
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOidb0X6D8
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOidb0X6D8
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOidb0X6D8        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOidb0X6D8          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOidb0X6D8 = fmt.Errorf("proto: unexpected end of group")
)
