// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pb/oidb/oidb0xec4.proto

package oidb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Comment struct {
	Id       string `protobuf:"bytes,1,opt,name=id" json:"id"`
	Comment  string `protobuf:"bytes,2,opt,name=comment" json:"comment"`
	Time     uint64 `protobuf:"varint,3,opt,name=time" json:"time"`
	FromUin  uint64 `protobuf:"varint,4,opt,name=fromUin" json:"fromUin"`
	ToUin    uint64 `protobuf:"varint,5,opt,name=toUin" json:"toUin"`
	ReplyId  string `protobuf:"bytes,6,opt,name=replyId" json:"replyId"`
	FromNick string `protobuf:"bytes,7,opt,name=fromNick" json:"fromNick"`
}

func (m *Comment) Reset()         { *m = Comment{} }
func (m *Comment) String() string { return proto.CompactTextString(m) }
func (*Comment) ProtoMessage()    {}
func (*Comment) Descriptor() ([]byte, []int) {
	return fileDescriptor_44ea2b0b0ef6242a, []int{0}
}
func (m *Comment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Comment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Comment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Comment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Comment.Merge(m, src)
}
func (m *Comment) XXX_Size() int {
	return m.Size()
}
func (m *Comment) XXX_DiscardUnknown() {
	xxx_messageInfo_Comment.DiscardUnknown(m)
}

var xxx_messageInfo_Comment proto.InternalMessageInfo

func (m *Comment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Comment) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *Comment) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Comment) GetFromUin() uint64 {
	if m != nil {
		return m.FromUin
	}
	return 0
}

func (m *Comment) GetToUin() uint64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *Comment) GetReplyId() string {
	if m != nil {
		return m.ReplyId
	}
	return ""
}

func (m *Comment) GetFromNick() string {
	if m != nil {
		return m.FromNick
	}
	return ""
}

type Praise struct {
	FromUin  uint64 `protobuf:"varint,1,opt,name=fromUin" json:"fromUin"`
	ToUin    uint64 `protobuf:"varint,2,opt,name=toUin" json:"toUin"`
	Time     uint64 `protobuf:"varint,3,opt,name=time" json:"time"`
	FromNick string `protobuf:"bytes,4,opt,name=fromNick" json:"fromNick"`
}

func (m *Praise) Reset()         { *m = Praise{} }
func (m *Praise) String() string { return proto.CompactTextString(m) }
func (*Praise) ProtoMessage()    {}
func (*Praise) Descriptor() ([]byte, []int) {
	return fileDescriptor_44ea2b0b0ef6242a, []int{1}
}
func (m *Praise) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Praise) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Praise.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Praise) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Praise.Merge(m, src)
}
func (m *Praise) XXX_Size() int {
	return m.Size()
}
func (m *Praise) XXX_DiscardUnknown() {
	xxx_messageInfo_Praise.DiscardUnknown(m)
}

var xxx_messageInfo_Praise proto.InternalMessageInfo

func (m *Praise) GetFromUin() uint64 {
	if m != nil {
		return m.FromUin
	}
	return 0
}

func (m *Praise) GetToUin() uint64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *Praise) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Praise) GetFromNick() string {
	if m != nil {
		return m.FromNick
	}
	return ""
}

type Quest struct {
	Id          string     `protobuf:"bytes,1,opt,name=id" json:"id"`
	Quest       string     `protobuf:"bytes,2,opt,name=quest" json:"quest"`
	QuestUin    uint64     `protobuf:"varint,3,opt,name=questUin" json:"questUin"`
	Time        uint64     `protobuf:"varint,4,opt,name=time" json:"time"`
	Ans         string     `protobuf:"bytes,5,opt,name=ans" json:"ans"`
	AnsTime     uint64     `protobuf:"varint,6,opt,name=ansTime" json:"ansTime"`
	Comment     []*Comment `protobuf:"bytes,7,rep,name=comment" json:"comment,omitempty"`
	Praise      []*Praise  `protobuf:"bytes,8,rep,name=praise" json:"praise,omitempty"`
	PraiseNum   uint64     `protobuf:"varint,9,opt,name=praiseNum" json:"praiseNum"`
	LikeKey     string     `protobuf:"bytes,10,opt,name=likeKey" json:"likeKey"`
	SystemId    uint64     `protobuf:"varint,11,opt,name=systemId" json:"systemId"`
	CommentNum  uint64     `protobuf:"varint,12,opt,name=commentNum" json:"commentNum"`
	ShowType    uint64     `protobuf:"varint,13,opt,name=showType" json:"showType"`
	ShowTimes   uint64     `protobuf:"varint,14,opt,name=showTimes" json:"showTimes"`
	BeenPraised uint64     `protobuf:"varint,15,opt,name=beenPraised" json:"beenPraised"`
	QuestRead   bool       `protobuf:"varint,16,opt,name=questRead" json:"questRead"`
	AnsShowType uint64     `protobuf:"varint,17,opt,name=ansShowType" json:"ansShowType"`
}

func (m *Quest) Reset()         { *m = Quest{} }
func (m *Quest) String() string { return proto.CompactTextString(m) }
func (*Quest) ProtoMessage()    {}
func (*Quest) Descriptor() ([]byte, []int) {
	return fileDescriptor_44ea2b0b0ef6242a, []int{2}
}
func (m *Quest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Quest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Quest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Quest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Quest.Merge(m, src)
}
func (m *Quest) XXX_Size() int {
	return m.Size()
}
func (m *Quest) XXX_DiscardUnknown() {
	xxx_messageInfo_Quest.DiscardUnknown(m)
}

var xxx_messageInfo_Quest proto.InternalMessageInfo

func (m *Quest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Quest) GetQuest() string {
	if m != nil {
		return m.Quest
	}
	return ""
}

func (m *Quest) GetQuestUin() uint64 {
	if m != nil {
		return m.QuestUin
	}
	return 0
}

func (m *Quest) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Quest) GetAns() string {
	if m != nil {
		return m.Ans
	}
	return ""
}

func (m *Quest) GetAnsTime() uint64 {
	if m != nil {
		return m.AnsTime
	}
	return 0
}

func (m *Quest) GetComment() []*Comment {
	if m != nil {
		return m.Comment
	}
	return nil
}

func (m *Quest) GetPraise() []*Praise {
	if m != nil {
		return m.Praise
	}
	return nil
}

func (m *Quest) GetPraiseNum() uint64 {
	if m != nil {
		return m.PraiseNum
	}
	return 0
}

func (m *Quest) GetLikeKey() string {
	if m != nil {
		return m.LikeKey
	}
	return ""
}

func (m *Quest) GetSystemId() uint64 {
	if m != nil {
		return m.SystemId
	}
	return 0
}

func (m *Quest) GetCommentNum() uint64 {
	if m != nil {
		return m.CommentNum
	}
	return 0
}

func (m *Quest) GetShowType() uint64 {
	if m != nil {
		return m.ShowType
	}
	return 0
}

func (m *Quest) GetShowTimes() uint64 {
	if m != nil {
		return m.ShowTimes
	}
	return 0
}

func (m *Quest) GetBeenPraised() uint64 {
	if m != nil {
		return m.BeenPraised
	}
	return 0
}

func (m *Quest) GetQuestRead() bool {
	if m != nil {
		return m.QuestRead
	}
	return false
}

func (m *Quest) GetAnsShowType() uint64 {
	if m != nil {
		return m.AnsShowType
	}
	return 0
}

type DEC4ReqBody struct {
	Uin        uint64 `protobuf:"varint,1,opt,name=uin" json:"uin"`
	QuestNum   uint64 `protobuf:"varint,2,opt,name=questNum" json:"questNum"`
	CommentNum uint64 `protobuf:"varint,3,opt,name=commentNum" json:"commentNum"`
	Cookie     []byte `protobuf:"bytes,4,opt,name=cookie" json:"cookie"`
	FetchType  uint32 `protobuf:"varint,5,opt,name=fetchType" json:"fetchType"`
}

func (m *DEC4ReqBody) Reset()         { *m = DEC4ReqBody{} }
func (m *DEC4ReqBody) String() string { return proto.CompactTextString(m) }
func (*DEC4ReqBody) ProtoMessage()    {}
func (*DEC4ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_44ea2b0b0ef6242a, []int{3}
}
func (m *DEC4ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DEC4ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DEC4ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DEC4ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DEC4ReqBody.Merge(m, src)
}
func (m *DEC4ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *DEC4ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_DEC4ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_DEC4ReqBody proto.InternalMessageInfo

func (m *DEC4ReqBody) GetUin() uint64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *DEC4ReqBody) GetQuestNum() uint64 {
	if m != nil {
		return m.QuestNum
	}
	return 0
}

func (m *DEC4ReqBody) GetCommentNum() uint64 {
	if m != nil {
		return m.CommentNum
	}
	return 0
}

func (m *DEC4ReqBody) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *DEC4ReqBody) GetFetchType() uint32 {
	if m != nil {
		return m.FetchType
	}
	return 0
}

type DEC4RspBody struct {
	Quest            []*Quest `protobuf:"bytes,1,rep,name=quest" json:"quest,omitempty"`
	IsFetchOver      bool     `protobuf:"varint,2,opt,name=isFetchOver" json:"isFetchOver"`
	TotalQuestNum    uint32   `protobuf:"varint,3,opt,name=totalQuestNum" json:"totalQuestNum"`
	Cookie           []byte   `protobuf:"bytes,4,opt,name=cookie" json:"cookie"`
	Ret              uint32   `protobuf:"varint,5,opt,name=ret" json:"ret"`
	AnsweredQuestNum uint32   `protobuf:"varint,6,opt,name=answeredQuestNum" json:"answeredQuestNum"`
}

func (m *DEC4RspBody) Reset()         { *m = DEC4RspBody{} }
func (m *DEC4RspBody) String() string { return proto.CompactTextString(m) }
func (*DEC4RspBody) ProtoMessage()    {}
func (*DEC4RspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_44ea2b0b0ef6242a, []int{4}
}
func (m *DEC4RspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DEC4RspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DEC4RspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DEC4RspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DEC4RspBody.Merge(m, src)
}
func (m *DEC4RspBody) XXX_Size() int {
	return m.Size()
}
func (m *DEC4RspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_DEC4RspBody.DiscardUnknown(m)
}

var xxx_messageInfo_DEC4RspBody proto.InternalMessageInfo

func (m *DEC4RspBody) GetQuest() []*Quest {
	if m != nil {
		return m.Quest
	}
	return nil
}

func (m *DEC4RspBody) GetIsFetchOver() bool {
	if m != nil {
		return m.IsFetchOver
	}
	return false
}

func (m *DEC4RspBody) GetTotalQuestNum() uint32 {
	if m != nil {
		return m.TotalQuestNum
	}
	return 0
}

func (m *DEC4RspBody) GetCookie() []byte {
	if m != nil {
		return m.Cookie
	}
	return nil
}

func (m *DEC4RspBody) GetRet() uint32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

func (m *DEC4RspBody) GetAnsweredQuestNum() uint32 {
	if m != nil {
		return m.AnsweredQuestNum
	}
	return 0
}

func init() {
	proto.RegisterType((*Comment)(nil), "Comment")
	proto.RegisterType((*Praise)(nil), "Praise")
	proto.RegisterType((*Quest)(nil), "Quest")
	proto.RegisterType((*DEC4ReqBody)(nil), "DEC4ReqBody")
	proto.RegisterType((*DEC4RspBody)(nil), "DEC4RspBody")
}

func init() { proto.RegisterFile("client/pb/oidb/oidb0xec4.proto", fileDescriptor_44ea2b0b0ef6242a) }

var fileDescriptor_44ea2b0b0ef6242a = []byte{
	// 598 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xc7, 0xb3, 0xb1, 0xe3, 0x24, 0x93, 0xe6, 0xf7, 0x2b, 0x16, 0xaa, 0x56, 0x55, 0xe5, 0x5a,
	0x16, 0xaa, 0x22, 0x0e, 0x69, 0x85, 0x7a, 0xe3, 0x96, 0x02, 0x52, 0x85, 0x54, 0x68, 0x28, 0x17,
	0x6e, 0xae, 0xbd, 0x55, 0x57, 0x89, 0xff, 0xd4, 0xeb, 0x50, 0x72, 0xe3, 0x11, 0x78, 0x13, 0xae,
	0x3c, 0x42, 0x8f, 0xbd, 0xc1, 0x09, 0xa1, 0xe4, 0xc0, 0x6b, 0xa0, 0x59, 0x7b, 0x9d, 0x35, 0x21,
	0x70, 0x89, 0x56, 0x9f, 0x99, 0x9d, 0xf9, 0xce, 0x77, 0x27, 0x06, 0x27, 0x98, 0x72, 0x16, 0xe7,
	0x87, 0xe9, 0xe5, 0x61, 0xc2, 0xc3, 0xe2, 0xe7, 0xe8, 0x03, 0x0b, 0x8e, 0x87, 0x69, 0x96, 0xe4,
	0x89, 0xf7, 0x95, 0x40, 0xfb, 0x24, 0x89, 0x22, 0x16, 0xe7, 0xf6, 0x43, 0x68, 0xf2, 0x90, 0x12,
	0x97, 0x0c, 0xba, 0x23, 0xf3, 0xee, 0xfb, 0x7e, 0x63, 0xdc, 0xe4, 0xa1, 0xed, 0x40, 0x3b, 0x28,
	0x12, 0x68, 0x53, 0x0b, 0x29, 0x68, 0x53, 0x30, 0x73, 0x1e, 0x31, 0x6a, 0xb8, 0x64, 0x60, 0x96,
	0x41, 0x49, 0xf0, 0xe6, 0x55, 0x96, 0x44, 0x6f, 0x79, 0x4c, 0x4d, 0x2d, 0xa8, 0xa0, 0xbd, 0x0b,
	0xad, 0x3c, 0xc1, 0x68, 0x4b, 0x8b, 0x16, 0x08, 0xef, 0x66, 0x2c, 0x9d, 0xce, 0x4f, 0x43, 0x6a,
	0xe9, 0x5d, 0x4b, 0x68, 0xbb, 0xd0, 0xc1, 0x32, 0x67, 0x3c, 0x98, 0xd0, 0xb6, 0x96, 0x50, 0x51,
	0xef, 0x23, 0x01, 0xeb, 0x75, 0xe6, 0x73, 0x51, 0x13, 0x42, 0xfe, 0x2a, 0xa4, 0xb9, 0x2e, 0x64,
	0xf3, 0x78, 0xba, 0x04, 0xf3, 0x8f, 0x12, 0xbe, 0x98, 0xd0, 0x3a, 0x9f, 0x31, 0xb1, 0xc9, 0xda,
	0x5d, 0x68, 0xdd, 0x60, 0xb8, 0x66, 0x6c, 0x81, 0xb0, 0xba, 0x3c, 0xa0, 0x2c, 0xbd, 0x77, 0x45,
	0x2b, 0x65, 0xe6, 0x9a, 0xb2, 0x1d, 0x30, 0xfc, 0x58, 0x48, 0x5b, 0x55, 0x55, 0x04, 0xe8, 0x83,
	0x1f, 0x8b, 0x0b, 0xbc, 0x64, 0xe9, 0x3e, 0x94, 0xd0, 0xf6, 0x56, 0x4f, 0xdd, 0x76, 0x8d, 0x41,
	0xef, 0x49, 0x67, 0x58, 0xee, 0xc6, 0xea, 0xb9, 0xf7, 0xc1, 0x4a, 0xa5, 0xab, 0xb4, 0x23, 0x53,
	0xda, 0xc3, 0xc2, 0xe4, 0x71, 0x89, 0x6d, 0x0f, 0xba, 0xc5, 0xe9, 0x6c, 0x16, 0xd1, 0xae, 0xd6,
	0x66, 0x85, 0x51, 0xc8, 0x94, 0x4f, 0xd8, 0x4b, 0x36, 0xa7, 0xa0, 0xbf, 0x6e, 0x09, 0x71, 0x78,
	0x31, 0x17, 0x39, 0x8b, 0x4e, 0x43, 0xda, 0xd3, 0x87, 0x57, 0xd4, 0x7e, 0x04, 0x50, 0x2a, 0xc2,
	0x36, 0x5b, 0x5a, 0x8e, 0xc6, 0x65, 0x9d, 0xeb, 0xe4, 0xf6, 0x62, 0x9e, 0x32, 0xda, 0xaf, 0xd5,
	0x29, 0x29, 0xaa, 0x95, 0x67, 0x1e, 0x31, 0x41, 0xff, 0xd3, 0xd5, 0x56, 0xd8, 0x3e, 0x80, 0xde,
	0x25, 0x63, 0x71, 0x31, 0x67, 0x48, 0xff, 0xd7, 0xb2, 0xf4, 0x00, 0xd6, 0x92, 0x8f, 0x33, 0x66,
	0x7e, 0x48, 0xb7, 0x5d, 0x32, 0xe8, 0xa8, 0x5a, 0x15, 0xc6, 0x5a, 0x7e, 0x2c, 0xde, 0x28, 0x51,
	0x0f, 0xf4, 0x5a, 0x5a, 0xc0, 0xfb, 0x4c, 0xa0, 0xf7, 0xec, 0xf9, 0xc9, 0xf1, 0x98, 0xdd, 0x8c,
	0x92, 0x70, 0x8e, 0x4f, 0x3a, 0xfb, 0x6d, 0x7d, 0x11, 0x54, 0x6b, 0x82, 0x2e, 0x34, 0xd7, 0xd6,
	0x04, 0x3d, 0xa8, 0x3b, 0x65, 0x6c, 0x70, 0x6a, 0x0f, 0xac, 0x20, 0x49, 0x26, 0xbc, 0x58, 0xa7,
	0xad, 0x32, 0xa3, 0x64, 0x38, 0xd9, 0x15, 0xcb, 0x83, 0x6b, 0xa9, 0x19, 0xd7, 0xaa, 0xaf, 0x26,
	0xab, 0xb0, 0xf7, 0x53, 0x29, 0x16, 0xa9, 0x54, 0xbc, 0xa7, 0x96, 0x9b, 0xc8, 0x3d, 0xb1, 0x86,
	0xf2, 0x9f, 0xa0, 0xd6, 0xfb, 0x00, 0x7a, 0x5c, 0xbc, 0xc0, 0xcb, 0xaf, 0xde, 0xb3, 0x4c, 0x4a,
	0x57, 0x6e, 0xe9, 0x01, 0xfb, 0x31, 0xf4, 0xf3, 0x24, 0xf7, 0xa7, 0xe7, 0x6a, 0x48, 0x43, 0xeb,
	0x5e, 0x0f, 0xfd, 0x63, 0x86, 0x1d, 0x30, 0x32, 0x96, 0xd7, 0xd4, 0x23, 0xb0, 0x8f, 0x60, 0xdb,
	0x8f, 0xc5, 0x2d, 0xcb, 0x58, 0x58, 0x35, 0xb1, 0xb4, 0xa4, 0xb5, 0xe8, 0xc8, 0xbd, 0x5b, 0x38,
	0xe4, 0x7e, 0xe1, 0x90, 0x1f, 0x0b, 0x87, 0x7c, 0x5a, 0x3a, 0x8d, 0xfb, 0xa5, 0xd3, 0xf8, 0xb6,
	0x74, 0x1a, 0xef, 0xac, 0xe1, 0x53, 0xfc, 0xc0, 0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xdc, 0x3c,
	0x49, 0x54, 0x76, 0x05, 0x00, 0x00,
}

func (m *Comment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Comment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Comment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.FromNick)
	copy(dAtA[i:], m.FromNick)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.FromNick)))
	i--
	dAtA[i] = 0x3a
	i -= len(m.ReplyId)
	copy(dAtA[i:], m.ReplyId)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.ReplyId)))
	i--
	dAtA[i] = 0x32
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x28
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.FromUin))
	i--
	dAtA[i] = 0x20
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x18
	i -= len(m.Comment)
	copy(dAtA[i:], m.Comment)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.Comment)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Id)
	copy(dAtA[i:], m.Id)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.Id)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Praise) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Praise) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Praise) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.FromNick)
	copy(dAtA[i:], m.FromNick)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.FromNick)))
	i--
	dAtA[i] = 0x22
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x18
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.ToUin))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.FromUin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Quest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Quest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Quest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.AnsShowType))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	i--
	if m.QuestRead {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x80
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.BeenPraised))
	i--
	dAtA[i] = 0x78
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.ShowTimes))
	i--
	dAtA[i] = 0x70
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.ShowType))
	i--
	dAtA[i] = 0x68
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.CommentNum))
	i--
	dAtA[i] = 0x60
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.SystemId))
	i--
	dAtA[i] = 0x58
	i -= len(m.LikeKey)
	copy(dAtA[i:], m.LikeKey)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.LikeKey)))
	i--
	dAtA[i] = 0x52
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.PraiseNum))
	i--
	dAtA[i] = 0x48
	if len(m.Praise) > 0 {
		for iNdEx := len(m.Praise) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Praise[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb0Xec4(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Comment) > 0 {
		for iNdEx := len(m.Comment) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Comment[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb0Xec4(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.AnsTime))
	i--
	dAtA[i] = 0x30
	i -= len(m.Ans)
	copy(dAtA[i:], m.Ans)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.Ans)))
	i--
	dAtA[i] = 0x2a
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.Time))
	i--
	dAtA[i] = 0x20
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.QuestUin))
	i--
	dAtA[i] = 0x18
	i -= len(m.Quest)
	copy(dAtA[i:], m.Quest)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.Quest)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Id)
	copy(dAtA[i:], m.Id)
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.Id)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DEC4ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DEC4ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DEC4ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.FetchType))
	i--
	dAtA[i] = 0x28
	if m.Cookie != nil {
		i -= len(m.Cookie)
		copy(dAtA[i:], m.Cookie)
		i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.Cookie)))
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.CommentNum))
	i--
	dAtA[i] = 0x18
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.QuestNum))
	i--
	dAtA[i] = 0x10
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.Uin))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *DEC4RspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DEC4RspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DEC4RspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.AnsweredQuestNum))
	i--
	dAtA[i] = 0x30
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.Ret))
	i--
	dAtA[i] = 0x28
	if m.Cookie != nil {
		i -= len(m.Cookie)
		copy(dAtA[i:], m.Cookie)
		i = encodeVarintOidb0Xec4(dAtA, i, uint64(len(m.Cookie)))
		i--
		dAtA[i] = 0x22
	}
	i = encodeVarintOidb0Xec4(dAtA, i, uint64(m.TotalQuestNum))
	i--
	dAtA[i] = 0x18
	i--
	if m.IsFetchOver {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	if len(m.Quest) > 0 {
		for iNdEx := len(m.Quest) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Quest[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb0Xec4(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintOidb0Xec4(dAtA []byte, offset int, v uint64) int {
	offset -= sovOidb0Xec4(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Comment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	l = len(m.Comment)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	n += 1 + sovOidb0Xec4(uint64(m.Time))
	n += 1 + sovOidb0Xec4(uint64(m.FromUin))
	n += 1 + sovOidb0Xec4(uint64(m.ToUin))
	l = len(m.ReplyId)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	l = len(m.FromNick)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	return n
}

func (m *Praise) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0Xec4(uint64(m.FromUin))
	n += 1 + sovOidb0Xec4(uint64(m.ToUin))
	n += 1 + sovOidb0Xec4(uint64(m.Time))
	l = len(m.FromNick)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	return n
}

func (m *Quest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	l = len(m.Quest)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	n += 1 + sovOidb0Xec4(uint64(m.QuestUin))
	n += 1 + sovOidb0Xec4(uint64(m.Time))
	l = len(m.Ans)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	n += 1 + sovOidb0Xec4(uint64(m.AnsTime))
	if len(m.Comment) > 0 {
		for _, e := range m.Comment {
			l = e.Size()
			n += 1 + l + sovOidb0Xec4(uint64(l))
		}
	}
	if len(m.Praise) > 0 {
		for _, e := range m.Praise {
			l = e.Size()
			n += 1 + l + sovOidb0Xec4(uint64(l))
		}
	}
	n += 1 + sovOidb0Xec4(uint64(m.PraiseNum))
	l = len(m.LikeKey)
	n += 1 + l + sovOidb0Xec4(uint64(l))
	n += 1 + sovOidb0Xec4(uint64(m.SystemId))
	n += 1 + sovOidb0Xec4(uint64(m.CommentNum))
	n += 1 + sovOidb0Xec4(uint64(m.ShowType))
	n += 1 + sovOidb0Xec4(uint64(m.ShowTimes))
	n += 1 + sovOidb0Xec4(uint64(m.BeenPraised))
	n += 3
	n += 2 + sovOidb0Xec4(uint64(m.AnsShowType))
	return n
}

func (m *DEC4ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovOidb0Xec4(uint64(m.Uin))
	n += 1 + sovOidb0Xec4(uint64(m.QuestNum))
	n += 1 + sovOidb0Xec4(uint64(m.CommentNum))
	if m.Cookie != nil {
		l = len(m.Cookie)
		n += 1 + l + sovOidb0Xec4(uint64(l))
	}
	n += 1 + sovOidb0Xec4(uint64(m.FetchType))
	return n
}

func (m *DEC4RspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Quest) > 0 {
		for _, e := range m.Quest {
			l = e.Size()
			n += 1 + l + sovOidb0Xec4(uint64(l))
		}
	}
	n += 2
	n += 1 + sovOidb0Xec4(uint64(m.TotalQuestNum))
	if m.Cookie != nil {
		l = len(m.Cookie)
		n += 1 + l + sovOidb0Xec4(uint64(l))
	}
	n += 1 + sovOidb0Xec4(uint64(m.Ret))
	n += 1 + sovOidb0Xec4(uint64(m.AnsweredQuestNum))
	return n
}

func sovOidb0Xec4(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOidb0Xec4(x uint64) (n int) {
	return sovOidb0Xec4(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Comment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xec4
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Comment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Comment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUin", wireType)
			}
			m.FromUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromNick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromNick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xec4(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Praise) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xec4
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Praise: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Praise: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUin", wireType)
			}
			m.FromUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromNick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromNick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xec4(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Quest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xec4
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Quest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Quest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestUin", wireType)
			}
			m.QuestUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuestUin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ans", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ans = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsTime", wireType)
			}
			m.AnsTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comment = append(m.Comment, &Comment{})
			if err := m.Comment[len(m.Comment)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Praise", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Praise = append(m.Praise, &Praise{})
			if err := m.Praise[len(m.Praise)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PraiseNum", wireType)
			}
			m.PraiseNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PraiseNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LikeKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LikeKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemId", wireType)
			}
			m.SystemId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SystemId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentNum", wireType)
			}
			m.CommentNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommentNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowType", wireType)
			}
			m.ShowType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShowTimes", wireType)
			}
			m.ShowTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShowTimes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeenPraised", wireType)
			}
			m.BeenPraised = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeenPraised |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QuestRead = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsShowType", wireType)
			}
			m.AnsShowType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsShowType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xec4(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DEC4ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xec4
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DEC4ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DEC4ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestNum", wireType)
			}
			m.QuestNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuestNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommentNum", wireType)
			}
			m.CommentNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommentNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookie = append(m.Cookie[:0], dAtA[iNdEx:postIndex]...)
			if m.Cookie == nil {
				m.Cookie = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchType", wireType)
			}
			m.FetchType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FetchType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xec4(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DEC4RspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xec4
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DEC4RspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DEC4RspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quest = append(m.Quest, &Quest{})
			if err := m.Quest[len(m.Quest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFetchOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFetchOver = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalQuestNum", wireType)
			}
			m.TotalQuestNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalQuestNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cookie = append(m.Cookie[:0], dAtA[iNdEx:postIndex]...)
			if m.Cookie == nil {
				m.Cookie = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			m.Ret = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ret |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnsweredQuestNum", wireType)
			}
			m.AnsweredQuestNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnsweredQuestNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xec4(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xec4
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOidb0Xec4(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOidb0Xec4
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb0Xec4
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOidb0Xec4
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOidb0Xec4
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOidb0Xec4
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOidb0Xec4        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOidb0Xec4          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOidb0Xec4 = fmt.Errorf("proto: unexpected end of group")
)
