// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oidb0xe07.proto

package oidb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DE07ReqBody struct {
	Version    int32       `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Client     int32       `protobuf:"varint,2,opt,name=client,proto3" json:"client,omitempty"`
	Entrance   int32       `protobuf:"varint,3,opt,name=entrance,proto3" json:"entrance,omitempty"`
	OcrReqBody *OCRReqBody `protobuf:"bytes,10,opt,name=ocrReqBody,proto3" json:"ocrReqBody,omitempty"`
}

func (m *DE07ReqBody) Reset()         { *m = DE07ReqBody{} }
func (m *DE07ReqBody) String() string { return proto.CompactTextString(m) }
func (*DE07ReqBody) ProtoMessage()    {}
func (*DE07ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{0}
}
func (m *DE07ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DE07ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DE07ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DE07ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DE07ReqBody.Merge(m, src)
}
func (m *DE07ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *DE07ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_DE07ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_DE07ReqBody proto.InternalMessageInfo

func (m *DE07ReqBody) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DE07ReqBody) GetClient() int32 {
	if m != nil {
		return m.Client
	}
	return 0
}

func (m *DE07ReqBody) GetEntrance() int32 {
	if m != nil {
		return m.Entrance
	}
	return 0
}

func (m *DE07ReqBody) GetOcrReqBody() *OCRReqBody {
	if m != nil {
		return m.OcrReqBody
	}
	return nil
}

type OCRReqBody struct {
	ImageUrl              string `protobuf:"bytes,1,opt,name=imageUrl,proto3" json:"imageUrl,omitempty"`
	LanguageType          string `protobuf:"bytes,2,opt,name=languageType,proto3" json:"languageType,omitempty"`
	Scene                 string `protobuf:"bytes,3,opt,name=scene,proto3" json:"scene,omitempty"`
	OriginMd5             string `protobuf:"bytes,10,opt,name=originMd5,proto3" json:"originMd5,omitempty"`
	AfterCompressMd5      string `protobuf:"bytes,11,opt,name=afterCompressMd5,proto3" json:"afterCompressMd5,omitempty"`
	AfterCompressFileSize int32  `protobuf:"varint,12,opt,name=afterCompressFileSize,proto3" json:"afterCompressFileSize,omitempty"`
	AfterCompressWeight   int32  `protobuf:"varint,13,opt,name=afterCompressWeight,proto3" json:"afterCompressWeight,omitempty"`
	AfterCompressHeight   int32  `protobuf:"varint,14,opt,name=afterCompressHeight,proto3" json:"afterCompressHeight,omitempty"`
	IsCut                 bool   `protobuf:"varint,15,opt,name=isCut,proto3" json:"isCut,omitempty"`
}

func (m *OCRReqBody) Reset()         { *m = OCRReqBody{} }
func (m *OCRReqBody) String() string { return proto.CompactTextString(m) }
func (*OCRReqBody) ProtoMessage()    {}
func (*OCRReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{1}
}
func (m *OCRReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OCRReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OCRReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OCRReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OCRReqBody.Merge(m, src)
}
func (m *OCRReqBody) XXX_Size() int {
	return m.Size()
}
func (m *OCRReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_OCRReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_OCRReqBody proto.InternalMessageInfo

func (m *OCRReqBody) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

func (m *OCRReqBody) GetLanguageType() string {
	if m != nil {
		return m.LanguageType
	}
	return ""
}

func (m *OCRReqBody) GetScene() string {
	if m != nil {
		return m.Scene
	}
	return ""
}

func (m *OCRReqBody) GetOriginMd5() string {
	if m != nil {
		return m.OriginMd5
	}
	return ""
}

func (m *OCRReqBody) GetAfterCompressMd5() string {
	if m != nil {
		return m.AfterCompressMd5
	}
	return ""
}

func (m *OCRReqBody) GetAfterCompressFileSize() int32 {
	if m != nil {
		return m.AfterCompressFileSize
	}
	return 0
}

func (m *OCRReqBody) GetAfterCompressWeight() int32 {
	if m != nil {
		return m.AfterCompressWeight
	}
	return 0
}

func (m *OCRReqBody) GetAfterCompressHeight() int32 {
	if m != nil {
		return m.AfterCompressHeight
	}
	return 0
}

func (m *OCRReqBody) GetIsCut() bool {
	if m != nil {
		return m.IsCut
	}
	return false
}

type DE07RspBody struct {
	RetCode    int32       `protobuf:"varint,1,opt,name=retCode,proto3" json:"retCode,omitempty"`
	ErrMsg     string      `protobuf:"bytes,2,opt,name=errMsg,proto3" json:"errMsg,omitempty"`
	Wording    string      `protobuf:"bytes,3,opt,name=wording,proto3" json:"wording,omitempty"`
	OcrRspBody *OCRRspBody `protobuf:"bytes,10,opt,name=ocrRspBody,proto3" json:"ocrRspBody,omitempty"`
}

func (m *DE07RspBody) Reset()         { *m = DE07RspBody{} }
func (m *DE07RspBody) String() string { return proto.CompactTextString(m) }
func (*DE07RspBody) ProtoMessage()    {}
func (*DE07RspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{2}
}
func (m *DE07RspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DE07RspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DE07RspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DE07RspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DE07RspBody.Merge(m, src)
}
func (m *DE07RspBody) XXX_Size() int {
	return m.Size()
}
func (m *DE07RspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_DE07RspBody.DiscardUnknown(m)
}

var xxx_messageInfo_DE07RspBody proto.InternalMessageInfo

func (m *DE07RspBody) GetRetCode() int32 {
	if m != nil {
		return m.RetCode
	}
	return 0
}

func (m *DE07RspBody) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

func (m *DE07RspBody) GetWording() string {
	if m != nil {
		return m.Wording
	}
	return ""
}

func (m *DE07RspBody) GetOcrRspBody() *OCRRspBody {
	if m != nil {
		return m.OcrRspBody
	}
	return nil
}

type TextDetection struct {
	DetectedText string   `protobuf:"bytes,1,opt,name=detectedText,proto3" json:"detectedText,omitempty"`
	Confidence   int32    `protobuf:"varint,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	Polygon      *Polygon `protobuf:"bytes,3,opt,name=polygon,proto3" json:"polygon,omitempty"`
	AdvancedInfo string   `protobuf:"bytes,4,opt,name=advancedInfo,proto3" json:"advancedInfo,omitempty"`
}

func (m *TextDetection) Reset()         { *m = TextDetection{} }
func (m *TextDetection) String() string { return proto.CompactTextString(m) }
func (*TextDetection) ProtoMessage()    {}
func (*TextDetection) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{3}
}
func (m *TextDetection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TextDetection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TextDetection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TextDetection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TextDetection.Merge(m, src)
}
func (m *TextDetection) XXX_Size() int {
	return m.Size()
}
func (m *TextDetection) XXX_DiscardUnknown() {
	xxx_messageInfo_TextDetection.DiscardUnknown(m)
}

var xxx_messageInfo_TextDetection proto.InternalMessageInfo

func (m *TextDetection) GetDetectedText() string {
	if m != nil {
		return m.DetectedText
	}
	return ""
}

func (m *TextDetection) GetConfidence() int32 {
	if m != nil {
		return m.Confidence
	}
	return 0
}

func (m *TextDetection) GetPolygon() *Polygon {
	if m != nil {
		return m.Polygon
	}
	return nil
}

func (m *TextDetection) GetAdvancedInfo() string {
	if m != nil {
		return m.AdvancedInfo
	}
	return ""
}

type Polygon struct {
	Coordinates []*Coordinate `protobuf:"bytes,1,rep,name=coordinates,proto3" json:"coordinates,omitempty"`
}

func (m *Polygon) Reset()         { *m = Polygon{} }
func (m *Polygon) String() string { return proto.CompactTextString(m) }
func (*Polygon) ProtoMessage()    {}
func (*Polygon) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{4}
}
func (m *Polygon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Polygon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Polygon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Polygon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Polygon.Merge(m, src)
}
func (m *Polygon) XXX_Size() int {
	return m.Size()
}
func (m *Polygon) XXX_DiscardUnknown() {
	xxx_messageInfo_Polygon.DiscardUnknown(m)
}

var xxx_messageInfo_Polygon proto.InternalMessageInfo

func (m *Polygon) GetCoordinates() []*Coordinate {
	if m != nil {
		return m.Coordinates
	}
	return nil
}

type Coordinate struct {
	X int32 `protobuf:"varint,1,opt,name=X,proto3" json:"X,omitempty"`
	Y int32 `protobuf:"varint,2,opt,name=Y,proto3" json:"Y,omitempty"`
}

func (m *Coordinate) Reset()         { *m = Coordinate{} }
func (m *Coordinate) String() string { return proto.CompactTextString(m) }
func (*Coordinate) ProtoMessage()    {}
func (*Coordinate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{5}
}
func (m *Coordinate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Coordinate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Coordinate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Coordinate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Coordinate.Merge(m, src)
}
func (m *Coordinate) XXX_Size() int {
	return m.Size()
}
func (m *Coordinate) XXX_DiscardUnknown() {
	xxx_messageInfo_Coordinate.DiscardUnknown(m)
}

var xxx_messageInfo_Coordinate proto.InternalMessageInfo

func (m *Coordinate) GetX() int32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Coordinate) GetY() int32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type Language struct {
	Language     string `protobuf:"bytes,1,opt,name=language,proto3" json:"language,omitempty"`
	LanguageDesc string `protobuf:"bytes,2,opt,name=languageDesc,proto3" json:"languageDesc,omitempty"`
}

func (m *Language) Reset()         { *m = Language{} }
func (m *Language) String() string { return proto.CompactTextString(m) }
func (*Language) ProtoMessage()    {}
func (*Language) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{6}
}
func (m *Language) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Language) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Language.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Language) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Language.Merge(m, src)
}
func (m *Language) XXX_Size() int {
	return m.Size()
}
func (m *Language) XXX_DiscardUnknown() {
	xxx_messageInfo_Language.DiscardUnknown(m)
}

var xxx_messageInfo_Language proto.InternalMessageInfo

func (m *Language) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Language) GetLanguageDesc() string {
	if m != nil {
		return m.LanguageDesc
	}
	return ""
}

type OCRRspBody struct {
	TextDetections           []*TextDetection `protobuf:"bytes,1,rep,name=textDetections,proto3" json:"textDetections,omitempty"`
	Language                 string           `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	RequestId                string           `protobuf:"bytes,3,opt,name=requestId,proto3" json:"requestId,omitempty"`
	OcrLanguageList          []string         `protobuf:"bytes,101,rep,name=ocrLanguageList,proto3" json:"ocrLanguageList,omitempty"`
	DstTranslateLanguageList []string         `protobuf:"bytes,102,rep,name=dstTranslateLanguageList,proto3" json:"dstTranslateLanguageList,omitempty"`
	LanguageList             []*Language      `protobuf:"bytes,103,rep,name=languageList,proto3" json:"languageList,omitempty"`
	AfterCompressWeight      int32            `protobuf:"varint,111,opt,name=afterCompressWeight,proto3" json:"afterCompressWeight,omitempty"`
	AfterCompressHeight      int32            `protobuf:"varint,112,opt,name=afterCompressHeight,proto3" json:"afterCompressHeight,omitempty"`
}

func (m *OCRRspBody) Reset()         { *m = OCRRspBody{} }
func (m *OCRRspBody) String() string { return proto.CompactTextString(m) }
func (*OCRRspBody) ProtoMessage()    {}
func (*OCRRspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_fd92dc9282876705, []int{7}
}
func (m *OCRRspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OCRRspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OCRRspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OCRRspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OCRRspBody.Merge(m, src)
}
func (m *OCRRspBody) XXX_Size() int {
	return m.Size()
}
func (m *OCRRspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_OCRRspBody.DiscardUnknown(m)
}

var xxx_messageInfo_OCRRspBody proto.InternalMessageInfo

func (m *OCRRspBody) GetTextDetections() []*TextDetection {
	if m != nil {
		return m.TextDetections
	}
	return nil
}

func (m *OCRRspBody) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *OCRRspBody) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *OCRRspBody) GetOcrLanguageList() []string {
	if m != nil {
		return m.OcrLanguageList
	}
	return nil
}

func (m *OCRRspBody) GetDstTranslateLanguageList() []string {
	if m != nil {
		return m.DstTranslateLanguageList
	}
	return nil
}

func (m *OCRRspBody) GetLanguageList() []*Language {
	if m != nil {
		return m.LanguageList
	}
	return nil
}

func (m *OCRRspBody) GetAfterCompressWeight() int32 {
	if m != nil {
		return m.AfterCompressWeight
	}
	return 0
}

func (m *OCRRspBody) GetAfterCompressHeight() int32 {
	if m != nil {
		return m.AfterCompressHeight
	}
	return 0
}

func init() {
	proto.RegisterType((*DE07ReqBody)(nil), "DE07ReqBody")
	proto.RegisterType((*OCRReqBody)(nil), "OCRReqBody")
	proto.RegisterType((*DE07RspBody)(nil), "DE07RspBody")
	proto.RegisterType((*TextDetection)(nil), "TextDetection")
	proto.RegisterType((*Polygon)(nil), "Polygon")
	proto.RegisterType((*Coordinate)(nil), "Coordinate")
	proto.RegisterType((*Language)(nil), "Language")
	proto.RegisterType((*OCRRspBody)(nil), "OCRRspBody")
}

func init() { proto.RegisterFile("oidb0xe07.proto", fileDescriptor_fd92dc9282876705) }

var fileDescriptor_fd92dc9282876705 = []byte{
	// 635 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x4f, 0x14, 0x4b,
	0x14, 0xa5, 0xe0, 0x01, 0xd3, 0x77, 0x06, 0x78, 0xa9, 0xf7, 0x34, 0x1d, 0x43, 0x3a, 0x93, 0x5e,
	0x4d, 0x34, 0x4c, 0x26, 0xf8, 0x81, 0xd1, 0x1d, 0x83, 0x46, 0x0c, 0x44, 0x53, 0x62, 0x04, 0x77,
	0x4d, 0xf7, 0x9d, 0xb6, 0x92, 0xa1, 0x6b, 0xa8, 0x2a, 0x10, 0xfc, 0x01, 0xc6, 0xa5, 0x7b, 0xff,
	0x90, 0x4b, 0x96, 0x2e, 0x5c, 0x18, 0xf8, 0x11, 0x6e, 0x4d, 0x55, 0x57, 0x31, 0xdd, 0x03, 0x2c,
	0x5c, 0x9e, 0x73, 0xea, 0x56, 0xdf, 0x7b, 0xcf, 0xa9, 0x86, 0x25, 0xc1, 0xb3, 0xfd, 0xde, 0x09,
	0xf6, 0xd6, 0xba, 0x23, 0x29, 0xb4, 0x88, 0xbf, 0x10, 0x68, 0x6e, 0x3c, 0xeb, 0xad, 0x31, 0x3c,
	0x5c, 0x17, 0xd9, 0x29, 0x0d, 0x61, 0xfe, 0x18, 0xa5, 0xe2, 0xa2, 0x08, 0x49, 0x9b, 0x74, 0x66,
	0x99, 0x87, 0xf4, 0x36, 0xcc, 0xa5, 0x43, 0x8e, 0x85, 0x0e, 0xa7, 0xad, 0xe0, 0x10, 0xbd, 0x03,
	0x0d, 0x2c, 0xb4, 0x4c, 0x8a, 0x14, 0xc3, 0x19, 0xab, 0x5c, 0x62, 0x7a, 0x0f, 0x40, 0xa4, 0xd2,
	0xdd, 0x1d, 0x42, 0x9b, 0x74, 0x9a, 0xab, 0xcd, 0xee, 0xab, 0x3e, 0x73, 0x14, 0xab, 0xc8, 0xf1,
	0xcf, 0x69, 0x80, 0xb1, 0x64, 0xee, 0xe5, 0x07, 0x49, 0x8e, 0x6f, 0xe5, 0xd0, 0xb6, 0x12, 0xb0,
	0x4b, 0x4c, 0x63, 0x68, 0x0d, 0x93, 0x22, 0x3f, 0x4a, 0x72, 0xdc, 0x39, 0x1d, 0xa1, 0xed, 0x28,
	0x60, 0x35, 0x8e, 0xfe, 0x0f, 0xb3, 0x2a, 0xc5, 0xa2, 0x6c, 0x2a, 0x60, 0x25, 0xa0, 0xcb, 0x10,
	0x08, 0xc9, 0x73, 0x5e, 0x6c, 0x67, 0x0f, 0x6d, 0x43, 0x01, 0x1b, 0x13, 0xf4, 0x2e, 0xfc, 0x9b,
	0x0c, 0x34, 0xca, 0xbe, 0x38, 0x18, 0x49, 0x54, 0xca, 0x1c, 0x6a, 0xda, 0x43, 0x57, 0x78, 0xfa,
	0x00, 0x6e, 0xd5, 0xb8, 0xe7, 0x7c, 0x88, 0x6f, 0xf8, 0x27, 0x0c, 0x5b, 0x76, 0x09, 0xd7, 0x8b,
	0xb4, 0x07, 0xff, 0xd5, 0x84, 0x77, 0xc8, 0xf3, 0x0f, 0x3a, 0x5c, 0xb0, 0x35, 0xd7, 0x49, 0x57,
	0x2a, 0x5e, 0x94, 0x15, 0x8b, 0xd7, 0x54, 0x94, 0x92, 0x99, 0x9c, 0xab, 0xfe, 0x91, 0x0e, 0x97,
	0xda, 0xa4, 0xd3, 0x60, 0x25, 0x88, 0x3f, 0x7b, 0xa7, 0xd5, 0xc8, 0x3b, 0x2d, 0x51, 0xf7, 0x45,
	0x86, 0xde, 0x69, 0x07, 0x8d, 0xd3, 0x28, 0xe5, 0xb6, 0xca, 0xdd, 0x5e, 0x1d, 0x32, 0x15, 0x1f,
	0x85, 0xcc, 0x78, 0x91, 0xbb, 0x9d, 0x7a, 0xe8, 0x7d, 0x2e, 0x6f, 0xae, 0xf9, 0x5c, 0x52, 0xac,
	0x22, 0xc7, 0xdf, 0x08, 0x2c, 0xec, 0xe0, 0x89, 0xde, 0x40, 0x8d, 0xa9, 0x36, 0xd1, 0x8a, 0xa1,
	0x95, 0x59, 0x80, 0x99, 0x11, 0x9c, 0xdd, 0x35, 0x8e, 0x46, 0x00, 0xa9, 0x28, 0x06, 0x3c, 0x43,
	0x13, 0xb4, 0x32, 0x82, 0x15, 0x86, 0xc6, 0x30, 0x3f, 0x12, 0xc3, 0xd3, 0x5c, 0x14, 0xb6, 0xb9,
	0xe6, 0x6a, 0xa3, 0xfb, 0xba, 0xc4, 0xcc, 0x0b, 0xe6, 0x3b, 0x49, 0x76, 0x6c, 0x92, 0x99, 0x6d,
	0x16, 0x03, 0x11, 0xfe, 0x53, 0x7e, 0xa7, 0xca, 0xc5, 0x8f, 0x61, 0xde, 0xd5, 0xd1, 0x15, 0x68,
	0xa6, 0xc2, 0x4e, 0x98, 0x68, 0x54, 0x21, 0x69, 0xcf, 0xd8, 0xb1, 0xfa, 0x97, 0x1c, 0xab, 0xea,
	0x71, 0x07, 0x60, 0x2c, 0xd1, 0x16, 0x90, 0x5d, 0xb7, 0x58, 0xb2, 0x6b, 0xd0, 0x9e, 0x6b, 0x9a,
	0xec, 0xc5, 0x2f, 0xa1, 0xb1, 0xe5, 0xa2, 0x6a, 0x62, 0xee, 0x63, 0xeb, 0x63, 0xee, 0x71, 0x35,
	0xe6, 0x1b, 0xa8, 0xd2, 0xc9, 0x98, 0x1b, 0x2e, 0xfe, 0xed, 0x5e, 0x8d, 0x73, 0xf5, 0x11, 0x2c,
	0xea, 0xea, 0x6e, 0x7d, 0xdb, 0x8b, 0xdd, 0xda, 0xca, 0xd9, 0xc4, 0xa9, 0x5a, 0x1b, 0xd3, 0x13,
	0x6d, 0x2c, 0x43, 0x20, 0xf1, 0xf0, 0x08, 0x95, 0xde, 0xcc, 0x9c, 0xf3, 0x63, 0x82, 0x76, 0x60,
	0x49, 0xa4, 0xd2, 0xcf, 0xb3, 0xc5, 0x95, 0x0e, 0xb1, 0x3d, 0xd3, 0x09, 0xd8, 0x24, 0x4d, 0x9f,
	0x40, 0x98, 0x29, 0xbd, 0x23, 0x93, 0x42, 0x0d, 0x13, 0x8d, 0xb5, 0x92, 0x81, 0x2d, 0xb9, 0x51,
	0xa7, 0x2b, 0xe3, 0x55, 0xd8, 0xf3, 0xb9, 0x9d, 0x2a, 0xe8, 0xfa, 0x43, 0xac, 0x26, 0xdf, 0xf4,
	0xcc, 0xc4, 0x5f, 0x3f, 0xb3, 0xd1, 0x8d, 0xcf, 0x6c, 0xbd, 0xfd, 0xfd, 0x3c, 0x22, 0x67, 0xe7,
	0x11, 0xf9, 0x75, 0x1e, 0x91, 0xaf, 0x17, 0xd1, 0xd4, 0xd9, 0x45, 0x34, 0xf5, 0xe3, 0x22, 0x9a,
	0x7a, 0x3f, 0xd7, 0x7d, 0x6a, 0xfe, 0xb3, 0xfb, 0x73, 0xf6, 0x1f, 0x7b, 0xff, 0x4f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x6c, 0xff, 0xde, 0x49, 0x76, 0x05, 0x00, 0x00,
}

func (m *DE07ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DE07ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DE07ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OcrReqBody != nil {
		{
			size, err := m.OcrReqBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0Xe07(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Entrance != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.Entrance))
		i--
		dAtA[i] = 0x18
	}
	if m.Client != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.Client))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OCRReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OCRReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OCRReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsCut {
		i--
		if m.IsCut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.AfterCompressHeight != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.AfterCompressHeight))
		i--
		dAtA[i] = 0x70
	}
	if m.AfterCompressWeight != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.AfterCompressWeight))
		i--
		dAtA[i] = 0x68
	}
	if m.AfterCompressFileSize != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.AfterCompressFileSize))
		i--
		dAtA[i] = 0x60
	}
	if len(m.AfterCompressMd5) > 0 {
		i -= len(m.AfterCompressMd5)
		copy(dAtA[i:], m.AfterCompressMd5)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.AfterCompressMd5)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.OriginMd5) > 0 {
		i -= len(m.OriginMd5)
		copy(dAtA[i:], m.OriginMd5)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.OriginMd5)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Scene) > 0 {
		i -= len(m.Scene)
		copy(dAtA[i:], m.Scene)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.Scene)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LanguageType) > 0 {
		i -= len(m.LanguageType)
		copy(dAtA[i:], m.LanguageType)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.LanguageType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ImageUrl) > 0 {
		i -= len(m.ImageUrl)
		copy(dAtA[i:], m.ImageUrl)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.ImageUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DE07RspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DE07RspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DE07RspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OcrRspBody != nil {
		{
			size, err := m.OcrRspBody.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0Xe07(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Wording) > 0 {
		i -= len(m.Wording)
		copy(dAtA[i:], m.Wording)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.Wording)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.RetCode != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.RetCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TextDetection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextDetection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TextDetection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AdvancedInfo) > 0 {
		i -= len(m.AdvancedInfo)
		copy(dAtA[i:], m.AdvancedInfo)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.AdvancedInfo)))
		i--
		dAtA[i] = 0x22
	}
	if m.Polygon != nil {
		{
			size, err := m.Polygon.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb0Xe07(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Confidence != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.Confidence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DetectedText) > 0 {
		i -= len(m.DetectedText)
		copy(dAtA[i:], m.DetectedText)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.DetectedText)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Polygon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Polygon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Polygon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coordinates) > 0 {
		for iNdEx := len(m.Coordinates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coordinates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb0Xe07(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Coordinate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Coordinate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Coordinate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Y != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.Y))
		i--
		dAtA[i] = 0x10
	}
	if m.X != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.X))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Language) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Language) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Language) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LanguageDesc) > 0 {
		i -= len(m.LanguageDesc)
		copy(dAtA[i:], m.LanguageDesc)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.LanguageDesc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OCRRspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OCRRspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OCRRspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AfterCompressHeight != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.AfterCompressHeight))
		i--
		dAtA[i] = 0x7
		i--
		dAtA[i] = 0x80
	}
	if m.AfterCompressWeight != 0 {
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(m.AfterCompressWeight))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xf8
	}
	if len(m.LanguageList) > 0 {
		for iNdEx := len(m.LanguageList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LanguageList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb0Xe07(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if len(m.DstTranslateLanguageList) > 0 {
		for iNdEx := len(m.DstTranslateLanguageList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DstTranslateLanguageList[iNdEx])
			copy(dAtA[i:], m.DstTranslateLanguageList[iNdEx])
			i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.DstTranslateLanguageList[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.OcrLanguageList) > 0 {
		for iNdEx := len(m.OcrLanguageList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OcrLanguageList[iNdEx])
			copy(dAtA[i:], m.OcrLanguageList[iNdEx])
			i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.OcrLanguageList[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintOidb0Xe07(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TextDetections) > 0 {
		for iNdEx := len(m.TextDetections) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TextDetections[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb0Xe07(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintOidb0Xe07(dAtA []byte, offset int, v uint64) int {
	offset -= sovOidb0Xe07(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DE07ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.Version))
	}
	if m.Client != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.Client))
	}
	if m.Entrance != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.Entrance))
	}
	if m.OcrReqBody != nil {
		l = m.OcrReqBody.Size()
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	return n
}

func (m *OCRReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.LanguageType)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.Scene)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.OriginMd5)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.AfterCompressMd5)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	if m.AfterCompressFileSize != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.AfterCompressFileSize))
	}
	if m.AfterCompressWeight != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.AfterCompressWeight))
	}
	if m.AfterCompressHeight != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.AfterCompressHeight))
	}
	if m.IsCut {
		n += 2
	}
	return n
}

func (m *DE07RspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.RetCode))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.Wording)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	if m.OcrRspBody != nil {
		l = m.OcrRspBody.Size()
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	return n
}

func (m *TextDetection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DetectedText)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	if m.Confidence != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.Confidence))
	}
	if m.Polygon != nil {
		l = m.Polygon.Size()
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.AdvancedInfo)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	return n
}

func (m *Polygon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Coordinates) > 0 {
		for _, e := range m.Coordinates {
			l = e.Size()
			n += 1 + l + sovOidb0Xe07(uint64(l))
		}
	}
	return n
}

func (m *Coordinate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovOidb0Xe07(uint64(m.Y))
	}
	return n
}

func (m *Language) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.LanguageDesc)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	return n
}

func (m *OCRRspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.TextDetections) > 0 {
		for _, e := range m.TextDetections {
			l = e.Size()
			n += 1 + l + sovOidb0Xe07(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovOidb0Xe07(uint64(l))
	}
	if len(m.OcrLanguageList) > 0 {
		for _, s := range m.OcrLanguageList {
			l = len(s)
			n += 2 + l + sovOidb0Xe07(uint64(l))
		}
	}
	if len(m.DstTranslateLanguageList) > 0 {
		for _, s := range m.DstTranslateLanguageList {
			l = len(s)
			n += 2 + l + sovOidb0Xe07(uint64(l))
		}
	}
	if len(m.LanguageList) > 0 {
		for _, e := range m.LanguageList {
			l = e.Size()
			n += 2 + l + sovOidb0Xe07(uint64(l))
		}
	}
	if m.AfterCompressWeight != 0 {
		n += 2 + sovOidb0Xe07(uint64(m.AfterCompressWeight))
	}
	if m.AfterCompressHeight != 0 {
		n += 2 + sovOidb0Xe07(uint64(m.AfterCompressHeight))
	}
	return n
}

func sovOidb0Xe07(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOidb0Xe07(x uint64) (n int) {
	return sovOidb0Xe07(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DE07ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DE07ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DE07ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			m.Client = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Client |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrance", wireType)
			}
			m.Entrance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Entrance |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OcrReqBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OcrReqBody == nil {
				m.OcrReqBody = &OCRReqBody{}
			}
			if err := m.OcrReqBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OCRReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OCRReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OCRReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scene", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scene = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginMd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginMd5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterCompressMd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterCompressMd5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterCompressFileSize", wireType)
			}
			m.AfterCompressFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AfterCompressFileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterCompressWeight", wireType)
			}
			m.AfterCompressWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AfterCompressWeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterCompressHeight", wireType)
			}
			m.AfterCompressHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AfterCompressHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCut = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DE07RspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DE07RspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DE07RspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wording", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wording = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OcrRspBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OcrRspBody == nil {
				m.OcrRspBody = &OCRRspBody{}
			}
			if err := m.OcrRspBody.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextDetection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextDetection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextDetection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectedText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DetectedText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confidence", wireType)
			}
			m.Confidence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Confidence |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Polygon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Polygon == nil {
				m.Polygon = &Polygon{}
			}
			if err := m.Polygon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvancedInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdvancedInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Polygon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Polygon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Polygon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinates = append(m.Coordinates, &Coordinate{})
			if err := m.Coordinates[len(m.Coordinates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Coordinate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coordinate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coordinate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Language) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Language: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Language: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OCRRspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OCRRspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OCRRspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextDetections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TextDetections = append(m.TextDetections, &TextDetection{})
			if err := m.TextDetections[len(m.TextDetections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OcrLanguageList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OcrLanguageList = append(m.OcrLanguageList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstTranslateLanguageList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstTranslateLanguageList = append(m.DstTranslateLanguageList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LanguageList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LanguageList = append(m.LanguageList, &Language{})
			if err := m.LanguageList[len(m.LanguageList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 111:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterCompressWeight", wireType)
			}
			m.AfterCompressWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AfterCompressWeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 112:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterCompressHeight", wireType)
			}
			m.AfterCompressHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AfterCompressHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb0Xe07(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb0Xe07
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOidb0Xe07(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOidb0Xe07
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb0Xe07
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOidb0Xe07
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOidb0Xe07
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOidb0Xe07
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOidb0Xe07        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOidb0Xe07          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOidb0Xe07 = fmt.Errorf("proto: unexpected end of group")
)
