// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: oidb.proto

package oidb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OIDBSSOPkg struct {
	Command       int32  `protobuf:"varint,1,opt,name=command,proto3" json:"command,omitempty"`
	ServiceType   int32  `protobuf:"varint,2,opt,name=serviceType,proto3" json:"serviceType,omitempty"`
	Result        int32  `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
	Bodybuffer    []byte `protobuf:"bytes,4,opt,name=bodybuffer,proto3" json:"bodybuffer,omitempty"`
	ErrorMsg      string `protobuf:"bytes,5,opt,name=errorMsg,proto3" json:"errorMsg,omitempty"`
	ClientVersion string `protobuf:"bytes,6,opt,name=clientVersion,proto3" json:"clientVersion,omitempty"`
}

func (m *OIDBSSOPkg) Reset()         { *m = OIDBSSOPkg{} }
func (m *OIDBSSOPkg) String() string { return proto.CompactTextString(m) }
func (*OIDBSSOPkg) ProtoMessage()    {}
func (*OIDBSSOPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{0}
}
func (m *OIDBSSOPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OIDBSSOPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OIDBSSOPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OIDBSSOPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OIDBSSOPkg.Merge(m, src)
}
func (m *OIDBSSOPkg) XXX_Size() int {
	return m.Size()
}
func (m *OIDBSSOPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_OIDBSSOPkg.DiscardUnknown(m)
}

var xxx_messageInfo_OIDBSSOPkg proto.InternalMessageInfo

func (m *OIDBSSOPkg) GetCommand() int32 {
	if m != nil {
		return m.Command
	}
	return 0
}

func (m *OIDBSSOPkg) GetServiceType() int32 {
	if m != nil {
		return m.ServiceType
	}
	return 0
}

func (m *OIDBSSOPkg) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *OIDBSSOPkg) GetBodybuffer() []byte {
	if m != nil {
		return m.Bodybuffer
	}
	return nil
}

func (m *OIDBSSOPkg) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *OIDBSSOPkg) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

type D8A0RspBody struct {
	OptUint64GroupCode int64             `protobuf:"varint,1,opt,name=optUint64GroupCode,proto3" json:"optUint64GroupCode,omitempty"`
	MsgKickResult      []*D8A0KickResult `protobuf:"bytes,2,rep,name=msgKickResult,proto3" json:"msgKickResult,omitempty"`
}

func (m *D8A0RspBody) Reset()         { *m = D8A0RspBody{} }
func (m *D8A0RspBody) String() string { return proto.CompactTextString(m) }
func (*D8A0RspBody) ProtoMessage()    {}
func (*D8A0RspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{1}
}
func (m *D8A0RspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D8A0RspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D8A0RspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D8A0RspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D8A0RspBody.Merge(m, src)
}
func (m *D8A0RspBody) XXX_Size() int {
	return m.Size()
}
func (m *D8A0RspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D8A0RspBody.DiscardUnknown(m)
}

var xxx_messageInfo_D8A0RspBody proto.InternalMessageInfo

func (m *D8A0RspBody) GetOptUint64GroupCode() int64 {
	if m != nil {
		return m.OptUint64GroupCode
	}
	return 0
}

func (m *D8A0RspBody) GetMsgKickResult() []*D8A0KickResult {
	if m != nil {
		return m.MsgKickResult
	}
	return nil
}

type D8A0KickResult struct {
	OptUint32Result    int32 `protobuf:"varint,1,opt,name=optUint32Result,proto3" json:"optUint32Result,omitempty"`
	OptUint64MemberUin int64 `protobuf:"varint,2,opt,name=optUint64MemberUin,proto3" json:"optUint64MemberUin,omitempty"`
}

func (m *D8A0KickResult) Reset()         { *m = D8A0KickResult{} }
func (m *D8A0KickResult) String() string { return proto.CompactTextString(m) }
func (*D8A0KickResult) ProtoMessage()    {}
func (*D8A0KickResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{2}
}
func (m *D8A0KickResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D8A0KickResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D8A0KickResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D8A0KickResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D8A0KickResult.Merge(m, src)
}
func (m *D8A0KickResult) XXX_Size() int {
	return m.Size()
}
func (m *D8A0KickResult) XXX_DiscardUnknown() {
	xxx_messageInfo_D8A0KickResult.DiscardUnknown(m)
}

var xxx_messageInfo_D8A0KickResult proto.InternalMessageInfo

func (m *D8A0KickResult) GetOptUint32Result() int32 {
	if m != nil {
		return m.OptUint32Result
	}
	return 0
}

func (m *D8A0KickResult) GetOptUint64MemberUin() int64 {
	if m != nil {
		return m.OptUint64MemberUin
	}
	return 0
}

type D8A0KickMemberInfo struct {
	OptUint32Operate   int32  `protobuf:"varint,1,opt,name=optUint32Operate,proto3" json:"optUint32Operate,omitempty"`
	OptUint64MemberUin int64  `protobuf:"varint,2,opt,name=optUint64MemberUin,proto3" json:"optUint64MemberUin,omitempty"`
	OptUint32Flag      int32  `protobuf:"varint,3,opt,name=optUint32Flag,proto3" json:"optUint32Flag,omitempty"`
	OptBytesMsg        []byte `protobuf:"bytes,4,opt,name=optBytesMsg,proto3" json:"optBytesMsg,omitempty"`
}

func (m *D8A0KickMemberInfo) Reset()         { *m = D8A0KickMemberInfo{} }
func (m *D8A0KickMemberInfo) String() string { return proto.CompactTextString(m) }
func (*D8A0KickMemberInfo) ProtoMessage()    {}
func (*D8A0KickMemberInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{3}
}
func (m *D8A0KickMemberInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D8A0KickMemberInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D8A0KickMemberInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D8A0KickMemberInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D8A0KickMemberInfo.Merge(m, src)
}
func (m *D8A0KickMemberInfo) XXX_Size() int {
	return m.Size()
}
func (m *D8A0KickMemberInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_D8A0KickMemberInfo.DiscardUnknown(m)
}

var xxx_messageInfo_D8A0KickMemberInfo proto.InternalMessageInfo

func (m *D8A0KickMemberInfo) GetOptUint32Operate() int32 {
	if m != nil {
		return m.OptUint32Operate
	}
	return 0
}

func (m *D8A0KickMemberInfo) GetOptUint64MemberUin() int64 {
	if m != nil {
		return m.OptUint64MemberUin
	}
	return 0
}

func (m *D8A0KickMemberInfo) GetOptUint32Flag() int32 {
	if m != nil {
		return m.OptUint32Flag
	}
	return 0
}

func (m *D8A0KickMemberInfo) GetOptBytesMsg() []byte {
	if m != nil {
		return m.OptBytesMsg
	}
	return nil
}

type D8A0ReqBody struct {
	OptUint64GroupCode int64                 `protobuf:"varint,1,opt,name=optUint64GroupCode,proto3" json:"optUint64GroupCode,omitempty"`
	MsgKickList        []*D8A0KickMemberInfo `protobuf:"bytes,2,rep,name=msgKickList,proto3" json:"msgKickList,omitempty"`
	KickList           []int64               `protobuf:"varint,3,rep,packed,name=kickList,proto3" json:"kickList,omitempty"`
	KickFlag           int32                 `protobuf:"varint,4,opt,name=kickFlag,proto3" json:"kickFlag,omitempty"`
	KickMsg            []byte                `protobuf:"bytes,5,opt,name=kickMsg,proto3" json:"kickMsg,omitempty"`
}

func (m *D8A0ReqBody) Reset()         { *m = D8A0ReqBody{} }
func (m *D8A0ReqBody) String() string { return proto.CompactTextString(m) }
func (*D8A0ReqBody) ProtoMessage()    {}
func (*D8A0ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{4}
}
func (m *D8A0ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D8A0ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D8A0ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D8A0ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D8A0ReqBody.Merge(m, src)
}
func (m *D8A0ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *D8A0ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D8A0ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_D8A0ReqBody proto.InternalMessageInfo

func (m *D8A0ReqBody) GetOptUint64GroupCode() int64 {
	if m != nil {
		return m.OptUint64GroupCode
	}
	return 0
}

func (m *D8A0ReqBody) GetMsgKickList() []*D8A0KickMemberInfo {
	if m != nil {
		return m.MsgKickList
	}
	return nil
}

func (m *D8A0ReqBody) GetKickList() []int64 {
	if m != nil {
		return m.KickList
	}
	return nil
}

func (m *D8A0ReqBody) GetKickFlag() int32 {
	if m != nil {
		return m.KickFlag
	}
	return 0
}

func (m *D8A0ReqBody) GetKickMsg() []byte {
	if m != nil {
		return m.KickMsg
	}
	return nil
}

type D89AReqBody struct {
	GroupCode           int64          `protobuf:"varint,1,opt,name=groupCode,proto3" json:"groupCode,omitempty"`
	StGroupInfo         *D89AGroupinfo `protobuf:"bytes,2,opt,name=stGroupInfo,proto3" json:"stGroupInfo,omitempty"`
	OriginalOperatorUin int64          `protobuf:"varint,3,opt,name=originalOperatorUin,proto3" json:"originalOperatorUin,omitempty"`
	ReqGroupOpenAppid   int32          `protobuf:"varint,4,opt,name=reqGroupOpenAppid,proto3" json:"reqGroupOpenAppid,omitempty"`
}

func (m *D89AReqBody) Reset()         { *m = D89AReqBody{} }
func (m *D89AReqBody) String() string { return proto.CompactTextString(m) }
func (*D89AReqBody) ProtoMessage()    {}
func (*D89AReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{5}
}
func (m *D89AReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D89AReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D89AReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D89AReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D89AReqBody.Merge(m, src)
}
func (m *D89AReqBody) XXX_Size() int {
	return m.Size()
}
func (m *D89AReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D89AReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_D89AReqBody proto.InternalMessageInfo

func (m *D89AReqBody) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *D89AReqBody) GetStGroupInfo() *D89AGroupinfo {
	if m != nil {
		return m.StGroupInfo
	}
	return nil
}

func (m *D89AReqBody) GetOriginalOperatorUin() int64 {
	if m != nil {
		return m.OriginalOperatorUin
	}
	return 0
}

func (m *D89AReqBody) GetReqGroupOpenAppid() int32 {
	if m != nil {
		return m.ReqGroupOpenAppid
	}
	return 0
}

type D89AGroupinfo struct {
	GroupExtAdmNum         int32                       `protobuf:"varint,1,opt,name=groupExtAdmNum,proto3" json:"groupExtAdmNum,omitempty"`
	Flag                   int32                       `protobuf:"varint,2,opt,name=flag,proto3" json:"flag,omitempty"`
	IngGroupName           []byte                      `protobuf:"bytes,3,opt,name=ingGroupName,proto3" json:"ingGroupName,omitempty"`
	IngGroupMemo           []byte                      `protobuf:"bytes,4,opt,name=ingGroupMemo,proto3" json:"ingGroupMemo,omitempty"`
	IngGroupFingerMemo     []byte                      `protobuf:"bytes,5,opt,name=ingGroupFingerMemo,proto3" json:"ingGroupFingerMemo,omitempty"`
	IngGroupAioSkinUrl     []byte                      `protobuf:"bytes,6,opt,name=ingGroupAioSkinUrl,proto3" json:"ingGroupAioSkinUrl,omitempty"`
	IngGroupBoardSkinUrl   []byte                      `protobuf:"bytes,7,opt,name=ingGroupBoardSkinUrl,proto3" json:"ingGroupBoardSkinUrl,omitempty"`
	IngGroupCoverSkinUrl   []byte                      `protobuf:"bytes,8,opt,name=ingGroupCoverSkinUrl,proto3" json:"ingGroupCoverSkinUrl,omitempty"`
	GroupGrade             int32                       `protobuf:"varint,9,opt,name=groupGrade,proto3" json:"groupGrade,omitempty"`
	ActiveMemberNum        int32                       `protobuf:"varint,10,opt,name=activeMemberNum,proto3" json:"activeMemberNum,omitempty"`
	CertificationType      int32                       `protobuf:"varint,11,opt,name=certificationType,proto3" json:"certificationType,omitempty"`
	IngCertificationText   []byte                      `protobuf:"bytes,12,opt,name=ingCertificationText,proto3" json:"ingCertificationText,omitempty"`
	IngGroupRichFingerMemo []byte                      `protobuf:"bytes,13,opt,name=ingGroupRichFingerMemo,proto3" json:"ingGroupRichFingerMemo,omitempty"`
	StGroupNewguidelines   *D89AGroupNewGuidelinesInfo `protobuf:"bytes,14,opt,name=stGroupNewguidelines,proto3" json:"stGroupNewguidelines,omitempty"`
	GroupFace              int32                       `protobuf:"varint,15,opt,name=groupFace,proto3" json:"groupFace,omitempty"`
	AddOption              int32                       `protobuf:"varint,16,opt,name=addOption,proto3" json:"addOption,omitempty"`
	// Types that are valid to be assigned to ShutupTime:
	//	*D89AGroupinfo_Val
	ShutupTime           isD89AGroupinfo_ShutupTime `protobuf_oneof:"shutupTime"`
	GroupTypeFlag        int32                      `protobuf:"varint,18,opt,name=groupTypeFlag,proto3" json:"groupTypeFlag,omitempty"`
	StringGroupTag       []byte                     `protobuf:"bytes,19,opt,name=stringGroupTag,proto3" json:"stringGroupTag,omitempty"`
	MsgGroupGeoInfo      *D89AGroupGeoInfo          `protobuf:"bytes,20,opt,name=msgGroupGeoInfo,proto3" json:"msgGroupGeoInfo,omitempty"`
	GroupClassExt        int32                      `protobuf:"varint,21,opt,name=groupClassExt,proto3" json:"groupClassExt,omitempty"`
	IngGroupClassText    []byte                     `protobuf:"bytes,22,opt,name=ingGroupClassText,proto3" json:"ingGroupClassText,omitempty"`
	AppPrivilegeFlag     int32                      `protobuf:"varint,23,opt,name=appPrivilegeFlag,proto3" json:"appPrivilegeFlag,omitempty"`
	AppPrivilegeMask     int32                      `protobuf:"varint,24,opt,name=appPrivilegeMask,proto3" json:"appPrivilegeMask,omitempty"`
	StGroupExInfo        *D89AGroupExInfoOnly       `protobuf:"bytes,25,opt,name=stGroupExInfo,proto3" json:"stGroupExInfo,omitempty"`
	GroupSecLevel        int32                      `protobuf:"varint,26,opt,name=groupSecLevel,proto3" json:"groupSecLevel,omitempty"`
	GroupSecLevelInfo    int32                      `protobuf:"varint,27,opt,name=groupSecLevelInfo,proto3" json:"groupSecLevelInfo,omitempty"`
	SubscriptionUin      int64                      `protobuf:"varint,28,opt,name=subscriptionUin,proto3" json:"subscriptionUin,omitempty"`
	AllowMemberInvite    int32                      `protobuf:"varint,29,opt,name=allowMemberInvite,proto3" json:"allowMemberInvite,omitempty"`
	IngGroupQuestion     []byte                     `protobuf:"bytes,30,opt,name=ingGroupQuestion,proto3" json:"ingGroupQuestion,omitempty"`
	IngGroupAnswer       []byte                     `protobuf:"bytes,31,opt,name=ingGroupAnswer,proto3" json:"ingGroupAnswer,omitempty"`
	GroupFlagext3        int32                      `protobuf:"varint,32,opt,name=groupFlagext3,proto3" json:"groupFlagext3,omitempty"`
	GroupFlagext3Mask    int32                      `protobuf:"varint,33,opt,name=groupFlagext3Mask,proto3" json:"groupFlagext3Mask,omitempty"`
	GroupOpenAppid       int32                      `protobuf:"varint,34,opt,name=groupOpenAppid,proto3" json:"groupOpenAppid,omitempty"`
	NoFingerOpenFlag     int32                      `protobuf:"varint,35,opt,name=noFingerOpenFlag,proto3" json:"noFingerOpenFlag,omitempty"`
	NoCodeFingerOpenFlag int32                      `protobuf:"varint,36,opt,name=noCodeFingerOpenFlag,proto3" json:"noCodeFingerOpenFlag,omitempty"`
	RootId               int64                      `protobuf:"varint,37,opt,name=rootId,proto3" json:"rootId,omitempty"`
	MsgLimitFrequency    int32                      `protobuf:"varint,38,opt,name=msgLimitFrequency,proto3" json:"msgLimitFrequency,omitempty"`
}

func (m *D89AGroupinfo) Reset()         { *m = D89AGroupinfo{} }
func (m *D89AGroupinfo) String() string { return proto.CompactTextString(m) }
func (*D89AGroupinfo) ProtoMessage()    {}
func (*D89AGroupinfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{6}
}
func (m *D89AGroupinfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D89AGroupinfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D89AGroupinfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D89AGroupinfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D89AGroupinfo.Merge(m, src)
}
func (m *D89AGroupinfo) XXX_Size() int {
	return m.Size()
}
func (m *D89AGroupinfo) XXX_DiscardUnknown() {
	xxx_messageInfo_D89AGroupinfo.DiscardUnknown(m)
}

var xxx_messageInfo_D89AGroupinfo proto.InternalMessageInfo

type isD89AGroupinfo_ShutupTime interface {
	isD89AGroupinfo_ShutupTime()
	MarshalTo([]byte) (int, error)
	Size() int
}

type D89AGroupinfo_Val struct {
	Val int32 `protobuf:"varint,17,opt,name=val,proto3,oneof" json:"val,omitempty"`
}

func (*D89AGroupinfo_Val) isD89AGroupinfo_ShutupTime() {}

func (m *D89AGroupinfo) GetShutupTime() isD89AGroupinfo_ShutupTime {
	if m != nil {
		return m.ShutupTime
	}
	return nil
}

func (m *D89AGroupinfo) GetGroupExtAdmNum() int32 {
	if m != nil {
		return m.GroupExtAdmNum
	}
	return 0
}

func (m *D89AGroupinfo) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *D89AGroupinfo) GetIngGroupName() []byte {
	if m != nil {
		return m.IngGroupName
	}
	return nil
}

func (m *D89AGroupinfo) GetIngGroupMemo() []byte {
	if m != nil {
		return m.IngGroupMemo
	}
	return nil
}

func (m *D89AGroupinfo) GetIngGroupFingerMemo() []byte {
	if m != nil {
		return m.IngGroupFingerMemo
	}
	return nil
}

func (m *D89AGroupinfo) GetIngGroupAioSkinUrl() []byte {
	if m != nil {
		return m.IngGroupAioSkinUrl
	}
	return nil
}

func (m *D89AGroupinfo) GetIngGroupBoardSkinUrl() []byte {
	if m != nil {
		return m.IngGroupBoardSkinUrl
	}
	return nil
}

func (m *D89AGroupinfo) GetIngGroupCoverSkinUrl() []byte {
	if m != nil {
		return m.IngGroupCoverSkinUrl
	}
	return nil
}

func (m *D89AGroupinfo) GetGroupGrade() int32 {
	if m != nil {
		return m.GroupGrade
	}
	return 0
}

func (m *D89AGroupinfo) GetActiveMemberNum() int32 {
	if m != nil {
		return m.ActiveMemberNum
	}
	return 0
}

func (m *D89AGroupinfo) GetCertificationType() int32 {
	if m != nil {
		return m.CertificationType
	}
	return 0
}

func (m *D89AGroupinfo) GetIngCertificationText() []byte {
	if m != nil {
		return m.IngCertificationText
	}
	return nil
}

func (m *D89AGroupinfo) GetIngGroupRichFingerMemo() []byte {
	if m != nil {
		return m.IngGroupRichFingerMemo
	}
	return nil
}

func (m *D89AGroupinfo) GetStGroupNewguidelines() *D89AGroupNewGuidelinesInfo {
	if m != nil {
		return m.StGroupNewguidelines
	}
	return nil
}

func (m *D89AGroupinfo) GetGroupFace() int32 {
	if m != nil {
		return m.GroupFace
	}
	return 0
}

func (m *D89AGroupinfo) GetAddOption() int32 {
	if m != nil {
		return m.AddOption
	}
	return 0
}

func (m *D89AGroupinfo) GetVal() int32 {
	if x, ok := m.GetShutupTime().(*D89AGroupinfo_Val); ok {
		return x.Val
	}
	return 0
}

func (m *D89AGroupinfo) GetGroupTypeFlag() int32 {
	if m != nil {
		return m.GroupTypeFlag
	}
	return 0
}

func (m *D89AGroupinfo) GetStringGroupTag() []byte {
	if m != nil {
		return m.StringGroupTag
	}
	return nil
}

func (m *D89AGroupinfo) GetMsgGroupGeoInfo() *D89AGroupGeoInfo {
	if m != nil {
		return m.MsgGroupGeoInfo
	}
	return nil
}

func (m *D89AGroupinfo) GetGroupClassExt() int32 {
	if m != nil {
		return m.GroupClassExt
	}
	return 0
}

func (m *D89AGroupinfo) GetIngGroupClassText() []byte {
	if m != nil {
		return m.IngGroupClassText
	}
	return nil
}

func (m *D89AGroupinfo) GetAppPrivilegeFlag() int32 {
	if m != nil {
		return m.AppPrivilegeFlag
	}
	return 0
}

func (m *D89AGroupinfo) GetAppPrivilegeMask() int32 {
	if m != nil {
		return m.AppPrivilegeMask
	}
	return 0
}

func (m *D89AGroupinfo) GetStGroupExInfo() *D89AGroupExInfoOnly {
	if m != nil {
		return m.StGroupExInfo
	}
	return nil
}

func (m *D89AGroupinfo) GetGroupSecLevel() int32 {
	if m != nil {
		return m.GroupSecLevel
	}
	return 0
}

func (m *D89AGroupinfo) GetGroupSecLevelInfo() int32 {
	if m != nil {
		return m.GroupSecLevelInfo
	}
	return 0
}

func (m *D89AGroupinfo) GetSubscriptionUin() int64 {
	if m != nil {
		return m.SubscriptionUin
	}
	return 0
}

func (m *D89AGroupinfo) GetAllowMemberInvite() int32 {
	if m != nil {
		return m.AllowMemberInvite
	}
	return 0
}

func (m *D89AGroupinfo) GetIngGroupQuestion() []byte {
	if m != nil {
		return m.IngGroupQuestion
	}
	return nil
}

func (m *D89AGroupinfo) GetIngGroupAnswer() []byte {
	if m != nil {
		return m.IngGroupAnswer
	}
	return nil
}

func (m *D89AGroupinfo) GetGroupFlagext3() int32 {
	if m != nil {
		return m.GroupFlagext3
	}
	return 0
}

func (m *D89AGroupinfo) GetGroupFlagext3Mask() int32 {
	if m != nil {
		return m.GroupFlagext3Mask
	}
	return 0
}

func (m *D89AGroupinfo) GetGroupOpenAppid() int32 {
	if m != nil {
		return m.GroupOpenAppid
	}
	return 0
}

func (m *D89AGroupinfo) GetNoFingerOpenFlag() int32 {
	if m != nil {
		return m.NoFingerOpenFlag
	}
	return 0
}

func (m *D89AGroupinfo) GetNoCodeFingerOpenFlag() int32 {
	if m != nil {
		return m.NoCodeFingerOpenFlag
	}
	return 0
}

func (m *D89AGroupinfo) GetRootId() int64 {
	if m != nil {
		return m.RootId
	}
	return 0
}

func (m *D89AGroupinfo) GetMsgLimitFrequency() int32 {
	if m != nil {
		return m.MsgLimitFrequency
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*D89AGroupinfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*D89AGroupinfo_Val)(nil),
	}
}

type D89AGroupNewGuidelinesInfo struct {
	BoolEnabled bool   `protobuf:"varint,1,opt,name=boolEnabled,proto3" json:"boolEnabled,omitempty"`
	IngContent  []byte `protobuf:"bytes,2,opt,name=ingContent,proto3" json:"ingContent,omitempty"`
}

func (m *D89AGroupNewGuidelinesInfo) Reset()         { *m = D89AGroupNewGuidelinesInfo{} }
func (m *D89AGroupNewGuidelinesInfo) String() string { return proto.CompactTextString(m) }
func (*D89AGroupNewGuidelinesInfo) ProtoMessage()    {}
func (*D89AGroupNewGuidelinesInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{7}
}
func (m *D89AGroupNewGuidelinesInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D89AGroupNewGuidelinesInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D89AGroupNewGuidelinesInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D89AGroupNewGuidelinesInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D89AGroupNewGuidelinesInfo.Merge(m, src)
}
func (m *D89AGroupNewGuidelinesInfo) XXX_Size() int {
	return m.Size()
}
func (m *D89AGroupNewGuidelinesInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_D89AGroupNewGuidelinesInfo.DiscardUnknown(m)
}

var xxx_messageInfo_D89AGroupNewGuidelinesInfo proto.InternalMessageInfo

func (m *D89AGroupNewGuidelinesInfo) GetBoolEnabled() bool {
	if m != nil {
		return m.BoolEnabled
	}
	return false
}

func (m *D89AGroupNewGuidelinesInfo) GetIngContent() []byte {
	if m != nil {
		return m.IngContent
	}
	return nil
}

type D89AGroupExInfoOnly struct {
	TribeId          int32 `protobuf:"varint,1,opt,name=tribeId,proto3" json:"tribeId,omitempty"`
	MoneyForAddGroup int32 `protobuf:"varint,2,opt,name=moneyForAddGroup,proto3" json:"moneyForAddGroup,omitempty"`
}

func (m *D89AGroupExInfoOnly) Reset()         { *m = D89AGroupExInfoOnly{} }
func (m *D89AGroupExInfoOnly) String() string { return proto.CompactTextString(m) }
func (*D89AGroupExInfoOnly) ProtoMessage()    {}
func (*D89AGroupExInfoOnly) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{8}
}
func (m *D89AGroupExInfoOnly) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D89AGroupExInfoOnly) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D89AGroupExInfoOnly.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D89AGroupExInfoOnly) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D89AGroupExInfoOnly.Merge(m, src)
}
func (m *D89AGroupExInfoOnly) XXX_Size() int {
	return m.Size()
}
func (m *D89AGroupExInfoOnly) XXX_DiscardUnknown() {
	xxx_messageInfo_D89AGroupExInfoOnly.DiscardUnknown(m)
}

var xxx_messageInfo_D89AGroupExInfoOnly proto.InternalMessageInfo

func (m *D89AGroupExInfoOnly) GetTribeId() int32 {
	if m != nil {
		return m.TribeId
	}
	return 0
}

func (m *D89AGroupExInfoOnly) GetMoneyForAddGroup() int32 {
	if m != nil {
		return m.MoneyForAddGroup
	}
	return 0
}

type D89AGroupGeoInfo struct {
	CityId        int32  `protobuf:"varint,1,opt,name=cityId,proto3" json:"cityId,omitempty"`
	Longtitude    int64  `protobuf:"varint,2,opt,name=longtitude,proto3" json:"longtitude,omitempty"`
	Latitude      int64  `protobuf:"varint,3,opt,name=latitude,proto3" json:"latitude,omitempty"`
	IngGeoContent []byte `protobuf:"bytes,4,opt,name=ingGeoContent,proto3" json:"ingGeoContent,omitempty"`
	PoiId         int64  `protobuf:"varint,5,opt,name=poiId,proto3" json:"poiId,omitempty"`
}

func (m *D89AGroupGeoInfo) Reset()         { *m = D89AGroupGeoInfo{} }
func (m *D89AGroupGeoInfo) String() string { return proto.CompactTextString(m) }
func (*D89AGroupGeoInfo) ProtoMessage()    {}
func (*D89AGroupGeoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{9}
}
func (m *D89AGroupGeoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D89AGroupGeoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D89AGroupGeoInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D89AGroupGeoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D89AGroupGeoInfo.Merge(m, src)
}
func (m *D89AGroupGeoInfo) XXX_Size() int {
	return m.Size()
}
func (m *D89AGroupGeoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_D89AGroupGeoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_D89AGroupGeoInfo proto.InternalMessageInfo

func (m *D89AGroupGeoInfo) GetCityId() int32 {
	if m != nil {
		return m.CityId
	}
	return 0
}

func (m *D89AGroupGeoInfo) GetLongtitude() int64 {
	if m != nil {
		return m.Longtitude
	}
	return 0
}

func (m *D89AGroupGeoInfo) GetLatitude() int64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *D89AGroupGeoInfo) GetIngGeoContent() []byte {
	if m != nil {
		return m.IngGeoContent
	}
	return nil
}

func (m *D89AGroupGeoInfo) GetPoiId() int64 {
	if m != nil {
		return m.PoiId
	}
	return 0
}

type DED3ReqBody struct {
	ToUin     int64 `protobuf:"varint,1,opt,name=toUin,proto3" json:"toUin,omitempty"`
	GroupCode int64 `protobuf:"varint,2,opt,name=groupCode,proto3" json:"groupCode,omitempty"`
	MsgSeq    int32 `protobuf:"varint,3,opt,name=msgSeq,proto3" json:"msgSeq,omitempty"`
	MsgRand   int32 `protobuf:"varint,4,opt,name=msgRand,proto3" json:"msgRand,omitempty"`
	AioUin    int64 `protobuf:"varint,5,opt,name=aioUin,proto3" json:"aioUin,omitempty"`
}

func (m *DED3ReqBody) Reset()         { *m = DED3ReqBody{} }
func (m *DED3ReqBody) String() string { return proto.CompactTextString(m) }
func (*DED3ReqBody) ProtoMessage()    {}
func (*DED3ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_3e8a13c74450e44e, []int{10}
}
func (m *DED3ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DED3ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DED3ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DED3ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DED3ReqBody.Merge(m, src)
}
func (m *DED3ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *DED3ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_DED3ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_DED3ReqBody proto.InternalMessageInfo

func (m *DED3ReqBody) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *DED3ReqBody) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *DED3ReqBody) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *DED3ReqBody) GetMsgRand() int32 {
	if m != nil {
		return m.MsgRand
	}
	return 0
}

func (m *DED3ReqBody) GetAioUin() int64 {
	if m != nil {
		return m.AioUin
	}
	return 0
}

func init() {
	proto.RegisterType((*OIDBSSOPkg)(nil), "OIDBSSOPkg")
	proto.RegisterType((*D8A0RspBody)(nil), "D8A0RspBody")
	proto.RegisterType((*D8A0KickResult)(nil), "D8A0KickResult")
	proto.RegisterType((*D8A0KickMemberInfo)(nil), "D8A0KickMemberInfo")
	proto.RegisterType((*D8A0ReqBody)(nil), "D8A0ReqBody")
	proto.RegisterType((*D89AReqBody)(nil), "D89AReqBody")
	proto.RegisterType((*D89AGroupinfo)(nil), "D89AGroupinfo")
	proto.RegisterType((*D89AGroupNewGuidelinesInfo)(nil), "D89AGroupNewGuidelinesInfo")
	proto.RegisterType((*D89AGroupExInfoOnly)(nil), "D89AGroupExInfoOnly")
	proto.RegisterType((*D89AGroupGeoInfo)(nil), "D89AGroupGeoInfo")
	proto.RegisterType((*DED3ReqBody)(nil), "DED3ReqBody")
}

func init() { proto.RegisterFile("oidb.proto", fileDescriptor_3e8a13c74450e44e) }

var fileDescriptor_3e8a13c74450e44e = []byte{
	// 1284 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcf, 0x72, 0xdc, 0xc4,
	0x13, 0xf6, 0x66, 0x63, 0x27, 0x99, 0x5d, 0xdb, 0xc9, 0xd8, 0x3f, 0xff, 0x44, 0x12, 0x96, 0x45,
	0x84, 0x94, 0x8b, 0xa2, 0x5c, 0x29, 0x1b, 0x52, 0x40, 0x4e, 0xb6, 0x63, 0x1b, 0x17, 0xb1, 0x37,
	0xc8, 0x09, 0x07, 0xa8, 0xa2, 0x4a, 0x2b, 0xb5, 0x95, 0xc1, 0x92, 0x46, 0x1e, 0xcd, 0xae, 0xbd,
	0x67, 0x8e, 0x5c, 0x78, 0x06, 0x9e, 0x82, 0x0b, 0x17, 0x0e, 0x14, 0xc7, 0x1c, 0x39, 0x52, 0xf1,
	0x8b, 0x50, 0xdd, 0x23, 0x69, 0xf5, 0x67, 0x73, 0x80, 0xdb, 0xf6, 0xf7, 0xf5, 0x8c, 0xfa, 0xeb,
	0xee, 0xe9, 0x99, 0x65, 0x4c, 0x0a, 0x7f, 0xb8, 0x91, 0x28, 0xa9, 0xa5, 0xfd, 0x7b, 0x8b, 0xb1,
	0xc1, 0xe1, 0xd3, 0x9d, 0x93, 0x93, 0xc1, 0xf3, 0xb3, 0x80, 0x5b, 0xec, 0x86, 0x27, 0xa3, 0xc8,
	0x8d, 0x7d, 0xab, 0xd5, 0x6f, 0xad, 0xcf, 0x3b, 0xb9, 0xc9, 0xfb, 0xac, 0x93, 0x82, 0x1a, 0x0b,
	0x0f, 0x5e, 0x4c, 0x12, 0xb0, 0xae, 0x11, 0x5b, 0x86, 0xf8, 0x1a, 0x5b, 0x50, 0x90, 0x8e, 0x42,
	0x6d, 0xb5, 0x89, 0xcc, 0x2c, 0xde, 0x63, 0x6c, 0x28, 0xfd, 0xc9, 0x70, 0x74, 0x7a, 0x0a, 0xca,
	0xba, 0xde, 0x6f, 0xad, 0x77, 0x9d, 0x12, 0xc2, 0xef, 0xb2, 0x9b, 0xa0, 0x94, 0x54, 0x47, 0x69,
	0x60, 0xcd, 0xf7, 0x5b, 0xeb, 0xb7, 0x9c, 0xc2, 0xe6, 0x0f, 0xd8, 0xa2, 0x17, 0x0a, 0x88, 0xf5,
	0x37, 0xa0, 0x52, 0x21, 0x63, 0x6b, 0x81, 0x1c, 0xaa, 0xa0, 0xad, 0x59, 0xe7, 0xe9, 0x67, 0xdb,
	0x8f, 0x9c, 0x34, 0xd9, 0x91, 0xfe, 0x84, 0x6f, 0x30, 0x2e, 0x13, 0xfd, 0x52, 0xc4, 0xfa, 0xf1,
	0x27, 0x07, 0x4a, 0x8e, 0x92, 0x5d, 0xe9, 0x03, 0xe9, 0x69, 0x3b, 0x33, 0x18, 0xfe, 0x29, 0x5b,
	0x8c, 0xd2, 0xe0, 0x2b, 0xe1, 0x9d, 0x39, 0x26, 0xfe, 0x6b, 0xfd, 0xf6, 0x7a, 0x67, 0x73, 0x79,
	0x03, 0x37, 0x9d, 0xc2, 0x4e, 0xd5, 0xcb, 0xfe, 0x81, 0x2d, 0x55, 0x1d, 0xf8, 0x3a, 0x5b, 0xce,
	0xb6, 0xdf, 0xda, 0xcc, 0xb6, 0x32, 0x59, 0xac, 0xc3, 0x95, 0x10, 0x8f, 0x20, 0x1a, 0x82, 0x7a,
	0x29, 0x62, 0x4a, 0x6a, 0x39, 0xc4, 0x82, 0xb1, 0x7f, 0x6d, 0x31, 0x9e, 0x7f, 0xcc, 0xa0, 0x87,
	0xf1, 0xa9, 0xe4, 0x1f, 0xb1, 0xdb, 0xc5, 0xce, 0x83, 0x04, 0x94, 0xab, 0x21, 0xfb, 0x62, 0x03,
	0xff, 0xb7, 0x9f, 0xc4, 0xd4, 0x17, 0x7b, 0xec, 0x87, 0x6e, 0x90, 0x55, 0xb5, 0x0a, 0x62, 0x5b,
	0xc8, 0x44, 0xef, 0x4c, 0x34, 0xa4, 0x58, 0x3f, 0x53, 0xdd, 0x32, 0x64, 0xff, 0xd1, 0xca, 0xaa,
	0x03, 0xe7, 0xff, 0xb1, 0x3a, 0x9d, 0x2c, 0xef, 0xcf, 0x44, 0x9a, 0xd7, 0x66, 0x65, 0xa3, 0x99,
	0x0d, 0xa7, 0xec, 0x87, 0x5d, 0x75, 0x96, 0xaf, 0x69, 0xf7, 0xdb, 0xeb, 0x6d, 0xa7, 0xb0, 0x73,
	0x8e, 0x54, 0x5d, 0x27, 0x55, 0x85, 0x8d, 0x27, 0x00, 0x7f, 0xe7, 0xcd, 0xd8, 0x75, 0x72, 0xd3,
	0xfe, 0x8d, 0x84, 0x7c, 0xbe, 0x9d, 0x0b, 0xb9, 0xcf, 0x6e, 0x05, 0xb5, 0xf8, 0xa7, 0x00, 0x7f,
	0xc4, 0x3a, 0xa9, 0x26, 0x15, 0x18, 0x1b, 0xe5, 0xb9, 0xb3, 0xb9, 0xb4, 0x81, 0x1b, 0x10, 0x2a,
	0x28, 0xe2, 0x92, 0x0b, 0x7f, 0xc4, 0x56, 0xa4, 0x12, 0x81, 0x88, 0xdd, 0xd0, 0xd4, 0x4c, 0x52,
	0x85, 0xda, 0xb4, 0xf3, 0x2c, 0x8a, 0x7f, 0xcc, 0xee, 0x28, 0x38, 0xa7, 0x1d, 0x06, 0x09, 0xc4,
	0xdb, 0x49, 0x22, 0xfc, 0x4c, 0x50, 0x93, 0xb0, 0x7f, 0x5c, 0x64, 0x8b, 0x95, 0xcf, 0xf3, 0x87,
	0x6c, 0x89, 0x02, 0xde, 0xbb, 0xd4, 0xdb, 0x7e, 0x74, 0x3c, 0x8a, 0xb2, 0xe6, 0xa9, 0xa1, 0x9c,
	0xb3, 0xeb, 0xa7, 0x98, 0x2b, 0x73, 0xe8, 0xe9, 0x37, 0xb7, 0x59, 0x57, 0xc4, 0x01, 0xed, 0x75,
	0xec, 0x46, 0x40, 0x61, 0x76, 0x9d, 0x0a, 0x56, 0xf6, 0x39, 0x82, 0x48, 0x66, 0xdd, 0x51, 0xc1,
	0xb0, 0x1d, 0x72, 0x7b, 0x5f, 0xc4, 0x01, 0x28, 0xf2, 0x34, 0xa9, 0x9f, 0xc1, 0x94, 0xfd, 0xb7,
	0x85, 0x3c, 0x39, 0x13, 0xf1, 0x4b, 0x15, 0xd2, 0x58, 0x28, 0xf9, 0x4f, 0x19, 0xbe, 0xc9, 0x56,
	0x73, 0x74, 0x47, 0xba, 0xca, 0xcf, 0x57, 0xdc, 0xa0, 0x15, 0x33, 0xb9, 0xf2, 0x9a, 0x5d, 0x39,
	0x06, 0x95, 0xaf, 0xb9, 0x59, 0x5d, 0x53, 0xe6, 0x70, 0xca, 0x51, 0xd6, 0x0e, 0x94, 0xeb, 0x83,
	0x75, 0x8b, 0x32, 0x55, 0x42, 0x70, 0x36, 0xb8, 0x9e, 0x16, 0x63, 0x30, 0x0d, 0x8b, 0xc9, 0x66,
	0x66, 0x36, 0xd4, 0x60, 0xac, 0xaa, 0x07, 0x4a, 0x8b, 0x53, 0xe1, 0xb9, 0x5a, 0xc8, 0x98, 0xe6,
	0x6d, 0xc7, 0x54, 0xb5, 0x41, 0x64, 0xb1, 0xee, 0x56, 0x70, 0xb8, 0xd4, 0x56, 0xb7, 0x88, 0xb5,
	0xc1, 0xf1, 0xc7, 0x6c, 0x2d, 0xd7, 0xe0, 0x08, 0xef, 0x55, 0x29, 0xef, 0x8b, 0xb4, 0xea, 0x2d,
	0x2c, 0x1f, 0xb0, 0xd5, 0xac, 0x61, 0x8f, 0xe1, 0x22, 0x18, 0x09, 0x1f, 0x42, 0x11, 0x43, 0x6a,
	0x2d, 0x51, 0x73, 0xdf, 0x9b, 0x36, 0xf7, 0x31, 0x5c, 0x1c, 0x14, 0x34, 0x9d, 0xcd, 0x99, 0x0b,
	0x8b, 0x23, 0xb4, 0xef, 0x7a, 0x60, 0x2d, 0x93, 0xc4, 0x29, 0x80, 0xac, 0xeb, 0xfb, 0x83, 0x04,
	0xe3, 0xb6, 0x6e, 0x1b, 0xb6, 0x00, 0x38, 0x67, 0xed, 0xb1, 0x1b, 0x5a, 0x77, 0x10, 0xff, 0x72,
	0xce, 0x41, 0x03, 0x67, 0x16, 0x2d, 0xc7, 0xcc, 0xd0, 0xe9, 0xe6, 0x66, 0x66, 0x55, 0x40, 0x6c,
	0xfb, 0x54, 0xab, 0x5c, 0xe3, 0x0b, 0x37, 0xb0, 0x56, 0x48, 0x76, 0x0d, 0xe5, 0x4f, 0xd8, 0x72,
	0x94, 0x1a, 0xf3, 0x00, 0x24, 0x1d, 0xe3, 0x55, 0x52, 0x7a, 0x67, 0xaa, 0x34, 0x23, 0x9c, 0xba,
	0x67, 0x11, 0xca, 0x6e, 0xe8, 0xa6, 0xe9, 0xde, 0xa5, 0xb6, 0xfe, 0x57, 0x0a, 0x25, 0x07, 0xb1,
	0xd6, 0x45, 0x37, 0x21, 0x46, 0xa5, 0x5b, 0xa3, 0x68, 0x9a, 0x04, 0x8e, 0x7b, 0x37, 0x49, 0x9e,
	0x2b, 0x31, 0x16, 0x21, 0x04, 0x46, 0xe1, 0xff, 0xcd, 0xb8, 0xaf, 0xe3, 0x75, 0xdf, 0x23, 0x37,
	0x3d, 0xb3, 0xac, 0xa6, 0x2f, 0xe2, 0xfc, 0x0b, 0xb6, 0x98, 0x95, 0x67, 0xef, 0x92, 0x64, 0xbe,
	0x43, 0x32, 0x57, 0xa7, 0x32, 0x0d, 0x3e, 0x88, 0xc3, 0x89, 0x53, 0x75, 0x2d, 0x74, 0x9e, 0x80,
	0xf7, 0x0c, 0xc6, 0x10, 0x5a, 0x77, 0x4b, 0x3a, 0x73, 0x10, 0x75, 0x56, 0x00, 0xfa, 0xca, 0x3d,
	0xd3, 0xd3, 0x0d, 0x02, 0xcf, 0x4a, 0x3a, 0x1a, 0xa6, 0x9e, 0x12, 0x54, 0x6a, 0x9c, 0x82, 0xf7,
	0x69, 0x0a, 0xd6, 0x61, 0xdc, 0xd7, 0x0d, 0x43, 0x79, 0x91, 0xdf, 0x02, 0x63, 0xa1, 0xc1, 0x7a,
	0xd7, 0xec, 0xdb, 0x20, 0x30, 0x27, 0x79, 0x52, 0xbf, 0x1e, 0x41, 0x4a, 0x7d, 0xd5, 0xa3, 0x64,
	0x37, 0x70, 0x6c, 0x92, 0x62, 0x9a, 0xc4, 0xe9, 0x05, 0x28, 0xeb, 0x3d, 0xd3, 0x24, 0x55, 0xb4,
	0xd0, 0x8f, 0x49, 0x87, 0x4b, 0xbd, 0x65, 0xf5, 0x4b, 0xfa, 0x73, 0xb0, 0xd0, 0x9f, 0x03, 0x54,
	0x8e, 0xf7, 0x4b, 0xfa, 0xcb, 0x44, 0x31, 0x97, 0xa7, 0x43, 0xdd, 0x2e, 0xcd, 0xe5, 0x02, 0x45,
	0x3d, 0xb1, 0x34, 0xe7, 0x13, 0x41, 0xea, 0x87, 0x0f, 0x4c, 0x8d, 0xeb, 0x38, 0xce, 0x89, 0x58,
	0xe2, 0xcd, 0x54, 0xf3, 0x7f, 0x40, 0xfe, 0x33, 0x39, 0x7a, 0xd1, 0x49, 0xa9, 0x0f, 0x7d, 0xeb,
	0x43, 0x4a, 0x7f, 0x66, 0xa1, 0x9a, 0x28, 0x0d, 0x9e, 0x89, 0x48, 0xe8, 0x7d, 0x05, 0xe7, 0x23,
	0x88, 0xbd, 0x89, 0xf5, 0xd0, 0xa8, 0x69, 0x10, 0x3b, 0x5d, 0xc6, 0xd2, 0x57, 0x23, 0x3d, 0x4a,
	0x5e, 0x88, 0x08, 0xec, 0xef, 0xd9, 0xdd, 0xb7, 0x8f, 0x09, 0x7c, 0x4e, 0x0c, 0xa5, 0x0c, 0xf7,
	0x62, 0x77, 0x18, 0x82, 0x79, 0x83, 0xde, 0x74, 0xca, 0x10, 0xce, 0x59, 0x9c, 0x69, 0x32, 0xd6,
	0x10, 0x6b, 0xba, 0x91, 0xba, 0x4e, 0x09, 0xb1, 0xbf, 0x63, 0x2b, 0x33, 0xba, 0x16, 0xaf, 0x75,
	0xad, 0xc4, 0x10, 0x0e, 0x8b, 0x87, 0x6d, 0x66, 0x62, 0x12, 0x23, 0x19, 0xc3, 0x64, 0x5f, 0xaa,
	0x6d, 0xdf, 0xa7, 0x75, 0xd9, 0x45, 0xd7, 0xc0, 0xed, 0x5f, 0x5a, 0xec, 0x76, 0xfd, 0xe8, 0x63,
	0x96, 0x3c, 0xa1, 0x27, 0xc5, 0xce, 0x99, 0x85, 0x91, 0x86, 0x32, 0x0e, 0xb4, 0xd0, 0x23, 0x1f,
	0xb2, 0x87, 0x56, 0x09, 0xc1, 0x57, 0x48, 0xe8, 0x66, 0xac, 0xb9, 0xe4, 0x0b, 0x1b, 0xbb, 0x0a,
	0xfb, 0x0c, 0x64, 0x2e, 0xd4, 0x5c, 0x9d, 0x55, 0x90, 0xaf, 0xb2, 0xf9, 0x44, 0x8a, 0x43, 0x9f,
	0xae, 0xcb, 0xb6, 0x63, 0x0c, 0xfb, 0x27, 0x7c, 0xa7, 0xec, 0x3d, 0xdd, 0xca, 0xdf, 0x29, 0xab,
	0x6c, 0x5e, 0x4b, 0x3c, 0x43, 0xe6, 0x8d, 0x62, 0x8c, 0xea, 0xeb, 0xe5, 0x5a, 0xfd, 0xf5, 0xb2,
	0xc6, 0x16, 0xa2, 0x34, 0x38, 0x81, 0xf3, 0xfc, 0x2d, 0x6f, 0x2c, 0x4c, 0x63, 0x94, 0x06, 0x0e,
	0xfe, 0x3f, 0x30, 0xef, 0x8c, 0xdc, 0xc4, 0x15, 0xae, 0xa0, 0xcf, 0x98, 0x60, 0x32, 0x6b, 0xa7,
	0xff, 0xe7, 0x9b, 0x5e, 0xeb, 0xf5, 0x9b, 0x5e, 0xeb, 0xef, 0x37, 0xbd, 0xd6, 0xcf, 0x57, 0xbd,
	0xb9, 0xd7, 0x57, 0xbd, 0xb9, 0xbf, 0xae, 0x7a, 0x73, 0xdf, 0x2e, 0x6c, 0x3c, 0xc1, 0x3f, 0x22,
	0xc3, 0x05, 0xfa, 0x27, 0xb2, 0xf5, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x71, 0xf7, 0x35, 0xc0,
	0x97, 0x0c, 0x00, 0x00,
}

func (m *OIDBSSOPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OIDBSSOPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OIDBSSOPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientVersion) > 0 {
		i -= len(m.ClientVersion)
		copy(dAtA[i:], m.ClientVersion)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.ClientVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Bodybuffer) > 0 {
		i -= len(m.Bodybuffer)
		copy(dAtA[i:], m.Bodybuffer)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.Bodybuffer)))
		i--
		dAtA[i] = 0x22
	}
	if m.Result != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x18
	}
	if m.ServiceType != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.ServiceType))
		i--
		dAtA[i] = 0x10
	}
	if m.Command != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.Command))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D8A0RspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D8A0RspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D8A0RspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MsgKickResult) > 0 {
		for iNdEx := len(m.MsgKickResult) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgKickResult[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OptUint64GroupCode != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OptUint64GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D8A0KickResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D8A0KickResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D8A0KickResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OptUint64MemberUin != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OptUint64MemberUin))
		i--
		dAtA[i] = 0x10
	}
	if m.OptUint32Result != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OptUint32Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D8A0KickMemberInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D8A0KickMemberInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D8A0KickMemberInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OptBytesMsg) > 0 {
		i -= len(m.OptBytesMsg)
		copy(dAtA[i:], m.OptBytesMsg)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.OptBytesMsg)))
		i--
		dAtA[i] = 0x22
	}
	if m.OptUint32Flag != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OptUint32Flag))
		i--
		dAtA[i] = 0x18
	}
	if m.OptUint64MemberUin != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OptUint64MemberUin))
		i--
		dAtA[i] = 0x10
	}
	if m.OptUint32Operate != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OptUint32Operate))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D8A0ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D8A0ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D8A0ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KickMsg) > 0 {
		i -= len(m.KickMsg)
		copy(dAtA[i:], m.KickMsg)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.KickMsg)))
		i--
		dAtA[i] = 0x2a
	}
	if m.KickFlag != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.KickFlag))
		i--
		dAtA[i] = 0x20
	}
	if len(m.KickList) > 0 {
		dAtA2 := make([]byte, len(m.KickList)*10)
		var j1 int
		for _, num1 := range m.KickList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintOidb(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MsgKickList) > 0 {
		for iNdEx := len(m.MsgKickList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgKickList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintOidb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OptUint64GroupCode != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OptUint64GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D89AReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D89AReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D89AReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqGroupOpenAppid != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.ReqGroupOpenAppid))
		i--
		dAtA[i] = 0x20
	}
	if m.OriginalOperatorUin != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.OriginalOperatorUin))
		i--
		dAtA[i] = 0x18
	}
	if m.StGroupInfo != nil {
		{
			size, err := m.StGroupInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupCode != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D89AGroupinfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D89AGroupinfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D89AGroupinfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgLimitFrequency != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.MsgLimitFrequency))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.RootId != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.RootId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.NoCodeFingerOpenFlag != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.NoCodeFingerOpenFlag))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.NoFingerOpenFlag != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.NoFingerOpenFlag))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.GroupOpenAppid != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupOpenAppid))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.GroupFlagext3Mask != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupFlagext3Mask))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.GroupFlagext3 != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupFlagext3))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if len(m.IngGroupAnswer) > 0 {
		i -= len(m.IngGroupAnswer)
		copy(dAtA[i:], m.IngGroupAnswer)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupAnswer)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.IngGroupQuestion) > 0 {
		i -= len(m.IngGroupQuestion)
		copy(dAtA[i:], m.IngGroupQuestion)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupQuestion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.AllowMemberInvite != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.AllowMemberInvite))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.SubscriptionUin != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.SubscriptionUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.GroupSecLevelInfo != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupSecLevelInfo))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.GroupSecLevel != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupSecLevel))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.StGroupExInfo != nil {
		{
			size, err := m.StGroupExInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.AppPrivilegeMask != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.AppPrivilegeMask))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.AppPrivilegeFlag != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.AppPrivilegeFlag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.IngGroupClassText) > 0 {
		i -= len(m.IngGroupClassText)
		copy(dAtA[i:], m.IngGroupClassText)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupClassText)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.GroupClassExt != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupClassExt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.MsgGroupGeoInfo != nil {
		{
			size, err := m.MsgGroupGeoInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.StringGroupTag) > 0 {
		i -= len(m.StringGroupTag)
		copy(dAtA[i:], m.StringGroupTag)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.StringGroupTag)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.GroupTypeFlag != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupTypeFlag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.ShutupTime != nil {
		{
			size := m.ShutupTime.Size()
			i -= size
			if _, err := m.ShutupTime.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AddOption != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.AddOption))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GroupFace != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupFace))
		i--
		dAtA[i] = 0x78
	}
	if m.StGroupNewguidelines != nil {
		{
			size, err := m.StGroupNewguidelines.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOidb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if len(m.IngGroupRichFingerMemo) > 0 {
		i -= len(m.IngGroupRichFingerMemo)
		copy(dAtA[i:], m.IngGroupRichFingerMemo)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupRichFingerMemo)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.IngCertificationText) > 0 {
		i -= len(m.IngCertificationText)
		copy(dAtA[i:], m.IngCertificationText)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngCertificationText)))
		i--
		dAtA[i] = 0x62
	}
	if m.CertificationType != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.CertificationType))
		i--
		dAtA[i] = 0x58
	}
	if m.ActiveMemberNum != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.ActiveMemberNum))
		i--
		dAtA[i] = 0x50
	}
	if m.GroupGrade != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupGrade))
		i--
		dAtA[i] = 0x48
	}
	if len(m.IngGroupCoverSkinUrl) > 0 {
		i -= len(m.IngGroupCoverSkinUrl)
		copy(dAtA[i:], m.IngGroupCoverSkinUrl)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupCoverSkinUrl)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.IngGroupBoardSkinUrl) > 0 {
		i -= len(m.IngGroupBoardSkinUrl)
		copy(dAtA[i:], m.IngGroupBoardSkinUrl)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupBoardSkinUrl)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.IngGroupAioSkinUrl) > 0 {
		i -= len(m.IngGroupAioSkinUrl)
		copy(dAtA[i:], m.IngGroupAioSkinUrl)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupAioSkinUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IngGroupFingerMemo) > 0 {
		i -= len(m.IngGroupFingerMemo)
		copy(dAtA[i:], m.IngGroupFingerMemo)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupFingerMemo)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IngGroupMemo) > 0 {
		i -= len(m.IngGroupMemo)
		copy(dAtA[i:], m.IngGroupMemo)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupMemo)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IngGroupName) > 0 {
		i -= len(m.IngGroupName)
		copy(dAtA[i:], m.IngGroupName)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGroupName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Flag != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupExtAdmNum != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupExtAdmNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D89AGroupinfo_Val) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D89AGroupinfo_Val) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintOidb(dAtA, i, uint64(m.Val))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x88
	return len(dAtA) - i, nil
}
func (m *D89AGroupNewGuidelinesInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D89AGroupNewGuidelinesInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D89AGroupNewGuidelinesInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IngContent) > 0 {
		i -= len(m.IngContent)
		copy(dAtA[i:], m.IngContent)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngContent)))
		i--
		dAtA[i] = 0x12
	}
	if m.BoolEnabled {
		i--
		if m.BoolEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D89AGroupExInfoOnly) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D89AGroupExInfoOnly) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D89AGroupExInfoOnly) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MoneyForAddGroup != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.MoneyForAddGroup))
		i--
		dAtA[i] = 0x10
	}
	if m.TribeId != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.TribeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D89AGroupGeoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D89AGroupGeoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D89AGroupGeoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PoiId != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.PoiId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.IngGeoContent) > 0 {
		i -= len(m.IngGeoContent)
		copy(dAtA[i:], m.IngGeoContent)
		i = encodeVarintOidb(dAtA, i, uint64(len(m.IngGeoContent)))
		i--
		dAtA[i] = 0x22
	}
	if m.Latitude != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.Latitude))
		i--
		dAtA[i] = 0x18
	}
	if m.Longtitude != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.Longtitude))
		i--
		dAtA[i] = 0x10
	}
	if m.CityId != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.CityId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DED3ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DED3ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DED3ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AioUin != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.AioUin))
		i--
		dAtA[i] = 0x28
	}
	if m.MsgRand != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.MsgRand))
		i--
		dAtA[i] = 0x20
	}
	if m.MsgSeq != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.MsgSeq))
		i--
		dAtA[i] = 0x18
	}
	if m.GroupCode != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.GroupCode))
		i--
		dAtA[i] = 0x10
	}
	if m.ToUin != 0 {
		i = encodeVarintOidb(dAtA, i, uint64(m.ToUin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOidb(dAtA []byte, offset int, v uint64) int {
	offset -= sovOidb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OIDBSSOPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Command != 0 {
		n += 1 + sovOidb(uint64(m.Command))
	}
	if m.ServiceType != 0 {
		n += 1 + sovOidb(uint64(m.ServiceType))
	}
	if m.Result != 0 {
		n += 1 + sovOidb(uint64(m.Result))
	}
	l = len(m.Bodybuffer)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.ClientVersion)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	return n
}

func (m *D8A0RspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptUint64GroupCode != 0 {
		n += 1 + sovOidb(uint64(m.OptUint64GroupCode))
	}
	if len(m.MsgKickResult) > 0 {
		for _, e := range m.MsgKickResult {
			l = e.Size()
			n += 1 + l + sovOidb(uint64(l))
		}
	}
	return n
}

func (m *D8A0KickResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptUint32Result != 0 {
		n += 1 + sovOidb(uint64(m.OptUint32Result))
	}
	if m.OptUint64MemberUin != 0 {
		n += 1 + sovOidb(uint64(m.OptUint64MemberUin))
	}
	return n
}

func (m *D8A0KickMemberInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptUint32Operate != 0 {
		n += 1 + sovOidb(uint64(m.OptUint32Operate))
	}
	if m.OptUint64MemberUin != 0 {
		n += 1 + sovOidb(uint64(m.OptUint64MemberUin))
	}
	if m.OptUint32Flag != 0 {
		n += 1 + sovOidb(uint64(m.OptUint32Flag))
	}
	l = len(m.OptBytesMsg)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	return n
}

func (m *D8A0ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptUint64GroupCode != 0 {
		n += 1 + sovOidb(uint64(m.OptUint64GroupCode))
	}
	if len(m.MsgKickList) > 0 {
		for _, e := range m.MsgKickList {
			l = e.Size()
			n += 1 + l + sovOidb(uint64(l))
		}
	}
	if len(m.KickList) > 0 {
		l = 0
		for _, e := range m.KickList {
			l += sovOidb(uint64(e))
		}
		n += 1 + sovOidb(uint64(l)) + l
	}
	if m.KickFlag != 0 {
		n += 1 + sovOidb(uint64(m.KickFlag))
	}
	l = len(m.KickMsg)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	return n
}

func (m *D89AReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupCode != 0 {
		n += 1 + sovOidb(uint64(m.GroupCode))
	}
	if m.StGroupInfo != nil {
		l = m.StGroupInfo.Size()
		n += 1 + l + sovOidb(uint64(l))
	}
	if m.OriginalOperatorUin != 0 {
		n += 1 + sovOidb(uint64(m.OriginalOperatorUin))
	}
	if m.ReqGroupOpenAppid != 0 {
		n += 1 + sovOidb(uint64(m.ReqGroupOpenAppid))
	}
	return n
}

func (m *D89AGroupinfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupExtAdmNum != 0 {
		n += 1 + sovOidb(uint64(m.GroupExtAdmNum))
	}
	if m.Flag != 0 {
		n += 1 + sovOidb(uint64(m.Flag))
	}
	l = len(m.IngGroupName)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.IngGroupMemo)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.IngGroupFingerMemo)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.IngGroupAioSkinUrl)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.IngGroupBoardSkinUrl)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.IngGroupCoverSkinUrl)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	if m.GroupGrade != 0 {
		n += 1 + sovOidb(uint64(m.GroupGrade))
	}
	if m.ActiveMemberNum != 0 {
		n += 1 + sovOidb(uint64(m.ActiveMemberNum))
	}
	if m.CertificationType != 0 {
		n += 1 + sovOidb(uint64(m.CertificationType))
	}
	l = len(m.IngCertificationText)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	l = len(m.IngGroupRichFingerMemo)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	if m.StGroupNewguidelines != nil {
		l = m.StGroupNewguidelines.Size()
		n += 1 + l + sovOidb(uint64(l))
	}
	if m.GroupFace != 0 {
		n += 1 + sovOidb(uint64(m.GroupFace))
	}
	if m.AddOption != 0 {
		n += 2 + sovOidb(uint64(m.AddOption))
	}
	if m.ShutupTime != nil {
		n += m.ShutupTime.Size()
	}
	if m.GroupTypeFlag != 0 {
		n += 2 + sovOidb(uint64(m.GroupTypeFlag))
	}
	l = len(m.StringGroupTag)
	if l > 0 {
		n += 2 + l + sovOidb(uint64(l))
	}
	if m.MsgGroupGeoInfo != nil {
		l = m.MsgGroupGeoInfo.Size()
		n += 2 + l + sovOidb(uint64(l))
	}
	if m.GroupClassExt != 0 {
		n += 2 + sovOidb(uint64(m.GroupClassExt))
	}
	l = len(m.IngGroupClassText)
	if l > 0 {
		n += 2 + l + sovOidb(uint64(l))
	}
	if m.AppPrivilegeFlag != 0 {
		n += 2 + sovOidb(uint64(m.AppPrivilegeFlag))
	}
	if m.AppPrivilegeMask != 0 {
		n += 2 + sovOidb(uint64(m.AppPrivilegeMask))
	}
	if m.StGroupExInfo != nil {
		l = m.StGroupExInfo.Size()
		n += 2 + l + sovOidb(uint64(l))
	}
	if m.GroupSecLevel != 0 {
		n += 2 + sovOidb(uint64(m.GroupSecLevel))
	}
	if m.GroupSecLevelInfo != 0 {
		n += 2 + sovOidb(uint64(m.GroupSecLevelInfo))
	}
	if m.SubscriptionUin != 0 {
		n += 2 + sovOidb(uint64(m.SubscriptionUin))
	}
	if m.AllowMemberInvite != 0 {
		n += 2 + sovOidb(uint64(m.AllowMemberInvite))
	}
	l = len(m.IngGroupQuestion)
	if l > 0 {
		n += 2 + l + sovOidb(uint64(l))
	}
	l = len(m.IngGroupAnswer)
	if l > 0 {
		n += 2 + l + sovOidb(uint64(l))
	}
	if m.GroupFlagext3 != 0 {
		n += 2 + sovOidb(uint64(m.GroupFlagext3))
	}
	if m.GroupFlagext3Mask != 0 {
		n += 2 + sovOidb(uint64(m.GroupFlagext3Mask))
	}
	if m.GroupOpenAppid != 0 {
		n += 2 + sovOidb(uint64(m.GroupOpenAppid))
	}
	if m.NoFingerOpenFlag != 0 {
		n += 2 + sovOidb(uint64(m.NoFingerOpenFlag))
	}
	if m.NoCodeFingerOpenFlag != 0 {
		n += 2 + sovOidb(uint64(m.NoCodeFingerOpenFlag))
	}
	if m.RootId != 0 {
		n += 2 + sovOidb(uint64(m.RootId))
	}
	if m.MsgLimitFrequency != 0 {
		n += 2 + sovOidb(uint64(m.MsgLimitFrequency))
	}
	return n
}

func (m *D89AGroupinfo_Val) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2 + sovOidb(uint64(m.Val))
	return n
}
func (m *D89AGroupNewGuidelinesInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BoolEnabled {
		n += 2
	}
	l = len(m.IngContent)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	return n
}

func (m *D89AGroupExInfoOnly) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TribeId != 0 {
		n += 1 + sovOidb(uint64(m.TribeId))
	}
	if m.MoneyForAddGroup != 0 {
		n += 1 + sovOidb(uint64(m.MoneyForAddGroup))
	}
	return n
}

func (m *D89AGroupGeoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CityId != 0 {
		n += 1 + sovOidb(uint64(m.CityId))
	}
	if m.Longtitude != 0 {
		n += 1 + sovOidb(uint64(m.Longtitude))
	}
	if m.Latitude != 0 {
		n += 1 + sovOidb(uint64(m.Latitude))
	}
	l = len(m.IngGeoContent)
	if l > 0 {
		n += 1 + l + sovOidb(uint64(l))
	}
	if m.PoiId != 0 {
		n += 1 + sovOidb(uint64(m.PoiId))
	}
	return n
}

func (m *DED3ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ToUin != 0 {
		n += 1 + sovOidb(uint64(m.ToUin))
	}
	if m.GroupCode != 0 {
		n += 1 + sovOidb(uint64(m.GroupCode))
	}
	if m.MsgSeq != 0 {
		n += 1 + sovOidb(uint64(m.MsgSeq))
	}
	if m.MsgRand != 0 {
		n += 1 + sovOidb(uint64(m.MsgRand))
	}
	if m.AioUin != 0 {
		n += 1 + sovOidb(uint64(m.AioUin))
	}
	return n
}

func sovOidb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOidb(x uint64) (n int) {
	return sovOidb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OIDBSSOPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OIDBSSOPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OIDBSSOPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			m.Command = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Command |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			m.ServiceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServiceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bodybuffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bodybuffer = append(m.Bodybuffer[:0], dAtA[iNdEx:postIndex]...)
			if m.Bodybuffer == nil {
				m.Bodybuffer = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D8A0RspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D8A0RspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D8A0RspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUint64GroupCode", wireType)
			}
			m.OptUint64GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUint64GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgKickResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgKickResult = append(m.MsgKickResult, &D8A0KickResult{})
			if err := m.MsgKickResult[len(m.MsgKickResult)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D8A0KickResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D8A0KickResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D8A0KickResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUint32Result", wireType)
			}
			m.OptUint32Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUint32Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUint64MemberUin", wireType)
			}
			m.OptUint64MemberUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUint64MemberUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D8A0KickMemberInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D8A0KickMemberInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D8A0KickMemberInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUint32Operate", wireType)
			}
			m.OptUint32Operate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUint32Operate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUint64MemberUin", wireType)
			}
			m.OptUint64MemberUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUint64MemberUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUint32Flag", wireType)
			}
			m.OptUint32Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUint32Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptBytesMsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptBytesMsg = append(m.OptBytesMsg[:0], dAtA[iNdEx:postIndex]...)
			if m.OptBytesMsg == nil {
				m.OptBytesMsg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D8A0ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D8A0ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D8A0ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUint64GroupCode", wireType)
			}
			m.OptUint64GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUint64GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgKickList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgKickList = append(m.MsgKickList, &D8A0KickMemberInfo{})
			if err := m.MsgKickList[len(m.MsgKickList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOidb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KickList = append(m.KickList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOidb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOidb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthOidb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.KickList) == 0 {
					m.KickList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOidb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KickList = append(m.KickList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KickList", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KickFlag", wireType)
			}
			m.KickFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KickFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KickMsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KickMsg = append(m.KickMsg[:0], dAtA[iNdEx:postIndex]...)
			if m.KickMsg == nil {
				m.KickMsg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D89AReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D89AReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D89AReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StGroupInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StGroupInfo == nil {
				m.StGroupInfo = &D89AGroupinfo{}
			}
			if err := m.StGroupInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalOperatorUin", wireType)
			}
			m.OriginalOperatorUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginalOperatorUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqGroupOpenAppid", wireType)
			}
			m.ReqGroupOpenAppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqGroupOpenAppid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D89AGroupinfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D89AGroupinfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D89AGroupinfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupExtAdmNum", wireType)
			}
			m.GroupExtAdmNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupExtAdmNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupName = append(m.IngGroupName[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupName == nil {
				m.IngGroupName = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupMemo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupMemo = append(m.IngGroupMemo[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupMemo == nil {
				m.IngGroupMemo = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupFingerMemo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupFingerMemo = append(m.IngGroupFingerMemo[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupFingerMemo == nil {
				m.IngGroupFingerMemo = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupAioSkinUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupAioSkinUrl = append(m.IngGroupAioSkinUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupAioSkinUrl == nil {
				m.IngGroupAioSkinUrl = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupBoardSkinUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupBoardSkinUrl = append(m.IngGroupBoardSkinUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupBoardSkinUrl == nil {
				m.IngGroupBoardSkinUrl = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupCoverSkinUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupCoverSkinUrl = append(m.IngGroupCoverSkinUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupCoverSkinUrl == nil {
				m.IngGroupCoverSkinUrl = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupGrade", wireType)
			}
			m.GroupGrade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupGrade |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveMemberNum", wireType)
			}
			m.ActiveMemberNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveMemberNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertificationType", wireType)
			}
			m.CertificationType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CertificationType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngCertificationText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngCertificationText = append(m.IngCertificationText[:0], dAtA[iNdEx:postIndex]...)
			if m.IngCertificationText == nil {
				m.IngCertificationText = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupRichFingerMemo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupRichFingerMemo = append(m.IngGroupRichFingerMemo[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupRichFingerMemo == nil {
				m.IngGroupRichFingerMemo = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StGroupNewguidelines", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StGroupNewguidelines == nil {
				m.StGroupNewguidelines = &D89AGroupNewGuidelinesInfo{}
			}
			if err := m.StGroupNewguidelines.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFace", wireType)
			}
			m.GroupFace = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupFace |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOption", wireType)
			}
			m.AddOption = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOption |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShutupTime = &D89AGroupinfo_Val{v}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupTypeFlag", wireType)
			}
			m.GroupTypeFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupTypeFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringGroupTag", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringGroupTag = append(m.StringGroupTag[:0], dAtA[iNdEx:postIndex]...)
			if m.StringGroupTag == nil {
				m.StringGroupTag = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgGroupGeoInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgGroupGeoInfo == nil {
				m.MsgGroupGeoInfo = &D89AGroupGeoInfo{}
			}
			if err := m.MsgGroupGeoInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupClassExt", wireType)
			}
			m.GroupClassExt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupClassExt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupClassText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupClassText = append(m.IngGroupClassText[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupClassText == nil {
				m.IngGroupClassText = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppPrivilegeFlag", wireType)
			}
			m.AppPrivilegeFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppPrivilegeFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppPrivilegeMask", wireType)
			}
			m.AppPrivilegeMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppPrivilegeMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StGroupExInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StGroupExInfo == nil {
				m.StGroupExInfo = &D89AGroupExInfoOnly{}
			}
			if err := m.StGroupExInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSecLevel", wireType)
			}
			m.GroupSecLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSecLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSecLevelInfo", wireType)
			}
			m.GroupSecLevelInfo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupSecLevelInfo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionUin", wireType)
			}
			m.SubscriptionUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubscriptionUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowMemberInvite", wireType)
			}
			m.AllowMemberInvite = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowMemberInvite |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupQuestion", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupQuestion = append(m.IngGroupQuestion[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupQuestion == nil {
				m.IngGroupQuestion = []byte{}
			}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGroupAnswer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGroupAnswer = append(m.IngGroupAnswer[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGroupAnswer == nil {
				m.IngGroupAnswer = []byte{}
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFlagext3", wireType)
			}
			m.GroupFlagext3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupFlagext3 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupFlagext3Mask", wireType)
			}
			m.GroupFlagext3Mask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupFlagext3Mask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupOpenAppid", wireType)
			}
			m.GroupOpenAppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupOpenAppid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFingerOpenFlag", wireType)
			}
			m.NoFingerOpenFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoFingerOpenFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCodeFingerOpenFlag", wireType)
			}
			m.NoCodeFingerOpenFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoCodeFingerOpenFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootId", wireType)
			}
			m.RootId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RootId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgLimitFrequency", wireType)
			}
			m.MsgLimitFrequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgLimitFrequency |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D89AGroupNewGuidelinesInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D89AGroupNewGuidelinesInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D89AGroupNewGuidelinesInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolEnabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngContent = append(m.IngContent[:0], dAtA[iNdEx:postIndex]...)
			if m.IngContent == nil {
				m.IngContent = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D89AGroupExInfoOnly) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D89AGroupExInfoOnly: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D89AGroupExInfoOnly: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TribeId", wireType)
			}
			m.TribeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TribeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoneyForAddGroup", wireType)
			}
			m.MoneyForAddGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MoneyForAddGroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D89AGroupGeoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D89AGroupGeoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D89AGroupGeoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityId", wireType)
			}
			m.CityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CityId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longtitude", wireType)
			}
			m.Longtitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Longtitude |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			m.Latitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Latitude |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngGeoContent", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthOidb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthOidb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngGeoContent = append(m.IngGeoContent[:0], dAtA[iNdEx:postIndex]...)
			if m.IngGeoContent == nil {
				m.IngGeoContent = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoiId", wireType)
			}
			m.PoiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoiId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DED3ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DED3ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DED3ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRand", wireType)
			}
			m.MsgRand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgRand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AioUin", wireType)
			}
			m.AioUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AioUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOidb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOidb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOidb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOidb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOidb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOidb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOidb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOidb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOidb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOidb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOidb = fmt.Errorf("proto: unexpected end of group")
)
