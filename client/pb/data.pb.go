// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pb/data.proto

package pb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DeviceInfo struct {
	Bootloader   string `protobuf:"bytes,1,opt,name=bootloader,proto3" json:"bootloader,omitempty"`
	ProcVersion  string `protobuf:"bytes,2,opt,name=procVersion,proto3" json:"procVersion,omitempty"`
	Codename     string `protobuf:"bytes,3,opt,name=codename,proto3" json:"codename,omitempty"`
	Incremental  string `protobuf:"bytes,4,opt,name=incremental,proto3" json:"incremental,omitempty"`
	Fingerprint  string `protobuf:"bytes,5,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
	BootId       string `protobuf:"bytes,6,opt,name=bootId,proto3" json:"bootId,omitempty"`
	AndroidId    string `protobuf:"bytes,7,opt,name=androidId,proto3" json:"androidId,omitempty"`
	BaseBand     string `protobuf:"bytes,8,opt,name=baseBand,proto3" json:"baseBand,omitempty"`
	InnerVersion string `protobuf:"bytes,9,opt,name=innerVersion,proto3" json:"innerVersion,omitempty"`
}

func (m *DeviceInfo) Reset()         { *m = DeviceInfo{} }
func (m *DeviceInfo) String() string { return proto.CompactTextString(m) }
func (*DeviceInfo) ProtoMessage()    {}
func (*DeviceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{0}
}
func (m *DeviceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceInfo.Merge(m, src)
}
func (m *DeviceInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeviceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceInfo proto.InternalMessageInfo

func (m *DeviceInfo) GetBootloader() string {
	if m != nil {
		return m.Bootloader
	}
	return ""
}

func (m *DeviceInfo) GetProcVersion() string {
	if m != nil {
		return m.ProcVersion
	}
	return ""
}

func (m *DeviceInfo) GetCodename() string {
	if m != nil {
		return m.Codename
	}
	return ""
}

func (m *DeviceInfo) GetIncremental() string {
	if m != nil {
		return m.Incremental
	}
	return ""
}

func (m *DeviceInfo) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *DeviceInfo) GetBootId() string {
	if m != nil {
		return m.BootId
	}
	return ""
}

func (m *DeviceInfo) GetAndroidId() string {
	if m != nil {
		return m.AndroidId
	}
	return ""
}

func (m *DeviceInfo) GetBaseBand() string {
	if m != nil {
		return m.BaseBand
	}
	return ""
}

func (m *DeviceInfo) GetInnerVersion() string {
	if m != nil {
		return m.InnerVersion
	}
	return ""
}

type RequestBody struct {
	RptConfigList []*ConfigSeq `protobuf:"bytes,1,rep,name=rpt_config_list,json=rptConfigList,proto3" json:"rpt_config_list,omitempty"`
}

func (m *RequestBody) Reset()         { *m = RequestBody{} }
func (m *RequestBody) String() string { return proto.CompactTextString(m) }
func (*RequestBody) ProtoMessage()    {}
func (*RequestBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{1}
}
func (m *RequestBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBody.Merge(m, src)
}
func (m *RequestBody) XXX_Size() int {
	return m.Size()
}
func (m *RequestBody) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBody.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBody proto.InternalMessageInfo

func (m *RequestBody) GetRptConfigList() []*ConfigSeq {
	if m != nil {
		return m.RptConfigList
	}
	return nil
}

type ConfigSeq struct {
	Type    int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Version int32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ConfigSeq) Reset()         { *m = ConfigSeq{} }
func (m *ConfigSeq) String() string { return proto.CompactTextString(m) }
func (*ConfigSeq) ProtoMessage()    {}
func (*ConfigSeq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{2}
}
func (m *ConfigSeq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigSeq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigSeq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigSeq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigSeq.Merge(m, src)
}
func (m *ConfigSeq) XXX_Size() int {
	return m.Size()
}
func (m *ConfigSeq) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigSeq.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigSeq proto.InternalMessageInfo

func (m *ConfigSeq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ConfigSeq) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type D50ReqBody struct {
	Appid                   int64   `protobuf:"varint,1,opt,name=appid,proto3" json:"appid,omitempty"`
	MaxPkgSize              int32   `protobuf:"varint,2,opt,name=maxPkgSize,proto3" json:"maxPkgSize,omitempty"`
	StartTime               int32   `protobuf:"varint,3,opt,name=startTime,proto3" json:"startTime,omitempty"`
	StartIndex              int32   `protobuf:"varint,4,opt,name=startIndex,proto3" json:"startIndex,omitempty"`
	ReqNum                  int32   `protobuf:"varint,5,opt,name=reqNum,proto3" json:"reqNum,omitempty"`
	UinList                 []int64 `protobuf:"varint,6,rep,packed,name=uinList,proto3" json:"uinList,omitempty"`
	ReqMusicSwitch          int32   `protobuf:"varint,91001,opt,name=reqMusicSwitch,proto3" json:"reqMusicSwitch,omitempty"`
	ReqMutualmarkAlienation int32   `protobuf:"varint,101001,opt,name=reqMutualmarkAlienation,proto3" json:"reqMutualmarkAlienation,omitempty"`
	ReqMutualmarkScore      int32   `protobuf:"varint,141001,opt,name=reqMutualmarkScore,proto3" json:"reqMutualmarkScore,omitempty"`
	ReqKsingSwitch          int32   `protobuf:"varint,151001,opt,name=reqKsingSwitch,proto3" json:"reqKsingSwitch,omitempty"`
	ReqMutualmarkLbsshare   int32   `protobuf:"varint,181001,opt,name=reqMutualmarkLbsshare,proto3" json:"reqMutualmarkLbsshare,omitempty"`
}

func (m *D50ReqBody) Reset()         { *m = D50ReqBody{} }
func (m *D50ReqBody) String() string { return proto.CompactTextString(m) }
func (*D50ReqBody) ProtoMessage()    {}
func (*D50ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{3}
}
func (m *D50ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D50ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D50ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D50ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D50ReqBody.Merge(m, src)
}
func (m *D50ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *D50ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D50ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_D50ReqBody proto.InternalMessageInfo

func (m *D50ReqBody) GetAppid() int64 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *D50ReqBody) GetMaxPkgSize() int32 {
	if m != nil {
		return m.MaxPkgSize
	}
	return 0
}

func (m *D50ReqBody) GetStartTime() int32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *D50ReqBody) GetStartIndex() int32 {
	if m != nil {
		return m.StartIndex
	}
	return 0
}

func (m *D50ReqBody) GetReqNum() int32 {
	if m != nil {
		return m.ReqNum
	}
	return 0
}

func (m *D50ReqBody) GetUinList() []int64 {
	if m != nil {
		return m.UinList
	}
	return nil
}

func (m *D50ReqBody) GetReqMusicSwitch() int32 {
	if m != nil {
		return m.ReqMusicSwitch
	}
	return 0
}

func (m *D50ReqBody) GetReqMutualmarkAlienation() int32 {
	if m != nil {
		return m.ReqMutualmarkAlienation
	}
	return 0
}

func (m *D50ReqBody) GetReqMutualmarkScore() int32 {
	if m != nil {
		return m.ReqMutualmarkScore
	}
	return 0
}

func (m *D50ReqBody) GetReqKsingSwitch() int32 {
	if m != nil {
		return m.ReqKsingSwitch
	}
	return 0
}

func (m *D50ReqBody) GetReqMutualmarkLbsshare() int32 {
	if m != nil {
		return m.ReqMutualmarkLbsshare
	}
	return 0
}

type D388ReqBody struct {
	NetType        int32           `protobuf:"varint,1,opt,name=netType,proto3" json:"netType,omitempty"`
	Subcmd         int32           `protobuf:"varint,2,opt,name=subcmd,proto3" json:"subcmd,omitempty"`
	MsgTryUpImgReq []*TryUpImgReq  `protobuf:"bytes,3,rep,name=msgTryUpImgReq,proto3" json:"msgTryUpImgReq,omitempty"`
	MsgTryUpPttReq []*TryUpPttReq  `protobuf:"bytes,5,rep,name=msgTryUpPttReq,proto3" json:"msgTryUpPttReq,omitempty"`
	MsgGetPttReq   []*GetPttUrlReq `protobuf:"bytes,6,rep,name=msgGetPttReq,proto3" json:"msgGetPttReq,omitempty"`
	CommandId      int32           `protobuf:"varint,7,opt,name=commandId,proto3" json:"commandId,omitempty"`
	Extension      []byte          `protobuf:"bytes,1001,opt,name=extension,proto3" json:"extension,omitempty"`
}

func (m *D388ReqBody) Reset()         { *m = D388ReqBody{} }
func (m *D388ReqBody) String() string { return proto.CompactTextString(m) }
func (*D388ReqBody) ProtoMessage()    {}
func (*D388ReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{4}
}
func (m *D388ReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D388ReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D388ReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D388ReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D388ReqBody.Merge(m, src)
}
func (m *D388ReqBody) XXX_Size() int {
	return m.Size()
}
func (m *D388ReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D388ReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_D388ReqBody proto.InternalMessageInfo

func (m *D388ReqBody) GetNetType() int32 {
	if m != nil {
		return m.NetType
	}
	return 0
}

func (m *D388ReqBody) GetSubcmd() int32 {
	if m != nil {
		return m.Subcmd
	}
	return 0
}

func (m *D388ReqBody) GetMsgTryUpImgReq() []*TryUpImgReq {
	if m != nil {
		return m.MsgTryUpImgReq
	}
	return nil
}

func (m *D388ReqBody) GetMsgTryUpPttReq() []*TryUpPttReq {
	if m != nil {
		return m.MsgTryUpPttReq
	}
	return nil
}

func (m *D388ReqBody) GetMsgGetPttReq() []*GetPttUrlReq {
	if m != nil {
		return m.MsgGetPttReq
	}
	return nil
}

func (m *D388ReqBody) GetCommandId() int32 {
	if m != nil {
		return m.CommandId
	}
	return 0
}

func (m *D388ReqBody) GetExtension() []byte {
	if m != nil {
		return m.Extension
	}
	return nil
}

type D388RespBody struct {
	ClientIp        int32           `protobuf:"varint,1,opt,name=clientIp,proto3" json:"clientIp,omitempty"`
	SubCmd          int32           `protobuf:"varint,2,opt,name=subCmd,proto3" json:"subCmd,omitempty"`
	MsgTryUpImgRsp  []*TryUpImgResp `protobuf:"bytes,3,rep,name=msgTryUpImgRsp,proto3" json:"msgTryUpImgRsp,omitempty"`
	MsgTryUpPttRsp  []*TryUpPttResp `protobuf:"bytes,5,rep,name=msgTryUpPttRsp,proto3" json:"msgTryUpPttRsp,omitempty"`
	MsgGetPttUrlRsp []*GetPttUrlRsp `protobuf:"bytes,6,rep,name=msgGetPttUrlRsp,proto3" json:"msgGetPttUrlRsp,omitempty"`
}

func (m *D388RespBody) Reset()         { *m = D388RespBody{} }
func (m *D388RespBody) String() string { return proto.CompactTextString(m) }
func (*D388RespBody) ProtoMessage()    {}
func (*D388RespBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{5}
}
func (m *D388RespBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *D388RespBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_D388RespBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *D388RespBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_D388RespBody.Merge(m, src)
}
func (m *D388RespBody) XXX_Size() int {
	return m.Size()
}
func (m *D388RespBody) XXX_DiscardUnknown() {
	xxx_messageInfo_D388RespBody.DiscardUnknown(m)
}

var xxx_messageInfo_D388RespBody proto.InternalMessageInfo

func (m *D388RespBody) GetClientIp() int32 {
	if m != nil {
		return m.ClientIp
	}
	return 0
}

func (m *D388RespBody) GetSubCmd() int32 {
	if m != nil {
		return m.SubCmd
	}
	return 0
}

func (m *D388RespBody) GetMsgTryUpImgRsp() []*TryUpImgResp {
	if m != nil {
		return m.MsgTryUpImgRsp
	}
	return nil
}

func (m *D388RespBody) GetMsgTryUpPttRsp() []*TryUpPttResp {
	if m != nil {
		return m.MsgTryUpPttRsp
	}
	return nil
}

func (m *D388RespBody) GetMsgGetPttUrlRsp() []*GetPttUrlRsp {
	if m != nil {
		return m.MsgGetPttUrlRsp
	}
	return nil
}

type GetPttUrlReq struct {
	GroupCode       int64  `protobuf:"varint,1,opt,name=groupCode,proto3" json:"groupCode,omitempty"`
	DstUin          int64  `protobuf:"varint,2,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	FileId          int64  `protobuf:"varint,3,opt,name=fileId,proto3" json:"fileId,omitempty"`
	FileMd5         []byte `protobuf:"bytes,4,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	ReqTerm         int32  `protobuf:"varint,5,opt,name=reqTerm,proto3" json:"reqTerm,omitempty"`
	ReqPlatformType int32  `protobuf:"varint,6,opt,name=reqPlatformType,proto3" json:"reqPlatformType,omitempty"`
	InnerIp         int32  `protobuf:"varint,7,opt,name=innerIp,proto3" json:"innerIp,omitempty"`
	BuType          int32  `protobuf:"varint,8,opt,name=buType,proto3" json:"buType,omitempty"`
	BuildVer        []byte `protobuf:"bytes,9,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	//int64 fileId = 10;
	FileKey         []byte `protobuf:"bytes,11,opt,name=fileKey,proto3" json:"fileKey,omitempty"`
	Codec           int32  `protobuf:"varint,12,opt,name=codec,proto3" json:"codec,omitempty"`
	BuId            int32  `protobuf:"varint,13,opt,name=buId,proto3" json:"buId,omitempty"`
	ReqTransferType int32  `protobuf:"varint,14,opt,name=reqTransferType,proto3" json:"reqTransferType,omitempty"`
	IsAuto          int32  `protobuf:"varint,15,opt,name=isAuto,proto3" json:"isAuto,omitempty"`
}

func (m *GetPttUrlReq) Reset()         { *m = GetPttUrlReq{} }
func (m *GetPttUrlReq) String() string { return proto.CompactTextString(m) }
func (*GetPttUrlReq) ProtoMessage()    {}
func (*GetPttUrlReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{6}
}
func (m *GetPttUrlReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPttUrlReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPttUrlReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPttUrlReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPttUrlReq.Merge(m, src)
}
func (m *GetPttUrlReq) XXX_Size() int {
	return m.Size()
}
func (m *GetPttUrlReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPttUrlReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetPttUrlReq proto.InternalMessageInfo

func (m *GetPttUrlReq) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GetPttUrlReq) GetDstUin() int64 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *GetPttUrlReq) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *GetPttUrlReq) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *GetPttUrlReq) GetReqTerm() int32 {
	if m != nil {
		return m.ReqTerm
	}
	return 0
}

func (m *GetPttUrlReq) GetReqPlatformType() int32 {
	if m != nil {
		return m.ReqPlatformType
	}
	return 0
}

func (m *GetPttUrlReq) GetInnerIp() int32 {
	if m != nil {
		return m.InnerIp
	}
	return 0
}

func (m *GetPttUrlReq) GetBuType() int32 {
	if m != nil {
		return m.BuType
	}
	return 0
}

func (m *GetPttUrlReq) GetBuildVer() []byte {
	if m != nil {
		return m.BuildVer
	}
	return nil
}

func (m *GetPttUrlReq) GetFileKey() []byte {
	if m != nil {
		return m.FileKey
	}
	return nil
}

func (m *GetPttUrlReq) GetCodec() int32 {
	if m != nil {
		return m.Codec
	}
	return 0
}

func (m *GetPttUrlReq) GetBuId() int32 {
	if m != nil {
		return m.BuId
	}
	return 0
}

func (m *GetPttUrlReq) GetReqTransferType() int32 {
	if m != nil {
		return m.ReqTransferType
	}
	return 0
}

func (m *GetPttUrlReq) GetIsAuto() int32 {
	if m != nil {
		return m.IsAuto
	}
	return 0
}

type GetPttUrlRsp struct {
	FileId         int64   `protobuf:"varint,1,opt,name=fileId,proto3" json:"fileId,omitempty"`
	FileMd5        []byte  `protobuf:"bytes,2,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	Result         int32   `protobuf:"varint,3,opt,name=result,proto3" json:"result,omitempty"`
	FailMsg        []byte  `protobuf:"bytes,4,opt,name=failMsg,proto3" json:"failMsg,omitempty"`
	BytesDownUrl   []byte  `protobuf:"bytes,5,opt,name=bytesDownUrl,proto3" json:"bytesDownUrl,omitempty"`
	Uint32DownIp   []int32 `protobuf:"varint,6,rep,packed,name=uint32DownIp,proto3" json:"uint32DownIp,omitempty"`
	Uint32DownPort []int32 `protobuf:"varint,7,rep,packed,name=uint32DownPort,proto3" json:"uint32DownPort,omitempty"`
	DownDomain     []byte  `protobuf:"bytes,8,opt,name=downDomain,proto3" json:"downDomain,omitempty"`
	DownPara       []byte  `protobuf:"bytes,9,opt,name=downPara,proto3" json:"downPara,omitempty"`
	//int64 fileId = 10;
	TransferType int32 `protobuf:"varint,11,opt,name=transferType,proto3" json:"transferType,omitempty"`
	AllowRetry   int32 `protobuf:"varint,12,opt,name=allowRetry,proto3" json:"allowRetry,omitempty"`
	//repeated IPv6Info msgDownIp6 = 26;
	ClientIp6 []byte `protobuf:"bytes,27,opt,name=clientIp6,proto3" json:"clientIp6,omitempty"`
	StrDomain string `protobuf:"bytes,28,opt,name=strDomain,proto3" json:"strDomain,omitempty"`
}

func (m *GetPttUrlRsp) Reset()         { *m = GetPttUrlRsp{} }
func (m *GetPttUrlRsp) String() string { return proto.CompactTextString(m) }
func (*GetPttUrlRsp) ProtoMessage()    {}
func (*GetPttUrlRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{7}
}
func (m *GetPttUrlRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPttUrlRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPttUrlRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPttUrlRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPttUrlRsp.Merge(m, src)
}
func (m *GetPttUrlRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetPttUrlRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPttUrlRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetPttUrlRsp proto.InternalMessageInfo

func (m *GetPttUrlRsp) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *GetPttUrlRsp) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *GetPttUrlRsp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *GetPttUrlRsp) GetFailMsg() []byte {
	if m != nil {
		return m.FailMsg
	}
	return nil
}

func (m *GetPttUrlRsp) GetBytesDownUrl() []byte {
	if m != nil {
		return m.BytesDownUrl
	}
	return nil
}

func (m *GetPttUrlRsp) GetUint32DownIp() []int32 {
	if m != nil {
		return m.Uint32DownIp
	}
	return nil
}

func (m *GetPttUrlRsp) GetUint32DownPort() []int32 {
	if m != nil {
		return m.Uint32DownPort
	}
	return nil
}

func (m *GetPttUrlRsp) GetDownDomain() []byte {
	if m != nil {
		return m.DownDomain
	}
	return nil
}

func (m *GetPttUrlRsp) GetDownPara() []byte {
	if m != nil {
		return m.DownPara
	}
	return nil
}

func (m *GetPttUrlRsp) GetTransferType() int32 {
	if m != nil {
		return m.TransferType
	}
	return 0
}

func (m *GetPttUrlRsp) GetAllowRetry() int32 {
	if m != nil {
		return m.AllowRetry
	}
	return 0
}

func (m *GetPttUrlRsp) GetClientIp6() []byte {
	if m != nil {
		return m.ClientIp6
	}
	return nil
}

func (m *GetPttUrlRsp) GetStrDomain() string {
	if m != nil {
		return m.StrDomain
	}
	return ""
}

type ReqDataHighwayHead struct {
	MsgBasehead   *DataHighwayHead `protobuf:"bytes,1,opt,name=msgBasehead,proto3" json:"msgBasehead,omitempty"`
	MsgSeghead    *SegHead         `protobuf:"bytes,2,opt,name=msgSeghead,proto3" json:"msgSeghead,omitempty"`
	ReqExtendinfo []byte           `protobuf:"bytes,3,opt,name=reqExtendinfo,proto3" json:"reqExtendinfo,omitempty"`
	Timestamp     int64            `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ReqDataHighwayHead) Reset()         { *m = ReqDataHighwayHead{} }
func (m *ReqDataHighwayHead) String() string { return proto.CompactTextString(m) }
func (*ReqDataHighwayHead) ProtoMessage()    {}
func (*ReqDataHighwayHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{8}
}
func (m *ReqDataHighwayHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReqDataHighwayHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReqDataHighwayHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReqDataHighwayHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReqDataHighwayHead.Merge(m, src)
}
func (m *ReqDataHighwayHead) XXX_Size() int {
	return m.Size()
}
func (m *ReqDataHighwayHead) XXX_DiscardUnknown() {
	xxx_messageInfo_ReqDataHighwayHead.DiscardUnknown(m)
}

var xxx_messageInfo_ReqDataHighwayHead proto.InternalMessageInfo

func (m *ReqDataHighwayHead) GetMsgBasehead() *DataHighwayHead {
	if m != nil {
		return m.MsgBasehead
	}
	return nil
}

func (m *ReqDataHighwayHead) GetMsgSeghead() *SegHead {
	if m != nil {
		return m.MsgSeghead
	}
	return nil
}

func (m *ReqDataHighwayHead) GetReqExtendinfo() []byte {
	if m != nil {
		return m.ReqExtendinfo
	}
	return nil
}

func (m *ReqDataHighwayHead) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type RspDataHighwayHead struct {
	MsgBasehead   *DataHighwayHead `protobuf:"bytes,1,opt,name=msgBasehead,proto3" json:"msgBasehead,omitempty"`
	MsgSeghead    *SegHead         `protobuf:"bytes,2,opt,name=msgSeghead,proto3" json:"msgSeghead,omitempty"`
	ErrorCode     int32            `protobuf:"varint,3,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
	AllowRetry    int32            `protobuf:"varint,4,opt,name=allowRetry,proto3" json:"allowRetry,omitempty"`
	Cachecost     int32            `protobuf:"varint,5,opt,name=cachecost,proto3" json:"cachecost,omitempty"`
	Htcost        int32            `protobuf:"varint,6,opt,name=htcost,proto3" json:"htcost,omitempty"`
	RspExtendinfo []byte           `protobuf:"bytes,7,opt,name=rspExtendinfo,proto3" json:"rspExtendinfo,omitempty"`
	Timestamp     int64            `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Range         int64            `protobuf:"varint,9,opt,name=range,proto3" json:"range,omitempty"`
	IsReset       int32            `protobuf:"varint,10,opt,name=isReset,proto3" json:"isReset,omitempty"`
}

func (m *RspDataHighwayHead) Reset()         { *m = RspDataHighwayHead{} }
func (m *RspDataHighwayHead) String() string { return proto.CompactTextString(m) }
func (*RspDataHighwayHead) ProtoMessage()    {}
func (*RspDataHighwayHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{9}
}
func (m *RspDataHighwayHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspDataHighwayHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspDataHighwayHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspDataHighwayHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspDataHighwayHead.Merge(m, src)
}
func (m *RspDataHighwayHead) XXX_Size() int {
	return m.Size()
}
func (m *RspDataHighwayHead) XXX_DiscardUnknown() {
	xxx_messageInfo_RspDataHighwayHead.DiscardUnknown(m)
}

var xxx_messageInfo_RspDataHighwayHead proto.InternalMessageInfo

func (m *RspDataHighwayHead) GetMsgBasehead() *DataHighwayHead {
	if m != nil {
		return m.MsgBasehead
	}
	return nil
}

func (m *RspDataHighwayHead) GetMsgSeghead() *SegHead {
	if m != nil {
		return m.MsgSeghead
	}
	return nil
}

func (m *RspDataHighwayHead) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *RspDataHighwayHead) GetAllowRetry() int32 {
	if m != nil {
		return m.AllowRetry
	}
	return 0
}

func (m *RspDataHighwayHead) GetCachecost() int32 {
	if m != nil {
		return m.Cachecost
	}
	return 0
}

func (m *RspDataHighwayHead) GetHtcost() int32 {
	if m != nil {
		return m.Htcost
	}
	return 0
}

func (m *RspDataHighwayHead) GetRspExtendinfo() []byte {
	if m != nil {
		return m.RspExtendinfo
	}
	return nil
}

func (m *RspDataHighwayHead) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RspDataHighwayHead) GetRange() int64 {
	if m != nil {
		return m.Range
	}
	return 0
}

func (m *RspDataHighwayHead) GetIsReset() int32 {
	if m != nil {
		return m.IsReset
	}
	return 0
}

type DataHighwayHead struct {
	Version    int32  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Uin        string `protobuf:"bytes,2,opt,name=uin,proto3" json:"uin,omitempty"`
	Command    string `protobuf:"bytes,3,opt,name=command,proto3" json:"command,omitempty"`
	Seq        int32  `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
	RetryTimes int32  `protobuf:"varint,5,opt,name=retryTimes,proto3" json:"retryTimes,omitempty"`
	Appid      int32  `protobuf:"varint,6,opt,name=appid,proto3" json:"appid,omitempty"`
	Dataflag   int32  `protobuf:"varint,7,opt,name=dataflag,proto3" json:"dataflag,omitempty"`
	CommandId  int32  `protobuf:"varint,8,opt,name=commandId,proto3" json:"commandId,omitempty"`
	BuildVer   string `protobuf:"bytes,9,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	LocaleId   int32  `protobuf:"varint,10,opt,name=localeId,proto3" json:"localeId,omitempty"`
}

func (m *DataHighwayHead) Reset()         { *m = DataHighwayHead{} }
func (m *DataHighwayHead) String() string { return proto.CompactTextString(m) }
func (*DataHighwayHead) ProtoMessage()    {}
func (*DataHighwayHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{10}
}
func (m *DataHighwayHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataHighwayHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataHighwayHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataHighwayHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataHighwayHead.Merge(m, src)
}
func (m *DataHighwayHead) XXX_Size() int {
	return m.Size()
}
func (m *DataHighwayHead) XXX_DiscardUnknown() {
	xxx_messageInfo_DataHighwayHead.DiscardUnknown(m)
}

var xxx_messageInfo_DataHighwayHead proto.InternalMessageInfo

func (m *DataHighwayHead) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DataHighwayHead) GetUin() string {
	if m != nil {
		return m.Uin
	}
	return ""
}

func (m *DataHighwayHead) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *DataHighwayHead) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *DataHighwayHead) GetRetryTimes() int32 {
	if m != nil {
		return m.RetryTimes
	}
	return 0
}

func (m *DataHighwayHead) GetAppid() int32 {
	if m != nil {
		return m.Appid
	}
	return 0
}

func (m *DataHighwayHead) GetDataflag() int32 {
	if m != nil {
		return m.Dataflag
	}
	return 0
}

func (m *DataHighwayHead) GetCommandId() int32 {
	if m != nil {
		return m.CommandId
	}
	return 0
}

func (m *DataHighwayHead) GetBuildVer() string {
	if m != nil {
		return m.BuildVer
	}
	return ""
}

func (m *DataHighwayHead) GetLocaleId() int32 {
	if m != nil {
		return m.LocaleId
	}
	return 0
}

type SegHead struct {
	Serviceid     int32  `protobuf:"varint,1,opt,name=serviceid,proto3" json:"serviceid,omitempty"`
	Filesize      int64  `protobuf:"varint,2,opt,name=filesize,proto3" json:"filesize,omitempty"`
	Dataoffset    int64  `protobuf:"varint,3,opt,name=dataoffset,proto3" json:"dataoffset,omitempty"`
	Datalength    int32  `protobuf:"varint,4,opt,name=datalength,proto3" json:"datalength,omitempty"`
	Rtcode        int32  `protobuf:"varint,5,opt,name=rtcode,proto3" json:"rtcode,omitempty"`
	Serviceticket []byte `protobuf:"bytes,6,opt,name=serviceticket,proto3" json:"serviceticket,omitempty"`
	Flag          int32  `protobuf:"varint,7,opt,name=flag,proto3" json:"flag,omitempty"`
	Md5           []byte `protobuf:"bytes,8,opt,name=md5,proto3" json:"md5,omitempty"`
	FileMd5       []byte `protobuf:"bytes,9,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	CacheAddr     int32  `protobuf:"varint,10,opt,name=cacheAddr,proto3" json:"cacheAddr,omitempty"`
	QueryTimes    int32  `protobuf:"varint,11,opt,name=queryTimes,proto3" json:"queryTimes,omitempty"`
	UpdateCacheip int32  `protobuf:"varint,12,opt,name=updateCacheip,proto3" json:"updateCacheip,omitempty"`
}

func (m *SegHead) Reset()         { *m = SegHead{} }
func (m *SegHead) String() string { return proto.CompactTextString(m) }
func (*SegHead) ProtoMessage()    {}
func (*SegHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{11}
}
func (m *SegHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SegHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SegHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SegHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SegHead.Merge(m, src)
}
func (m *SegHead) XXX_Size() int {
	return m.Size()
}
func (m *SegHead) XXX_DiscardUnknown() {
	xxx_messageInfo_SegHead.DiscardUnknown(m)
}

var xxx_messageInfo_SegHead proto.InternalMessageInfo

func (m *SegHead) GetServiceid() int32 {
	if m != nil {
		return m.Serviceid
	}
	return 0
}

func (m *SegHead) GetFilesize() int64 {
	if m != nil {
		return m.Filesize
	}
	return 0
}

func (m *SegHead) GetDataoffset() int64 {
	if m != nil {
		return m.Dataoffset
	}
	return 0
}

func (m *SegHead) GetDatalength() int32 {
	if m != nil {
		return m.Datalength
	}
	return 0
}

func (m *SegHead) GetRtcode() int32 {
	if m != nil {
		return m.Rtcode
	}
	return 0
}

func (m *SegHead) GetServiceticket() []byte {
	if m != nil {
		return m.Serviceticket
	}
	return nil
}

func (m *SegHead) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *SegHead) GetMd5() []byte {
	if m != nil {
		return m.Md5
	}
	return nil
}

func (m *SegHead) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *SegHead) GetCacheAddr() int32 {
	if m != nil {
		return m.CacheAddr
	}
	return 0
}

func (m *SegHead) GetQueryTimes() int32 {
	if m != nil {
		return m.QueryTimes
	}
	return 0
}

func (m *SegHead) GetUpdateCacheip() int32 {
	if m != nil {
		return m.UpdateCacheip
	}
	return 0
}

type TryUpImgReq struct {
	GroupCode    int64  `protobuf:"varint,1,opt,name=groupCode,proto3" json:"groupCode,omitempty"`
	SrcUin       int64  `protobuf:"varint,2,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
	FileId       int64  `protobuf:"varint,3,opt,name=fileId,proto3" json:"fileId,omitempty"`
	FileMd5      []byte `protobuf:"bytes,4,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	FileSize     int64  `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName     string `protobuf:"bytes,6,opt,name=fileName,proto3" json:"fileName,omitempty"`
	SrcTerm      int32  `protobuf:"varint,7,opt,name=srcTerm,proto3" json:"srcTerm,omitempty"`
	PlatformType int32  `protobuf:"varint,8,opt,name=platformType,proto3" json:"platformType,omitempty"`
	BuType       int32  `protobuf:"varint,9,opt,name=buType,proto3" json:"buType,omitempty"`
	PicWidth     int32  `protobuf:"varint,10,opt,name=picWidth,proto3" json:"picWidth,omitempty"`
	PicHeight    int32  `protobuf:"varint,11,opt,name=picHeight,proto3" json:"picHeight,omitempty"`
	PicType      int32  `protobuf:"varint,12,opt,name=picType,proto3" json:"picType,omitempty"`
	BuildVer     string `protobuf:"bytes,13,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	InnerIp      int32  `protobuf:"varint,14,opt,name=innerIp,proto3" json:"innerIp,omitempty"`
	AppPicType   int32  `protobuf:"varint,15,opt,name=appPicType,proto3" json:"appPicType,omitempty"`
	OriginalPic  int32  `protobuf:"varint,16,opt,name=originalPic,proto3" json:"originalPic,omitempty"`
	FileIndex    []byte `protobuf:"bytes,17,opt,name=fileIndex,proto3" json:"fileIndex,omitempty"`
	DstUin       int64  `protobuf:"varint,18,opt,name=dstUin,proto3" json:"dstUin,omitempty"`
	SrvUpload    int32  `protobuf:"varint,19,opt,name=srvUpload,proto3" json:"srvUpload,omitempty"`
	TransferUrl  []byte `protobuf:"bytes,20,opt,name=transferUrl,proto3" json:"transferUrl,omitempty"`
}

func (m *TryUpImgReq) Reset()         { *m = TryUpImgReq{} }
func (m *TryUpImgReq) String() string { return proto.CompactTextString(m) }
func (*TryUpImgReq) ProtoMessage()    {}
func (*TryUpImgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{12}
}
func (m *TryUpImgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TryUpImgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TryUpImgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TryUpImgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TryUpImgReq.Merge(m, src)
}
func (m *TryUpImgReq) XXX_Size() int {
	return m.Size()
}
func (m *TryUpImgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TryUpImgReq.DiscardUnknown(m)
}

var xxx_messageInfo_TryUpImgReq proto.InternalMessageInfo

func (m *TryUpImgReq) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *TryUpImgReq) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *TryUpImgReq) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *TryUpImgReq) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *TryUpImgReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *TryUpImgReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *TryUpImgReq) GetSrcTerm() int32 {
	if m != nil {
		return m.SrcTerm
	}
	return 0
}

func (m *TryUpImgReq) GetPlatformType() int32 {
	if m != nil {
		return m.PlatformType
	}
	return 0
}

func (m *TryUpImgReq) GetBuType() int32 {
	if m != nil {
		return m.BuType
	}
	return 0
}

func (m *TryUpImgReq) GetPicWidth() int32 {
	if m != nil {
		return m.PicWidth
	}
	return 0
}

func (m *TryUpImgReq) GetPicHeight() int32 {
	if m != nil {
		return m.PicHeight
	}
	return 0
}

func (m *TryUpImgReq) GetPicType() int32 {
	if m != nil {
		return m.PicType
	}
	return 0
}

func (m *TryUpImgReq) GetBuildVer() string {
	if m != nil {
		return m.BuildVer
	}
	return ""
}

func (m *TryUpImgReq) GetInnerIp() int32 {
	if m != nil {
		return m.InnerIp
	}
	return 0
}

func (m *TryUpImgReq) GetAppPicType() int32 {
	if m != nil {
		return m.AppPicType
	}
	return 0
}

func (m *TryUpImgReq) GetOriginalPic() int32 {
	if m != nil {
		return m.OriginalPic
	}
	return 0
}

func (m *TryUpImgReq) GetFileIndex() []byte {
	if m != nil {
		return m.FileIndex
	}
	return nil
}

func (m *TryUpImgReq) GetDstUin() int64 {
	if m != nil {
		return m.DstUin
	}
	return 0
}

func (m *TryUpImgReq) GetSrvUpload() int32 {
	if m != nil {
		return m.SrvUpload
	}
	return 0
}

func (m *TryUpImgReq) GetTransferUrl() []byte {
	if m != nil {
		return m.TransferUrl
	}
	return nil
}

type TryUpImgResp struct {
	FileId       int64    `protobuf:"varint,1,opt,name=fileId,proto3" json:"fileId,omitempty"`
	Result       int32    `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	FailMsg      string   `protobuf:"bytes,3,opt,name=failMsg,proto3" json:"failMsg,omitempty"`
	BoolFileExit bool     `protobuf:"varint,4,opt,name=boolFileExit,proto3" json:"boolFileExit,omitempty"`
	MsgImgInfo   *ImgInfo `protobuf:"bytes,5,opt,name=msgImgInfo,proto3" json:"msgImgInfo,omitempty"`
	Uint32UpIp   []int32  `protobuf:"varint,6,rep,packed,name=uint32UpIp,proto3" json:"uint32UpIp,omitempty"`
	Uint32UpPort []int32  `protobuf:"varint,7,rep,packed,name=uint32UpPort,proto3" json:"uint32UpPort,omitempty"`
	UpUkey       []byte   `protobuf:"bytes,8,opt,name=upUkey,proto3" json:"upUkey,omitempty"`
	Fid          int64    `protobuf:"varint,9,opt,name=fid,proto3" json:"fid,omitempty"`
}

func (m *TryUpImgResp) Reset()         { *m = TryUpImgResp{} }
func (m *TryUpImgResp) String() string { return proto.CompactTextString(m) }
func (*TryUpImgResp) ProtoMessage()    {}
func (*TryUpImgResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{13}
}
func (m *TryUpImgResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TryUpImgResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TryUpImgResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TryUpImgResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TryUpImgResp.Merge(m, src)
}
func (m *TryUpImgResp) XXX_Size() int {
	return m.Size()
}
func (m *TryUpImgResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TryUpImgResp.DiscardUnknown(m)
}

var xxx_messageInfo_TryUpImgResp proto.InternalMessageInfo

func (m *TryUpImgResp) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *TryUpImgResp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *TryUpImgResp) GetFailMsg() string {
	if m != nil {
		return m.FailMsg
	}
	return ""
}

func (m *TryUpImgResp) GetBoolFileExit() bool {
	if m != nil {
		return m.BoolFileExit
	}
	return false
}

func (m *TryUpImgResp) GetMsgImgInfo() *ImgInfo {
	if m != nil {
		return m.MsgImgInfo
	}
	return nil
}

func (m *TryUpImgResp) GetUint32UpIp() []int32 {
	if m != nil {
		return m.Uint32UpIp
	}
	return nil
}

func (m *TryUpImgResp) GetUint32UpPort() []int32 {
	if m != nil {
		return m.Uint32UpPort
	}
	return nil
}

func (m *TryUpImgResp) GetUpUkey() []byte {
	if m != nil {
		return m.UpUkey
	}
	return nil
}

func (m *TryUpImgResp) GetFid() int64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

type TryUpPttReq struct {
	GroupCode     int64  `protobuf:"varint,1,opt,name=groupCode,proto3" json:"groupCode,omitempty"`
	SrcUin        int64  `protobuf:"varint,2,opt,name=srcUin,proto3" json:"srcUin,omitempty"`
	FileId        int64  `protobuf:"varint,3,opt,name=fileId,proto3" json:"fileId,omitempty"`
	FileMd5       []byte `protobuf:"bytes,4,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	FileSize      int64  `protobuf:"varint,5,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileName      []byte `protobuf:"bytes,6,opt,name=fileName,proto3" json:"fileName,omitempty"`
	SrcTerm       int32  `protobuf:"varint,7,opt,name=srcTerm,proto3" json:"srcTerm,omitempty"`
	PlatformType  int32  `protobuf:"varint,8,opt,name=platformType,proto3" json:"platformType,omitempty"`
	BuType        int32  `protobuf:"varint,9,opt,name=buType,proto3" json:"buType,omitempty"`
	BuildVer      string `protobuf:"bytes,10,opt,name=buildVer,proto3" json:"buildVer,omitempty"`
	InnerIp       int32  `protobuf:"varint,11,opt,name=innerIp,proto3" json:"innerIp,omitempty"`
	VoiceLength   int32  `protobuf:"varint,12,opt,name=voiceLength,proto3" json:"voiceLength,omitempty"`
	BoolNewUpChan bool   `protobuf:"varint,13,opt,name=boolNewUpChan,proto3" json:"boolNewUpChan,omitempty"`
	Codec         int32  `protobuf:"varint,14,opt,name=codec,proto3" json:"codec,omitempty"`
	VoiceType     int32  `protobuf:"varint,15,opt,name=voiceType,proto3" json:"voiceType,omitempty"`
	BuId          int32  `protobuf:"varint,16,opt,name=buId,proto3" json:"buId,omitempty"`
}

func (m *TryUpPttReq) Reset()         { *m = TryUpPttReq{} }
func (m *TryUpPttReq) String() string { return proto.CompactTextString(m) }
func (*TryUpPttReq) ProtoMessage()    {}
func (*TryUpPttReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{14}
}
func (m *TryUpPttReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TryUpPttReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TryUpPttReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TryUpPttReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TryUpPttReq.Merge(m, src)
}
func (m *TryUpPttReq) XXX_Size() int {
	return m.Size()
}
func (m *TryUpPttReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TryUpPttReq.DiscardUnknown(m)
}

var xxx_messageInfo_TryUpPttReq proto.InternalMessageInfo

func (m *TryUpPttReq) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *TryUpPttReq) GetSrcUin() int64 {
	if m != nil {
		return m.SrcUin
	}
	return 0
}

func (m *TryUpPttReq) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *TryUpPttReq) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *TryUpPttReq) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *TryUpPttReq) GetFileName() []byte {
	if m != nil {
		return m.FileName
	}
	return nil
}

func (m *TryUpPttReq) GetSrcTerm() int32 {
	if m != nil {
		return m.SrcTerm
	}
	return 0
}

func (m *TryUpPttReq) GetPlatformType() int32 {
	if m != nil {
		return m.PlatformType
	}
	return 0
}

func (m *TryUpPttReq) GetBuType() int32 {
	if m != nil {
		return m.BuType
	}
	return 0
}

func (m *TryUpPttReq) GetBuildVer() string {
	if m != nil {
		return m.BuildVer
	}
	return ""
}

func (m *TryUpPttReq) GetInnerIp() int32 {
	if m != nil {
		return m.InnerIp
	}
	return 0
}

func (m *TryUpPttReq) GetVoiceLength() int32 {
	if m != nil {
		return m.VoiceLength
	}
	return 0
}

func (m *TryUpPttReq) GetBoolNewUpChan() bool {
	if m != nil {
		return m.BoolNewUpChan
	}
	return false
}

func (m *TryUpPttReq) GetCodec() int32 {
	if m != nil {
		return m.Codec
	}
	return 0
}

func (m *TryUpPttReq) GetVoiceType() int32 {
	if m != nil {
		return m.VoiceType
	}
	return 0
}

func (m *TryUpPttReq) GetBuId() int32 {
	if m != nil {
		return m.BuId
	}
	return 0
}

type TryUpPttResp struct {
	FileId       int64   `protobuf:"varint,1,opt,name=fileId,proto3" json:"fileId,omitempty"`
	Result       int32   `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	FailMsg      string  `protobuf:"bytes,3,opt,name=failMsg,proto3" json:"failMsg,omitempty"`
	BoolFileExit bool    `protobuf:"varint,4,opt,name=boolFileExit,proto3" json:"boolFileExit,omitempty"`
	Uint32UpIp   []int32 `protobuf:"varint,5,rep,packed,name=uint32UpIp,proto3" json:"uint32UpIp,omitempty"`
	Uint32UpPort []int32 `protobuf:"varint,6,rep,packed,name=uint32UpPort,proto3" json:"uint32UpPort,omitempty"`
	UpUkey       []byte  `protobuf:"bytes,7,opt,name=upUkey,proto3" json:"upUkey,omitempty"`
	FileId2      int64   `protobuf:"varint,8,opt,name=fileId2,proto3" json:"fileId2,omitempty"`
	UpOffset     int64   `protobuf:"varint,9,opt,name=upOffset,proto3" json:"upOffset,omitempty"`
	BlockSize    int64   `protobuf:"varint,10,opt,name=blockSize,proto3" json:"blockSize,omitempty"`
	FileKey      []byte  `protobuf:"bytes,11,opt,name=fileKey,proto3" json:"fileKey,omitempty"`
	ChannelType  int32   `protobuf:"varint,12,opt,name=channelType,proto3" json:"channelType,omitempty"`
}

func (m *TryUpPttResp) Reset()         { *m = TryUpPttResp{} }
func (m *TryUpPttResp) String() string { return proto.CompactTextString(m) }
func (*TryUpPttResp) ProtoMessage()    {}
func (*TryUpPttResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{15}
}
func (m *TryUpPttResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TryUpPttResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TryUpPttResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TryUpPttResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TryUpPttResp.Merge(m, src)
}
func (m *TryUpPttResp) XXX_Size() int {
	return m.Size()
}
func (m *TryUpPttResp) XXX_DiscardUnknown() {
	xxx_messageInfo_TryUpPttResp.DiscardUnknown(m)
}

var xxx_messageInfo_TryUpPttResp proto.InternalMessageInfo

func (m *TryUpPttResp) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *TryUpPttResp) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *TryUpPttResp) GetFailMsg() string {
	if m != nil {
		return m.FailMsg
	}
	return ""
}

func (m *TryUpPttResp) GetBoolFileExit() bool {
	if m != nil {
		return m.BoolFileExit
	}
	return false
}

func (m *TryUpPttResp) GetUint32UpIp() []int32 {
	if m != nil {
		return m.Uint32UpIp
	}
	return nil
}

func (m *TryUpPttResp) GetUint32UpPort() []int32 {
	if m != nil {
		return m.Uint32UpPort
	}
	return nil
}

func (m *TryUpPttResp) GetUpUkey() []byte {
	if m != nil {
		return m.UpUkey
	}
	return nil
}

func (m *TryUpPttResp) GetFileId2() int64 {
	if m != nil {
		return m.FileId2
	}
	return 0
}

func (m *TryUpPttResp) GetUpOffset() int64 {
	if m != nil {
		return m.UpOffset
	}
	return 0
}

func (m *TryUpPttResp) GetBlockSize() int64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *TryUpPttResp) GetFileKey() []byte {
	if m != nil {
		return m.FileKey
	}
	return nil
}

func (m *TryUpPttResp) GetChannelType() int32 {
	if m != nil {
		return m.ChannelType
	}
	return 0
}

type ImgInfo struct {
	FileMd5    []byte `protobuf:"bytes,1,opt,name=fileMd5,proto3" json:"fileMd5,omitempty"`
	FileType   int32  `protobuf:"varint,2,opt,name=fileType,proto3" json:"fileType,omitempty"`
	FileSize   int64  `protobuf:"varint,3,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileWidth  int32  `protobuf:"varint,4,opt,name=fileWidth,proto3" json:"fileWidth,omitempty"`
	FileHeight int32  `protobuf:"varint,5,opt,name=fileHeight,proto3" json:"fileHeight,omitempty"`
}

func (m *ImgInfo) Reset()         { *m = ImgInfo{} }
func (m *ImgInfo) String() string { return proto.CompactTextString(m) }
func (*ImgInfo) ProtoMessage()    {}
func (*ImgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{16}
}
func (m *ImgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImgInfo.Merge(m, src)
}
func (m *ImgInfo) XXX_Size() int {
	return m.Size()
}
func (m *ImgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ImgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ImgInfo proto.InternalMessageInfo

func (m *ImgInfo) GetFileMd5() []byte {
	if m != nil {
		return m.FileMd5
	}
	return nil
}

func (m *ImgInfo) GetFileType() int32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *ImgInfo) GetFileSize() int64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *ImgInfo) GetFileWidth() int32 {
	if m != nil {
		return m.FileWidth
	}
	return 0
}

func (m *ImgInfo) GetFileHeight() int32 {
	if m != nil {
		return m.FileHeight
	}
	return 0
}

type DeleteMessageRequest struct {
	Items []*MessageItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
}

func (m *DeleteMessageRequest) Reset()         { *m = DeleteMessageRequest{} }
func (m *DeleteMessageRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteMessageRequest) ProtoMessage()    {}
func (*DeleteMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{17}
}
func (m *DeleteMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMessageRequest.Merge(m, src)
}
func (m *DeleteMessageRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMessageRequest proto.InternalMessageInfo

func (m *DeleteMessageRequest) GetItems() []*MessageItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type MessageItem struct {
	FromUin int64  `protobuf:"varint,1,opt,name=fromUin,proto3" json:"fromUin,omitempty"`
	ToUin   int64  `protobuf:"varint,2,opt,name=toUin,proto3" json:"toUin,omitempty"`
	MsgType int32  `protobuf:"varint,3,opt,name=msgType,proto3" json:"msgType,omitempty"`
	MsgSeq  int32  `protobuf:"varint,4,opt,name=msgSeq,proto3" json:"msgSeq,omitempty"`
	MsgUid  int64  `protobuf:"varint,5,opt,name=msgUid,proto3" json:"msgUid,omitempty"`
	Sig     []byte `protobuf:"bytes,7,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *MessageItem) Reset()         { *m = MessageItem{} }
func (m *MessageItem) String() string { return proto.CompactTextString(m) }
func (*MessageItem) ProtoMessage()    {}
func (*MessageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{18}
}
func (m *MessageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageItem.Merge(m, src)
}
func (m *MessageItem) XXX_Size() int {
	return m.Size()
}
func (m *MessageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageItem.DiscardUnknown(m)
}

var xxx_messageInfo_MessageItem proto.InternalMessageInfo

func (m *MessageItem) GetFromUin() int64 {
	if m != nil {
		return m.FromUin
	}
	return 0
}

func (m *MessageItem) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *MessageItem) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *MessageItem) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *MessageItem) GetMsgUid() int64 {
	if m != nil {
		return m.MsgUid
	}
	return 0
}

func (m *MessageItem) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

type SubD4 struct {
	Uin int64 `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
}

func (m *SubD4) Reset()         { *m = SubD4{} }
func (m *SubD4) String() string { return proto.CompactTextString(m) }
func (*SubD4) ProtoMessage()    {}
func (*SubD4) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{19}
}
func (m *SubD4) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubD4) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubD4.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubD4) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubD4.Merge(m, src)
}
func (m *SubD4) XXX_Size() int {
	return m.Size()
}
func (m *SubD4) XXX_DiscardUnknown() {
	xxx_messageInfo_SubD4.DiscardUnknown(m)
}

var xxx_messageInfo_SubD4 proto.InternalMessageInfo

func (m *SubD4) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

type Sub8A struct {
	MsgInfo         []*Sub8AMsgInfo `protobuf:"bytes,1,rep,name=msg_info,json=msgInfo,proto3" json:"msg_info,omitempty"`
	AppId           int32           `protobuf:"varint,2,opt,name=appId,proto3" json:"appId,omitempty"`
	InstId          int32           `protobuf:"varint,3,opt,name=instId,proto3" json:"instId,omitempty"`
	LongMessageFlag int32           `protobuf:"varint,4,opt,name=longMessageFlag,proto3" json:"longMessageFlag,omitempty"`
	Reserved        []byte          `protobuf:"bytes,5,opt,name=reserved,proto3" json:"reserved,omitempty"`
}

func (m *Sub8A) Reset()         { *m = Sub8A{} }
func (m *Sub8A) String() string { return proto.CompactTextString(m) }
func (*Sub8A) ProtoMessage()    {}
func (*Sub8A) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{20}
}
func (m *Sub8A) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub8A) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sub8A.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sub8A) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub8A.Merge(m, src)
}
func (m *Sub8A) XXX_Size() int {
	return m.Size()
}
func (m *Sub8A) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub8A.DiscardUnknown(m)
}

var xxx_messageInfo_Sub8A proto.InternalMessageInfo

func (m *Sub8A) GetMsgInfo() []*Sub8AMsgInfo {
	if m != nil {
		return m.MsgInfo
	}
	return nil
}

func (m *Sub8A) GetAppId() int32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *Sub8A) GetInstId() int32 {
	if m != nil {
		return m.InstId
	}
	return 0
}

func (m *Sub8A) GetLongMessageFlag() int32 {
	if m != nil {
		return m.LongMessageFlag
	}
	return 0
}

func (m *Sub8A) GetReserved() []byte {
	if m != nil {
		return m.Reserved
	}
	return nil
}

type Sub8AMsgInfo struct {
	FromUin   int64 `protobuf:"varint,1,opt,name=fromUin,proto3" json:"fromUin,omitempty"`
	ToUin     int64 `protobuf:"varint,2,opt,name=toUin,proto3" json:"toUin,omitempty"`
	MsgSeq    int32 `protobuf:"varint,3,opt,name=msgSeq,proto3" json:"msgSeq,omitempty"`
	MsgUid    int64 `protobuf:"varint,4,opt,name=msgUid,proto3" json:"msgUid,omitempty"`
	MsgTime   int64 `protobuf:"varint,5,opt,name=msgTime,proto3" json:"msgTime,omitempty"`
	MsgRandom int32 `protobuf:"varint,6,opt,name=msgRandom,proto3" json:"msgRandom,omitempty"`
	PkgNum    int32 `protobuf:"varint,7,opt,name=pkgNum,proto3" json:"pkgNum,omitempty"`
	PkgIndex  int32 `protobuf:"varint,8,opt,name=pkgIndex,proto3" json:"pkgIndex,omitempty"`
	DevSeq    int32 `protobuf:"varint,9,opt,name=devSeq,proto3" json:"devSeq,omitempty"`
}

func (m *Sub8AMsgInfo) Reset()         { *m = Sub8AMsgInfo{} }
func (m *Sub8AMsgInfo) String() string { return proto.CompactTextString(m) }
func (*Sub8AMsgInfo) ProtoMessage()    {}
func (*Sub8AMsgInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{21}
}
func (m *Sub8AMsgInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub8AMsgInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sub8AMsgInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sub8AMsgInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub8AMsgInfo.Merge(m, src)
}
func (m *Sub8AMsgInfo) XXX_Size() int {
	return m.Size()
}
func (m *Sub8AMsgInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub8AMsgInfo.DiscardUnknown(m)
}

var xxx_messageInfo_Sub8AMsgInfo proto.InternalMessageInfo

func (m *Sub8AMsgInfo) GetFromUin() int64 {
	if m != nil {
		return m.FromUin
	}
	return 0
}

func (m *Sub8AMsgInfo) GetToUin() int64 {
	if m != nil {
		return m.ToUin
	}
	return 0
}

func (m *Sub8AMsgInfo) GetMsgSeq() int32 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *Sub8AMsgInfo) GetMsgUid() int64 {
	if m != nil {
		return m.MsgUid
	}
	return 0
}

func (m *Sub8AMsgInfo) GetMsgTime() int64 {
	if m != nil {
		return m.MsgTime
	}
	return 0
}

func (m *Sub8AMsgInfo) GetMsgRandom() int32 {
	if m != nil {
		return m.MsgRandom
	}
	return 0
}

func (m *Sub8AMsgInfo) GetPkgNum() int32 {
	if m != nil {
		return m.PkgNum
	}
	return 0
}

func (m *Sub8AMsgInfo) GetPkgIndex() int32 {
	if m != nil {
		return m.PkgIndex
	}
	return 0
}

func (m *Sub8AMsgInfo) GetDevSeq() int32 {
	if m != nil {
		return m.DevSeq
	}
	return 0
}

type SubB3 struct {
	Type            int32              `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	MsgAddFrdNotify *SubB3AddFrdNotify `protobuf:"bytes,2,opt,name=msgAddFrdNotify,proto3" json:"msgAddFrdNotify,omitempty"`
}

func (m *SubB3) Reset()         { *m = SubB3{} }
func (m *SubB3) String() string { return proto.CompactTextString(m) }
func (*SubB3) ProtoMessage()    {}
func (*SubB3) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{22}
}
func (m *SubB3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubB3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubB3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubB3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubB3.Merge(m, src)
}
func (m *SubB3) XXX_Size() int {
	return m.Size()
}
func (m *SubB3) XXX_DiscardUnknown() {
	xxx_messageInfo_SubB3.DiscardUnknown(m)
}

var xxx_messageInfo_SubB3 proto.InternalMessageInfo

func (m *SubB3) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *SubB3) GetMsgAddFrdNotify() *SubB3AddFrdNotify {
	if m != nil {
		return m.MsgAddFrdNotify
	}
	return nil
}

type SubB3AddFrdNotify struct {
	Uin  int64  `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	Nick string `protobuf:"bytes,5,opt,name=nick,proto3" json:"nick,omitempty"`
}

func (m *SubB3AddFrdNotify) Reset()         { *m = SubB3AddFrdNotify{} }
func (m *SubB3AddFrdNotify) String() string { return proto.CompactTextString(m) }
func (*SubB3AddFrdNotify) ProtoMessage()    {}
func (*SubB3AddFrdNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{23}
}
func (m *SubB3AddFrdNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubB3AddFrdNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubB3AddFrdNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubB3AddFrdNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubB3AddFrdNotify.Merge(m, src)
}
func (m *SubB3AddFrdNotify) XXX_Size() int {
	return m.Size()
}
func (m *SubB3AddFrdNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_SubB3AddFrdNotify.DiscardUnknown(m)
}

var xxx_messageInfo_SubB3AddFrdNotify proto.InternalMessageInfo

func (m *SubB3AddFrdNotify) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *SubB3AddFrdNotify) GetNick() string {
	if m != nil {
		return m.Nick
	}
	return ""
}

type Sub44 struct {
	FriendSyncMsg *Sub44FriendSyncMsg `protobuf:"bytes,1,opt,name=friendSyncMsg,proto3" json:"friendSyncMsg,omitempty"`
	GroupSyncMsg  *Sub44GroupSyncMsg  `protobuf:"bytes,2,opt,name=groupSyncMsg,proto3" json:"groupSyncMsg,omitempty"`
}

func (m *Sub44) Reset()         { *m = Sub44{} }
func (m *Sub44) String() string { return proto.CompactTextString(m) }
func (*Sub44) ProtoMessage()    {}
func (*Sub44) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{24}
}
func (m *Sub44) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub44) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sub44.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sub44) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub44.Merge(m, src)
}
func (m *Sub44) XXX_Size() int {
	return m.Size()
}
func (m *Sub44) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub44.DiscardUnknown(m)
}

var xxx_messageInfo_Sub44 proto.InternalMessageInfo

func (m *Sub44) GetFriendSyncMsg() *Sub44FriendSyncMsg {
	if m != nil {
		return m.FriendSyncMsg
	}
	return nil
}

func (m *Sub44) GetGroupSyncMsg() *Sub44GroupSyncMsg {
	if m != nil {
		return m.GroupSyncMsg
	}
	return nil
}

type Sub44FriendSyncMsg struct {
	Uin         int64    `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	FUin        int64    `protobuf:"varint,2,opt,name=fUin,proto3" json:"fUin,omitempty"`
	ProcessType int32    `protobuf:"varint,3,opt,name=processType,proto3" json:"processType,omitempty"`
	Time        int32    `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	ProcessFlag int32    `protobuf:"varint,5,opt,name=processFlag,proto3" json:"processFlag,omitempty"`
	SourceId    int32    `protobuf:"varint,6,opt,name=sourceId,proto3" json:"sourceId,omitempty"`
	SourceSubId int32    `protobuf:"varint,7,opt,name=sourceSubId,proto3" json:"sourceSubId,omitempty"`
	StrWording  []string `protobuf:"bytes,8,rep,name=strWording,proto3" json:"strWording,omitempty"`
}

func (m *Sub44FriendSyncMsg) Reset()         { *m = Sub44FriendSyncMsg{} }
func (m *Sub44FriendSyncMsg) String() string { return proto.CompactTextString(m) }
func (*Sub44FriendSyncMsg) ProtoMessage()    {}
func (*Sub44FriendSyncMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{25}
}
func (m *Sub44FriendSyncMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub44FriendSyncMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sub44FriendSyncMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sub44FriendSyncMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub44FriendSyncMsg.Merge(m, src)
}
func (m *Sub44FriendSyncMsg) XXX_Size() int {
	return m.Size()
}
func (m *Sub44FriendSyncMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub44FriendSyncMsg.DiscardUnknown(m)
}

var xxx_messageInfo_Sub44FriendSyncMsg proto.InternalMessageInfo

func (m *Sub44FriendSyncMsg) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *Sub44FriendSyncMsg) GetFUin() int64 {
	if m != nil {
		return m.FUin
	}
	return 0
}

func (m *Sub44FriendSyncMsg) GetProcessType() int32 {
	if m != nil {
		return m.ProcessType
	}
	return 0
}

func (m *Sub44FriendSyncMsg) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Sub44FriendSyncMsg) GetProcessFlag() int32 {
	if m != nil {
		return m.ProcessFlag
	}
	return 0
}

func (m *Sub44FriendSyncMsg) GetSourceId() int32 {
	if m != nil {
		return m.SourceId
	}
	return 0
}

func (m *Sub44FriendSyncMsg) GetSourceSubId() int32 {
	if m != nil {
		return m.SourceSubId
	}
	return 0
}

func (m *Sub44FriendSyncMsg) GetStrWording() []string {
	if m != nil {
		return m.StrWording
	}
	return nil
}

type Sub44GroupSyncMsg struct {
	MsgType         int32  `protobuf:"varint,1,opt,name=msgType,proto3" json:"msgType,omitempty"`
	MsgSeq          int64  `protobuf:"varint,2,opt,name=msgSeq,proto3" json:"msgSeq,omitempty"`
	GrpCode         int64  `protobuf:"varint,3,opt,name=grpCode,proto3" json:"grpCode,omitempty"`
	GaCode          int64  `protobuf:"varint,4,opt,name=gaCode,proto3" json:"gaCode,omitempty"`
	OptUin1         int64  `protobuf:"varint,5,opt,name=optUin1,proto3" json:"optUin1,omitempty"`
	OptUin2         int64  `protobuf:"varint,6,opt,name=optUin2,proto3" json:"optUin2,omitempty"`
	MsgBuf          []byte `protobuf:"bytes,7,opt,name=msgBuf,proto3" json:"msgBuf,omitempty"`
	AuthKey         []byte `protobuf:"bytes,8,opt,name=authKey,proto3" json:"authKey,omitempty"`
	MsgStatus       int32  `protobuf:"varint,9,opt,name=msgStatus,proto3" json:"msgStatus,omitempty"`
	ActionUin       int64  `protobuf:"varint,10,opt,name=actionUin,proto3" json:"actionUin,omitempty"`
	ActionTime      int64  `protobuf:"varint,11,opt,name=actionTime,proto3" json:"actionTime,omitempty"`
	CurMaxMemCount  int32  `protobuf:"varint,12,opt,name=curMaxMemCount,proto3" json:"curMaxMemCount,omitempty"`
	NextMaxMemCount int32  `protobuf:"varint,13,opt,name=nextMaxMemCount,proto3" json:"nextMaxMemCount,omitempty"`
	CurMemCount     int32  `protobuf:"varint,14,opt,name=curMemCount,proto3" json:"curMemCount,omitempty"`
	ReqSrcId        int32  `protobuf:"varint,15,opt,name=reqSrcId,proto3" json:"reqSrcId,omitempty"`
	ReqSrcSubId     int32  `protobuf:"varint,16,opt,name=reqSrcSubId,proto3" json:"reqSrcSubId,omitempty"`
	InviterRole     int32  `protobuf:"varint,17,opt,name=inviterRole,proto3" json:"inviterRole,omitempty"`
	ExtAdminNum     int32  `protobuf:"varint,18,opt,name=extAdminNum,proto3" json:"extAdminNum,omitempty"`
	ProcessFlag     int32  `protobuf:"varint,19,opt,name=processFlag,proto3" json:"processFlag,omitempty"`
}

func (m *Sub44GroupSyncMsg) Reset()         { *m = Sub44GroupSyncMsg{} }
func (m *Sub44GroupSyncMsg) String() string { return proto.CompactTextString(m) }
func (*Sub44GroupSyncMsg) ProtoMessage()    {}
func (*Sub44GroupSyncMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{26}
}
func (m *Sub44GroupSyncMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sub44GroupSyncMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sub44GroupSyncMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sub44GroupSyncMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sub44GroupSyncMsg.Merge(m, src)
}
func (m *Sub44GroupSyncMsg) XXX_Size() int {
	return m.Size()
}
func (m *Sub44GroupSyncMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_Sub44GroupSyncMsg.DiscardUnknown(m)
}

var xxx_messageInfo_Sub44GroupSyncMsg proto.InternalMessageInfo

func (m *Sub44GroupSyncMsg) GetMsgType() int32 {
	if m != nil {
		return m.MsgType
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetMsgSeq() int64 {
	if m != nil {
		return m.MsgSeq
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetGrpCode() int64 {
	if m != nil {
		return m.GrpCode
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetGaCode() int64 {
	if m != nil {
		return m.GaCode
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetOptUin1() int64 {
	if m != nil {
		return m.OptUin1
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetOptUin2() int64 {
	if m != nil {
		return m.OptUin2
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetMsgBuf() []byte {
	if m != nil {
		return m.MsgBuf
	}
	return nil
}

func (m *Sub44GroupSyncMsg) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *Sub44GroupSyncMsg) GetMsgStatus() int32 {
	if m != nil {
		return m.MsgStatus
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetActionUin() int64 {
	if m != nil {
		return m.ActionUin
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetActionTime() int64 {
	if m != nil {
		return m.ActionTime
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetCurMaxMemCount() int32 {
	if m != nil {
		return m.CurMaxMemCount
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetNextMaxMemCount() int32 {
	if m != nil {
		return m.NextMaxMemCount
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetCurMemCount() int32 {
	if m != nil {
		return m.CurMemCount
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetReqSrcId() int32 {
	if m != nil {
		return m.ReqSrcId
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetReqSrcSubId() int32 {
	if m != nil {
		return m.ReqSrcSubId
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetInviterRole() int32 {
	if m != nil {
		return m.InviterRole
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetExtAdminNum() int32 {
	if m != nil {
		return m.ExtAdminNum
	}
	return 0
}

func (m *Sub44GroupSyncMsg) GetProcessFlag() int32 {
	if m != nil {
		return m.ProcessFlag
	}
	return 0
}

type GroupMemberReqBody struct {
	GroupCode       int64 `protobuf:"varint,1,opt,name=groupCode,proto3" json:"groupCode,omitempty"`
	Uin             int64 `protobuf:"varint,2,opt,name=uin,proto3" json:"uin,omitempty"`
	NewClient       bool  `protobuf:"varint,3,opt,name=newClient,proto3" json:"newClient,omitempty"`
	ClientType      int32 `protobuf:"varint,4,opt,name=clientType,proto3" json:"clientType,omitempty"`
	RichCardNameVer int32 `protobuf:"varint,5,opt,name=richCardNameVer,proto3" json:"richCardNameVer,omitempty"`
}

func (m *GroupMemberReqBody) Reset()         { *m = GroupMemberReqBody{} }
func (m *GroupMemberReqBody) String() string { return proto.CompactTextString(m) }
func (*GroupMemberReqBody) ProtoMessage()    {}
func (*GroupMemberReqBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{27}
}
func (m *GroupMemberReqBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMemberReqBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMemberReqBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMemberReqBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMemberReqBody.Merge(m, src)
}
func (m *GroupMemberReqBody) XXX_Size() int {
	return m.Size()
}
func (m *GroupMemberReqBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMemberReqBody.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMemberReqBody proto.InternalMessageInfo

func (m *GroupMemberReqBody) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GroupMemberReqBody) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *GroupMemberReqBody) GetNewClient() bool {
	if m != nil {
		return m.NewClient
	}
	return false
}

func (m *GroupMemberReqBody) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *GroupMemberReqBody) GetRichCardNameVer() int32 {
	if m != nil {
		return m.RichCardNameVer
	}
	return 0
}

type GroupMemberRspBody struct {
	GroupCode              int64            `protobuf:"varint,1,opt,name=groupCode,proto3" json:"groupCode,omitempty"`
	SelfRole               int32            `protobuf:"varint,2,opt,name=selfRole,proto3" json:"selfRole,omitempty"`
	MemInfo                *GroupMemberInfo `protobuf:"bytes,3,opt,name=memInfo,proto3" json:"memInfo,omitempty"`
	BoolSelfLocationShared bool             `protobuf:"varint,4,opt,name=boolSelfLocationShared,proto3" json:"boolSelfLocationShared,omitempty"`
	GroupType              int32            `protobuf:"varint,5,opt,name=groupType,proto3" json:"groupType,omitempty"`
}

func (m *GroupMemberRspBody) Reset()         { *m = GroupMemberRspBody{} }
func (m *GroupMemberRspBody) String() string { return proto.CompactTextString(m) }
func (*GroupMemberRspBody) ProtoMessage()    {}
func (*GroupMemberRspBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{28}
}
func (m *GroupMemberRspBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMemberRspBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMemberRspBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMemberRspBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMemberRspBody.Merge(m, src)
}
func (m *GroupMemberRspBody) XXX_Size() int {
	return m.Size()
}
func (m *GroupMemberRspBody) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMemberRspBody.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMemberRspBody proto.InternalMessageInfo

func (m *GroupMemberRspBody) GetGroupCode() int64 {
	if m != nil {
		return m.GroupCode
	}
	return 0
}

func (m *GroupMemberRspBody) GetSelfRole() int32 {
	if m != nil {
		return m.SelfRole
	}
	return 0
}

func (m *GroupMemberRspBody) GetMemInfo() *GroupMemberInfo {
	if m != nil {
		return m.MemInfo
	}
	return nil
}

func (m *GroupMemberRspBody) GetBoolSelfLocationShared() bool {
	if m != nil {
		return m.BoolSelfLocationShared
	}
	return false
}

func (m *GroupMemberRspBody) GetGroupType() int32 {
	if m != nil {
		return m.GroupType
	}
	return 0
}

type GroupMemberInfo struct {
	Uin         int64  `protobuf:"varint,1,opt,name=uin,proto3" json:"uin,omitempty"`
	Result      int32  `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Errmsg      []byte `protobuf:"bytes,3,opt,name=errmsg,proto3" json:"errmsg,omitempty"`
	IsFriend    bool   `protobuf:"varint,4,opt,name=IsFriend,proto3" json:"IsFriend,omitempty"`
	Remark      []byte `protobuf:"bytes,5,opt,name=remark,proto3" json:"remark,omitempty"`
	IsConcerned bool   `protobuf:"varint,6,opt,name=IsConcerned,proto3" json:"IsConcerned,omitempty"`
	Credit      int32  `protobuf:"varint,7,opt,name=credit,proto3" json:"credit,omitempty"`
	Card        []byte `protobuf:"bytes,8,opt,name=card,proto3" json:"card,omitempty"`
	Sex         int32  `protobuf:"varint,9,opt,name=sex,proto3" json:"sex,omitempty"`
	Location    []byte `protobuf:"bytes,10,opt,name=location,proto3" json:"location,omitempty"`
	Nick        []byte `protobuf:"bytes,11,opt,name=nick,proto3" json:"nick,omitempty"`
	Age         int32  `protobuf:"varint,12,opt,name=age,proto3" json:"age,omitempty"`
	Lev         []byte `protobuf:"bytes,13,opt,name=lev,proto3" json:"lev,omitempty"`
	Join        int64  `protobuf:"varint,14,opt,name=join,proto3" json:"join,omitempty"`
	LastSpeak   int64  `protobuf:"varint,15,opt,name=lastSpeak,proto3" json:"lastSpeak,omitempty"`
	//repeated CustomEntry customEnties = 16;
	//repeated GBarInfo gbarConcerned = 17;
	GbarTitle              []byte `protobuf:"bytes,18,opt,name=gbarTitle,proto3" json:"gbarTitle,omitempty"`
	GbarUrl                []byte `protobuf:"bytes,19,opt,name=gbarUrl,proto3" json:"gbarUrl,omitempty"`
	GbarCnt                int32  `protobuf:"varint,20,opt,name=gbarCnt,proto3" json:"gbarCnt,omitempty"`
	IsAllowModCard         bool   `protobuf:"varint,21,opt,name=isAllowModCard,proto3" json:"isAllowModCard,omitempty"`
	IsVip                  bool   `protobuf:"varint,22,opt,name=isVip,proto3" json:"isVip,omitempty"`
	IsYearVip              bool   `protobuf:"varint,23,opt,name=isYearVip,proto3" json:"isYearVip,omitempty"`
	IsSuperVip             bool   `protobuf:"varint,24,opt,name=isSuperVip,proto3" json:"isSuperVip,omitempty"`
	IsSuperQq              bool   `protobuf:"varint,25,opt,name=isSuperQq,proto3" json:"isSuperQq,omitempty"`
	VipLev                 int32  `protobuf:"varint,26,opt,name=vipLev,proto3" json:"vipLev,omitempty"`
	Role                   int32  `protobuf:"varint,27,opt,name=role,proto3" json:"role,omitempty"`
	LocationShared         bool   `protobuf:"varint,28,opt,name=locationShared,proto3" json:"locationShared,omitempty"`
	Int64Distance          int64  `protobuf:"varint,29,opt,name=int64Distance,proto3" json:"int64Distance,omitempty"`
	ConcernType            int32  `protobuf:"varint,30,opt,name=concernType,proto3" json:"concernType,omitempty"`
	SpecialTitle           []byte `protobuf:"bytes,31,opt,name=specialTitle,proto3" json:"specialTitle,omitempty"`
	SpecialTitleExpireTime int32  `protobuf:"varint,32,opt,name=specialTitleExpireTime,proto3" json:"specialTitleExpireTime,omitempty"`
	//FlowersEntry flowerEntry = 33;
	//TeamEntry teamEntry = 34;
	PhoneNum []byte `protobuf:"bytes,35,opt,name=phoneNum,proto3" json:"phoneNum,omitempty"`
	Job      []byte `protobuf:"bytes,36,opt,name=job,proto3" json:"job,omitempty"`
	MedalId  int32  `protobuf:"varint,37,opt,name=medalId,proto3" json:"medalId,omitempty"`
	Level    int32  `protobuf:"varint,39,opt,name=level,proto3" json:"level,omitempty"`
	Honor    string `protobuf:"bytes,41,opt,name=honor,proto3" json:"honor,omitempty"`
}

func (m *GroupMemberInfo) Reset()         { *m = GroupMemberInfo{} }
func (m *GroupMemberInfo) String() string { return proto.CompactTextString(m) }
func (*GroupMemberInfo) ProtoMessage()    {}
func (*GroupMemberInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce252935ee1a442c, []int{29}
}
func (m *GroupMemberInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMemberInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMemberInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMemberInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMemberInfo.Merge(m, src)
}
func (m *GroupMemberInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupMemberInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMemberInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMemberInfo proto.InternalMessageInfo

func (m *GroupMemberInfo) GetUin() int64 {
	if m != nil {
		return m.Uin
	}
	return 0
}

func (m *GroupMemberInfo) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

func (m *GroupMemberInfo) GetErrmsg() []byte {
	if m != nil {
		return m.Errmsg
	}
	return nil
}

func (m *GroupMemberInfo) GetIsFriend() bool {
	if m != nil {
		return m.IsFriend
	}
	return false
}

func (m *GroupMemberInfo) GetRemark() []byte {
	if m != nil {
		return m.Remark
	}
	return nil
}

func (m *GroupMemberInfo) GetIsConcerned() bool {
	if m != nil {
		return m.IsConcerned
	}
	return false
}

func (m *GroupMemberInfo) GetCredit() int32 {
	if m != nil {
		return m.Credit
	}
	return 0
}

func (m *GroupMemberInfo) GetCard() []byte {
	if m != nil {
		return m.Card
	}
	return nil
}

func (m *GroupMemberInfo) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *GroupMemberInfo) GetLocation() []byte {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GroupMemberInfo) GetNick() []byte {
	if m != nil {
		return m.Nick
	}
	return nil
}

func (m *GroupMemberInfo) GetAge() int32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *GroupMemberInfo) GetLev() []byte {
	if m != nil {
		return m.Lev
	}
	return nil
}

func (m *GroupMemberInfo) GetJoin() int64 {
	if m != nil {
		return m.Join
	}
	return 0
}

func (m *GroupMemberInfo) GetLastSpeak() int64 {
	if m != nil {
		return m.LastSpeak
	}
	return 0
}

func (m *GroupMemberInfo) GetGbarTitle() []byte {
	if m != nil {
		return m.GbarTitle
	}
	return nil
}

func (m *GroupMemberInfo) GetGbarUrl() []byte {
	if m != nil {
		return m.GbarUrl
	}
	return nil
}

func (m *GroupMemberInfo) GetGbarCnt() int32 {
	if m != nil {
		return m.GbarCnt
	}
	return 0
}

func (m *GroupMemberInfo) GetIsAllowModCard() bool {
	if m != nil {
		return m.IsAllowModCard
	}
	return false
}

func (m *GroupMemberInfo) GetIsVip() bool {
	if m != nil {
		return m.IsVip
	}
	return false
}

func (m *GroupMemberInfo) GetIsYearVip() bool {
	if m != nil {
		return m.IsYearVip
	}
	return false
}

func (m *GroupMemberInfo) GetIsSuperVip() bool {
	if m != nil {
		return m.IsSuperVip
	}
	return false
}

func (m *GroupMemberInfo) GetIsSuperQq() bool {
	if m != nil {
		return m.IsSuperQq
	}
	return false
}

func (m *GroupMemberInfo) GetVipLev() int32 {
	if m != nil {
		return m.VipLev
	}
	return 0
}

func (m *GroupMemberInfo) GetRole() int32 {
	if m != nil {
		return m.Role
	}
	return 0
}

func (m *GroupMemberInfo) GetLocationShared() bool {
	if m != nil {
		return m.LocationShared
	}
	return false
}

func (m *GroupMemberInfo) GetInt64Distance() int64 {
	if m != nil {
		return m.Int64Distance
	}
	return 0
}

func (m *GroupMemberInfo) GetConcernType() int32 {
	if m != nil {
		return m.ConcernType
	}
	return 0
}

func (m *GroupMemberInfo) GetSpecialTitle() []byte {
	if m != nil {
		return m.SpecialTitle
	}
	return nil
}

func (m *GroupMemberInfo) GetSpecialTitleExpireTime() int32 {
	if m != nil {
		return m.SpecialTitleExpireTime
	}
	return 0
}

func (m *GroupMemberInfo) GetPhoneNum() []byte {
	if m != nil {
		return m.PhoneNum
	}
	return nil
}

func (m *GroupMemberInfo) GetJob() []byte {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *GroupMemberInfo) GetMedalId() int32 {
	if m != nil {
		return m.MedalId
	}
	return 0
}

func (m *GroupMemberInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GroupMemberInfo) GetHonor() string {
	if m != nil {
		return m.Honor
	}
	return ""
}

func init() {
	proto.RegisterType((*DeviceInfo)(nil), "DeviceInfo")
	proto.RegisterType((*RequestBody)(nil), "RequestBody")
	proto.RegisterType((*ConfigSeq)(nil), "ConfigSeq")
	proto.RegisterType((*D50ReqBody)(nil), "D50ReqBody")
	proto.RegisterType((*D388ReqBody)(nil), "D388ReqBody")
	proto.RegisterType((*D388RespBody)(nil), "D388RespBody")
	proto.RegisterType((*GetPttUrlReq)(nil), "GetPttUrlReq")
	proto.RegisterType((*GetPttUrlRsp)(nil), "GetPttUrlRsp")
	proto.RegisterType((*ReqDataHighwayHead)(nil), "ReqDataHighwayHead")
	proto.RegisterType((*RspDataHighwayHead)(nil), "RspDataHighwayHead")
	proto.RegisterType((*DataHighwayHead)(nil), "DataHighwayHead")
	proto.RegisterType((*SegHead)(nil), "SegHead")
	proto.RegisterType((*TryUpImgReq)(nil), "TryUpImgReq")
	proto.RegisterType((*TryUpImgResp)(nil), "TryUpImgResp")
	proto.RegisterType((*TryUpPttReq)(nil), "TryUpPttReq")
	proto.RegisterType((*TryUpPttResp)(nil), "TryUpPttResp")
	proto.RegisterType((*ImgInfo)(nil), "ImgInfo")
	proto.RegisterType((*DeleteMessageRequest)(nil), "DeleteMessageRequest")
	proto.RegisterType((*MessageItem)(nil), "MessageItem")
	proto.RegisterType((*SubD4)(nil), "SubD4")
	proto.RegisterType((*Sub8A)(nil), "Sub8A")
	proto.RegisterType((*Sub8AMsgInfo)(nil), "Sub8AMsgInfo")
	proto.RegisterType((*SubB3)(nil), "SubB3")
	proto.RegisterType((*SubB3AddFrdNotify)(nil), "SubB3AddFrdNotify")
	proto.RegisterType((*Sub44)(nil), "Sub44")
	proto.RegisterType((*Sub44FriendSyncMsg)(nil), "Sub44FriendSyncMsg")
	proto.RegisterType((*Sub44GroupSyncMsg)(nil), "Sub44GroupSyncMsg")
	proto.RegisterType((*GroupMemberReqBody)(nil), "GroupMemberReqBody")
	proto.RegisterType((*GroupMemberRspBody)(nil), "GroupMemberRspBody")
	proto.RegisterType((*GroupMemberInfo)(nil), "GroupMemberInfo")
}

func init() { proto.RegisterFile("client/pb/data.proto", fileDescriptor_ce252935ee1a442c) }

var fileDescriptor_ce252935ee1a442c = []byte{
	// 3030 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xcb, 0x6f, 0x24, 0x47,
	0x19, 0xcf, 0x78, 0x3c, 0x7e, 0xd4, 0x8c, 0xbd, 0x9b, 0xde, 0xcd, 0xa6, 0x93, 0x6c, 0x8c, 0xd5,
	0x84, 0x60, 0x38, 0x38, 0x89, 0xf7, 0x41, 0x12, 0xb8, 0x78, 0xed, 0x6c, 0x32, 0xda, 0xf5, 0x62,
	0x7a, 0xd6, 0x89, 0xc2, 0x25, 0xaa, 0xe9, 0xae, 0xe9, 0xa9, 0xb8, 0x5f, 0xae, 0xaa, 0xf6, 0x23,
	0x7f, 0x00, 0x52, 0x2e, 0x08, 0x24, 0x38, 0xa0, 0x48, 0x9c, 0xe0, 0x96, 0x33, 0xff, 0x41, 0x10,
	0x39, 0x20, 0x85, 0x1b, 0x70, 0x42, 0x89, 0x90, 0xc8, 0x0d, 0x71, 0xe3, 0x86, 0xbe, 0xaf, 0xaa,
	0xba, 0xab, 0x67, 0xed, 0x8d, 0xe0, 0x10, 0x71, 0xab, 0xdf, 0xaf, 0x1e, 0xfe, 0xfa, 0x7b, 0x57,
	0x8d, 0xc9, 0xd5, 0x28, 0xe5, 0x2c, 0x57, 0x2f, 0x95, 0xe3, 0x97, 0x62, 0xaa, 0xe8, 0x66, 0x29,
	0x0a, 0x55, 0x04, 0xbf, 0x99, 0x23, 0x64, 0x97, 0x1d, 0xf3, 0x88, 0x0d, 0xf3, 0x49, 0xe1, 0xad,
	0x11, 0x32, 0x2e, 0x0a, 0x95, 0x16, 0x34, 0x66, 0xc2, 0xef, 0xac, 0x77, 0x36, 0x96, 0x43, 0x87,
	0xf1, 0xd6, 0x49, 0xbf, 0x14, 0x45, 0xf4, 0x36, 0x13, 0x92, 0x17, 0xb9, 0x3f, 0x87, 0x0b, 0x5c,
	0xca, 0x7b, 0x96, 0x2c, 0x45, 0x45, 0xcc, 0x72, 0x9a, 0x31, 0xbf, 0x8b, 0xd3, 0x35, 0x86, 0xdd,
	0x3c, 0x8f, 0x04, 0xcb, 0x58, 0xae, 0x68, 0xea, 0xcf, 0xeb, 0xdd, 0x0e, 0x05, 0x2b, 0x26, 0x3c,
	0x4f, 0x98, 0x28, 0x05, 0xcf, 0x95, 0xdf, 0xd3, 0x2b, 0x1c, 0xca, 0xbb, 0x46, 0x16, 0x40, 0x9e,
	0x61, 0xec, 0x2f, 0xe0, 0xa4, 0x41, 0xde, 0x75, 0xb2, 0x4c, 0xf3, 0x58, 0x14, 0x3c, 0x1e, 0xc6,
	0xfe, 0x22, 0x4e, 0x35, 0x04, 0x48, 0x35, 0xa6, 0x92, 0xdd, 0xa1, 0x79, 0xec, 0x2f, 0x69, 0xa9,
	0x2c, 0xf6, 0x02, 0x32, 0xe0, 0x79, 0xce, 0x84, 0xfd, 0xa8, 0x65, 0x9c, 0x6f, 0x71, 0xc1, 0x36,
	0xe9, 0x87, 0xec, 0xa8, 0x62, 0x52, 0xdd, 0x29, 0xe2, 0x33, 0x6f, 0x8b, 0x5c, 0x12, 0xa5, 0x7a,
	0x2f, 0x2a, 0xf2, 0x09, 0x4f, 0xde, 0x4b, 0xb9, 0x54, 0x7e, 0x67, 0xbd, 0xbb, 0xd1, 0xdf, 0x22,
	0x9b, 0x3b, 0xc8, 0x8d, 0xd8, 0x51, 0xb8, 0x22, 0x4a, 0xa5, 0xd1, 0x7d, 0x2e, 0x55, 0xf0, 0x1a,
	0x59, 0xae, 0xe7, 0x3c, 0x8f, 0xcc, 0xab, 0xb3, 0x92, 0xa1, 0x86, 0x7b, 0x21, 0x8e, 0x3d, 0x9f,
	0x2c, 0x1e, 0x3b, 0x7a, 0xed, 0x85, 0x16, 0x06, 0x1f, 0x77, 0x09, 0xd9, 0xbd, 0xf5, 0x72, 0xc8,
	0x8e, 0xf0, 0xaf, 0x5f, 0x25, 0x3d, 0x5a, 0x96, 0x3c, 0xc6, 0xdd, 0xdd, 0x50, 0x03, 0x30, 0x5d,
	0x46, 0x4f, 0xf7, 0x0f, 0x93, 0x11, 0xff, 0x80, 0x99, 0x13, 0x1c, 0x06, 0x14, 0x24, 0x15, 0x15,
	0xea, 0x21, 0x37, 0x96, 0xe9, 0x85, 0x0d, 0x01, 0xbb, 0x11, 0x0c, 0xf3, 0x98, 0x9d, 0xa2, 0x65,
	0x7a, 0xa1, 0xc3, 0x80, 0xda, 0x05, 0x3b, 0x7a, 0x50, 0x65, 0x68, 0x93, 0x5e, 0x68, 0x10, 0x08,
	0x5d, 0xf1, 0x1c, 0x3e, 0xd0, 0x5f, 0x58, 0xef, 0x6e, 0x74, 0x43, 0x0b, 0xbd, 0x0d, 0xb2, 0x2a,
	0xd8, 0xd1, 0x5e, 0x25, 0x79, 0x34, 0x3a, 0xe1, 0x2a, 0x9a, 0xfa, 0xff, 0xfe, 0xbd, 0xde, 0x3b,
	0xc3, 0x7b, 0xaf, 0x93, 0xa7, 0x91, 0x51, 0x15, 0x4d, 0x33, 0x2a, 0x0e, 0xb7, 0xc1, 0x51, 0xa9,
	0x02, 0x45, 0x7c, 0xf8, 0xcb, 0x05, 0xdc, 0x72, 0xd1, 0x02, 0xef, 0x65, 0xe2, 0xb5, 0xa6, 0x46,
	0x51, 0x21, 0x98, 0xff, 0xe9, 0x1f, 0x97, 0x70, 0xdb, 0x39, 0x73, 0x46, 0xae, 0x7b, 0x92, 0xe7,
	0x89, 0x91, 0xeb, 0x2f, 0x1f, 0x2d, 0xd7, 0x72, 0x39, 0xbc, 0x77, 0x9b, 0x3c, 0xd5, 0xda, 0x7f,
	0x7f, 0x2c, 0xe5, 0x94, 0x0a, 0xe6, 0x7f, 0xf8, 0x93, 0x3e, 0x6e, 0x38, 0x7f, 0x3a, 0xf8, 0x68,
	0x8e, 0xf4, 0x77, 0x6f, 0xbc, 0xfa, 0xaa, 0xb5, 0x97, 0x4f, 0x16, 0x73, 0xa6, 0x1e, 0x36, 0xf6,
	0xb6, 0x10, 0xb4, 0x2a, 0xab, 0x71, 0x94, 0xc5, 0xc6, 0x5e, 0x06, 0x79, 0x37, 0xc9, 0x6a, 0x26,
	0x93, 0x87, 0xe2, 0xec, 0xa0, 0x1c, 0x66, 0x49, 0xc8, 0x8e, 0xfc, 0x2e, 0xba, 0xd7, 0x60, 0xd3,
	0xe1, 0xc2, 0x99, 0x35, 0xee, 0xae, 0x7d, 0xa5, 0x60, 0x57, 0xcf, 0xdd, 0xa5, 0xb9, 0x70, 0x66,
	0x8d, 0xf7, 0x0a, 0x19, 0x64, 0x32, 0x79, 0x93, 0x29, 0xb3, 0x67, 0x01, 0xf7, 0xac, 0x6c, 0x6a,
	0xe6, 0x40, 0xa4, 0xb0, 0xa9, 0xb5, 0x04, 0x5c, 0x29, 0x2a, 0xb2, 0x8c, 0xe6, 0x36, 0xd6, 0x7a,
	0x61, 0x43, 0x78, 0xcf, 0x93, 0x65, 0x76, 0xaa, 0x58, 0x8e, 0x9e, 0xfc, 0x25, 0x4c, 0x0f, 0xc2,
	0x86, 0x09, 0xbe, 0xec, 0x90, 0x81, 0xd6, 0x8e, 0x2c, 0x51, 0x3d, 0x90, 0x31, 0x30, 0x35, 0x0d,
	0x4b, 0xa3, 0x9f, 0x1a, 0x1b, 0x05, 0xed, 0xb4, 0x14, 0xb4, 0x93, 0xc5, 0xde, 0xad, 0xb6, 0x82,
	0x64, 0x69, 0x14, 0xb4, 0xe2, 0x28, 0x48, 0x96, 0xe1, 0xcc, 0x22, 0x77, 0x1b, 0x7c, 0x8a, 0x2c,
	0x8d, 0x86, 0x56, 0x1c, 0x0d, 0xb9, 0xdb, 0xf4, 0x22, 0xef, 0x7b, 0xe4, 0x52, 0xfd, 0xfd, 0xa0,
	0x10, 0x59, 0x9e, 0xa3, 0x25, 0x59, 0x86, 0xb3, 0xab, 0x82, 0x9f, 0x76, 0xc9, 0xc0, 0xd5, 0x23,
	0x68, 0x2e, 0x11, 0x45, 0x55, 0xee, 0x14, 0x31, 0x33, 0xe1, 0xdb, 0x10, 0xf0, 0xb5, 0xb1, 0x54,
	0x07, 0x5c, 0x27, 0x80, 0x6e, 0x68, 0x10, 0xf0, 0x13, 0x9e, 0xb2, 0x61, 0x8c, 0x71, 0xdb, 0x0d,
	0x0d, 0x02, 0xc7, 0x82, 0xd1, 0x5e, 0x7c, 0x0b, 0x23, 0x76, 0x10, 0x5a, 0x08, 0x33, 0x82, 0x1d,
	0x3d, 0x64, 0xc2, 0xc6, 0xab, 0x85, 0xde, 0x06, 0xb9, 0x24, 0xd8, 0xd1, 0x7e, 0x4a, 0xd5, 0xa4,
	0x10, 0x19, 0x3a, 0xa5, 0x0e, 0xb1, 0x59, 0x1a, 0xce, 0xc0, 0x1c, 0x38, 0x2c, 0x8d, 0x8d, 0x2d,
	0xc4, 0x1c, 0x5c, 0xe1, 0x56, 0x1d, 0x66, 0x06, 0x61, 0x96, 0xad, 0x78, 0x1a, 0xbf, 0xcd, 0x04,
	0x66, 0xd1, 0x41, 0x58, 0x63, 0x2b, 0xeb, 0x3d, 0x76, 0xe6, 0xf7, 0x1b, 0x59, 0xef, 0x31, 0x4c,
	0x67, 0x50, 0x21, 0x22, 0x7f, 0x80, 0x87, 0x69, 0x00, 0x19, 0x72, 0x5c, 0x0d, 0x63, 0x7f, 0x45,
	0x67, 0x48, 0x18, 0x1b, 0xd9, 0x1f, 0x0a, 0x9a, 0xcb, 0x09, 0x13, 0x28, 0xc0, 0x6a, 0x2d, 0xbb,
	0x4b, 0x83, 0x84, 0x5c, 0x6e, 0x57, 0xaa, 0xf0, 0x2f, 0x69, 0x09, 0x35, 0x0a, 0x7e, 0xdd, 0x32,
	0x88, 0x2c, 0x1d, 0xd5, 0x76, 0x2e, 0x52, 0xed, 0x5c, 0x5b, 0xb5, 0x98, 0x09, 0x65, 0x95, 0x2a,
	0x93, 0x44, 0x0d, 0xc2, 0x1d, 0x94, 0xa7, 0x7b, 0x32, 0xa9, 0x8d, 0xa1, 0x21, 0x14, 0x98, 0xf1,
	0x99, 0x62, 0x72, 0xb7, 0x38, 0xc9, 0x0f, 0x44, 0x8a, 0x16, 0x19, 0x84, 0x2d, 0x0e, 0xd6, 0x54,
	0x3c, 0x57, 0x37, 0xb6, 0x80, 0x18, 0x6a, 0xff, 0xea, 0x85, 0x2d, 0xce, 0x7b, 0x91, 0xac, 0x36,
	0x78, 0xbf, 0x10, 0xca, 0x5f, 0xc4, 0x55, 0x33, 0x2c, 0xe4, 0xf2, 0xb8, 0x38, 0xc9, 0x77, 0x8b,
	0x8c, 0xf2, 0x1c, 0x4d, 0x34, 0x08, 0x1d, 0x06, 0xcc, 0x04, 0x68, 0x9f, 0x0a, 0x6a, 0xcd, 0x64,
	0x31, 0xc8, 0xa1, 0x5c, 0xfd, 0xea, 0x44, 0xd7, 0xe2, 0xe0, 0x7c, 0x9a, 0xa6, 0xc5, 0x49, 0xc8,
	0x94, 0x38, 0x33, 0x56, 0x73, 0x18, 0x4c, 0x0f, 0x26, 0x80, 0x6f, 0xfb, 0xcf, 0xe9, 0xf8, 0xaf,
	0x09, 0x5d, 0x87, 0x84, 0x11, 0xee, 0xba, 0x2e, 0xd4, 0x35, 0x11, 0xfc, 0xae, 0x43, 0xbc, 0x90,
	0x1d, 0xed, 0x52, 0x45, 0xdf, 0xe2, 0xc9, 0xf4, 0x84, 0x9e, 0xbd, 0xc5, 0x68, 0xec, 0x6d, 0x91,
	0x7e, 0x26, 0x93, 0x3b, 0x54, 0xb2, 0x29, 0xa3, 0xda, 0x56, 0xfd, 0xad, 0xcb, 0x9b, 0x33, 0xcb,
	0x42, 0x77, 0x91, 0xb7, 0x41, 0x48, 0x26, 0x93, 0x11, 0x4b, 0x70, 0xcb, 0x1c, 0x6e, 0x59, 0xda,
	0x1c, 0xb1, 0x04, 0x97, 0x3a, 0x73, 0xde, 0x0b, 0x64, 0x45, 0xb0, 0xa3, 0x37, 0x20, 0x45, 0xc5,
	0x3c, 0x9f, 0x14, 0x68, 0xd9, 0x41, 0xd8, 0x26, 0x41, 0x70, 0xc5, 0x33, 0x26, 0x15, 0xcd, 0x4a,
	0x34, 0x71, 0x37, 0x6c, 0x88, 0xe0, 0xaf, 0x73, 0xc4, 0x0b, 0x65, 0xf9, 0xf5, 0x0a, 0x7e, 0x9d,
	0x2c, 0x33, 0x21, 0x0a, 0x81, 0xe9, 0xc4, 0xd4, 0xf4, 0x9a, 0x98, 0xb1, 0xd3, 0xfc, 0xb9, 0x76,
	0xa2, 0xd1, 0x94, 0x45, 0x85, 0x54, 0x26, 0x4d, 0x34, 0x04, 0xf8, 0xf9, 0x54, 0xe1, 0x94, 0xce,
	0x0f, 0x06, 0xa1, 0xb2, 0x64, 0xe9, 0x28, 0x6b, 0xd1, 0x28, 0xcb, 0x25, 0xdb, 0xca, 0x5a, 0x9a,
	0x51, 0x16, 0x84, 0xbc, 0xa0, 0x79, 0xc2, 0xd0, 0xfd, 0xba, 0xa1, 0x06, 0x98, 0x70, 0x64, 0xc8,
	0x24, 0x53, 0x3e, 0x31, 0x09, 0x47, 0xc3, 0xe0, 0xe7, 0x73, 0xe4, 0xd2, 0xac, 0x66, 0x9d, 0x76,
	0xa9, 0xd3, 0x6a, 0x97, 0xbc, 0xcb, 0xa4, 0x5b, 0x71, 0xdb, 0x9c, 0xc2, 0x10, 0xd6, 0x9a, 0xfa,
	0x64, 0x7a, 0x52, 0x0b, 0x61, 0xad, 0x64, 0x47, 0x46, 0x39, 0x30, 0x04, 0xad, 0x09, 0x50, 0x0f,
	0xb4, 0x45, 0xd2, 0xa8, 0xc5, 0x61, 0x9a, 0xee, 0x4b, 0xab, 0xc5, 0x74, 0x5f, 0x10, 0x53, 0x54,
	0xd1, 0x49, 0x4a, 0x13, 0x93, 0x2d, 0x6b, 0xdc, 0x2e, 0x97, 0x4b, 0xb3, 0xe5, 0x72, 0x36, 0x69,
	0x2e, 0x3b, 0x49, 0xf3, 0x59, 0xb2, 0x94, 0x16, 0x11, 0xc5, 0xfc, 0xa4, 0x55, 0x52, 0xe3, 0xe0,
	0xef, 0x73, 0x64, 0xd1, 0xf8, 0x04, 0xc6, 0x14, 0x13, 0xd0, 0xc5, 0x9b, 0xae, 0x10, 0x7a, 0x3b,
	0x4b, 0xc0, 0x29, 0x90, 0xbc, 0xa4, 0xed, 0x0b, 0xbb, 0x61, 0x8d, 0x31, 0x57, 0x50, 0x45, 0x8b,
	0xc9, 0x04, 0xd4, 0xae, 0xcb, 0x8b, 0xc3, 0xd8, 0xf9, 0x94, 0xe5, 0x89, 0x9a, 0x5a, 0x1f, 0x6a,
	0x18, 0xcc, 0x86, 0x0a, 0x32, 0x76, 0xdd, 0x17, 0x22, 0x02, 0x2f, 0x31, 0x02, 0x28, 0x1e, 0x1d,
	0x32, 0xed, 0x44, 0x83, 0xb0, 0x4d, 0x42, 0x92, 0x77, 0x34, 0x86, 0x63, 0xb0, 0x48, 0x16, 0xdf,
	0x32, 0x69, 0x0b, 0x86, 0x6e, 0x2e, 0x5e, 0x6e, 0xe7, 0x62, 0xeb, 0xc1, 0xdb, 0x71, 0x2c, 0x8c,
	0x82, 0x1a, 0x02, 0x64, 0x3f, 0xaa, 0x98, 0xb5, 0xa4, 0xce, 0x64, 0x0e, 0x03, 0x32, 0x56, 0x65,
	0x4c, 0x15, 0xdb, 0x81, 0x2d, 0xbc, 0x34, 0xa9, 0xac, 0x4d, 0x06, 0x9f, 0xcc, 0x93, 0xbe, 0xdb,
	0x65, 0x7d, 0x65, 0x09, 0x97, 0x22, 0x72, 0x4a, 0xb8, 0x46, 0xff, 0x43, 0x09, 0x37, 0x56, 0xc3,
	0x6e, 0xbe, 0xd7, 0x58, 0x0d, 0x7b, 0x79, 0x33, 0xf7, 0x00, 0x2e, 0x59, 0xfa, 0x1a, 0x54, 0x63,
	0x38, 0x51, 0x8a, 0x08, 0x4b, 0xbf, 0x29, 0xdb, 0x06, 0x42, 0x6e, 0x2f, 0xdd, 0xba, 0xaf, 0x5d,
	0xb1, 0xc5, 0x39, 0xa5, 0x7d, 0x79, 0xb6, 0xb4, 0x97, 0x3c, 0x7a, 0x87, 0xc7, 0x6a, 0x6a, 0x3d,
	0xd1, 0x62, 0xd0, 0x48, 0xc9, 0xa3, 0xb7, 0x18, 0x4f, 0xa6, 0xca, 0xa8, 0xb9, 0x21, 0x40, 0x9e,
	0x92, 0x47, 0x78, 0xa4, 0xd6, 0xaf, 0x85, 0x2d, 0xcf, 0x5f, 0x99, 0xf1, 0x7c, 0xa7, 0xf9, 0x58,
	0x6d, 0x37, 0x1f, 0x90, 0xd5, 0xca, 0x72, 0xdf, 0x1c, 0x79, 0xc9, 0x64, 0xb5, 0x9a, 0x81, 0x2b,
	0x64, 0x21, 0x78, 0xc2, 0x73, 0x9a, 0xee, 0xf3, 0xc8, 0xbf, 0x8c, 0x0b, 0x5c, 0x0a, 0xe4, 0x45,
	0xed, 0xe3, 0x55, 0xe7, 0x49, 0x5d, 0x9f, 0x6a, 0xc2, 0x69, 0xc2, 0xbc, 0x56, 0x13, 0x06, 0x31,
	0x26, 0x8e, 0x0f, 0x4a, 0xb8, 0x09, 0xfb, 0x57, 0x4c, 0x8c, 0x59, 0x02, 0xfe, 0xaa, 0xad, 0x91,
	0x50, 0xe2, 0xaf, 0xe2, 0xa9, 0x2e, 0x15, 0xfc, 0x62, 0x8e, 0x0c, 0xdc, 0xe6, 0xf4, 0xc2, 0xd6,
	0xa3, 0x69, 0x30, 0xe6, 0x2e, 0x6a, 0x30, 0x4c, 0x12, 0x73, 0x1b, 0x8c, 0xa2, 0x48, 0xef, 0xf2,
	0x94, 0xbd, 0x71, 0xca, 0x15, 0x7a, 0xd2, 0x52, 0xd8, 0xe2, 0x4c, 0x51, 0x19, 0x66, 0x09, 0xdc,
	0xf3, 0xd1, 0xa1, 0xa0, 0xa8, 0x18, 0x1c, 0x3a, 0x73, 0xa0, 0x60, 0xdd, 0x50, 0x1c, 0x94, 0x75,
	0x23, 0xe2, 0x30, 0x4d, 0xab, 0x72, 0x50, 0x3a, 0x4d, 0x48, 0x8b, 0x83, 0x6f, 0xa8, 0xca, 0x83,
	0x43, 0x76, 0x66, 0xe2, 0xd8, 0x20, 0x08, 0xee, 0x09, 0x8f, 0x4d, 0xda, 0x87, 0x61, 0xf0, 0x69,
	0xd7, 0x84, 0x57, 0x73, 0xb7, 0xf8, 0xbf, 0x0b, 0xaf, 0xc1, 0xd7, 0x11, 0x5e, 0x75, 0x28, 0x90,
	0x8b, 0x43, 0xa1, 0xdf, 0x0e, 0x85, 0x75, 0xd2, 0x3f, 0x2e, 0x78, 0xc4, 0xee, 0xeb, 0xec, 0xac,
	0xc3, 0xcb, 0xa5, 0x20, 0xc5, 0x81, 0x17, 0x3c, 0x60, 0x27, 0x07, 0xe5, 0xce, 0x94, 0xe6, 0x18,
	0x67, 0x4b, 0x61, 0x9b, 0x6c, 0x3a, 0xf0, 0x55, 0xb7, 0x03, 0xbf, 0x4e, 0x96, 0xf1, 0x28, 0x27,
	0xce, 0x1a, 0xa2, 0xee, 0xcf, 0x2f, 0x37, 0xfd, 0x79, 0xf0, 0x0f, 0xeb, 0xe2, 0xe6, 0x22, 0xf5,
	0x35, 0xbb, 0x78, 0xdb, 0x71, 0x7b, 0x5f, 0xe9, 0xb8, 0x0b, 0x8f, 0x75, 0xdc, 0xc5, 0x96, 0xe3,
	0x1a, 0x47, 0x1a, 0xc6, 0x5b, 0xa6, 0x9b, 0xb1, 0x10, 0x4c, 0x57, 0x95, 0x3f, 0xd4, 0xf5, 0x53,
	0xfb, 0x75, 0x8d, 0x41, 0x85, 0xe3, 0xb4, 0x88, 0x0e, 0xd1, 0xcb, 0x88, 0x76, 0xe6, 0x9a, 0x78,
	0xcc, 0x95, 0x68, 0x9d, 0xf4, 0xa3, 0x29, 0xcd, 0x73, 0x96, 0x3a, 0x79, 0xd3, 0xa5, 0x82, 0x5f,
	0x75, 0xc8, 0xa2, 0x0d, 0x58, 0xc7, 0xc9, 0x3b, 0xe7, 0x3a, 0x39, 0x1e, 0xa2, 0x35, 0x5d, 0xe3,
	0x56, 0x00, 0x74, 0x67, 0x02, 0xc0, 0x64, 0x48, 0x9d, 0xee, 0x75, 0xd1, 0x6f, 0x08, 0xd0, 0x33,
	0x00, 0x93, 0xf0, 0x4d, 0x87, 0xd4, 0x30, 0xc1, 0xeb, 0xe4, 0xea, 0x2e, 0x4b, 0x99, 0x62, 0x7b,
	0x4c, 0x4a, 0x9a, 0x30, 0xf3, 0x72, 0xe6, 0x05, 0xa4, 0xc7, 0x15, 0xcb, 0xa4, 0x79, 0x2b, 0x1b,
	0x6c, 0x9a, 0xf9, 0xa1, 0x62, 0x59, 0xa8, 0xa7, 0xe0, 0xbb, 0xfa, 0x0e, 0x8d, 0xdf, 0x26, 0x8a,
	0x0c, 0x22, 0xbe, 0x63, 0xf4, 0xae, 0x21, 0x38, 0xad, 0x2a, 0x9a, 0x4c, 0xa0, 0x01, 0xac, 0x87,
	0xcb, 0x3b, 0x7c, 0xb0, 0xee, 0x87, 0x2d, 0x04, 0xcb, 0x62, 0xe7, 0x6c, 0x9b, 0x3d, 0x83, 0x0c,
	0x7f, 0xc0, 0x63, 0x93, 0x06, 0x0c, 0xc2, 0xce, 0x90, 0x27, 0xc6, 0x0d, 0x60, 0x18, 0x3c, 0x43,
	0x7a, 0xa3, 0x6a, 0xbc, 0x7b, 0xd3, 0x36, 0x98, 0x5a, 0x20, 0x18, 0x06, 0xbf, 0xed, 0xe0, 0xdc,
	0xab, 0xdb, 0xde, 0x06, 0x59, 0xca, 0x64, 0xf2, 0x1e, 0x76, 0xc6, 0x1d, 0xf3, 0x48, 0x80, 0x33,
	0x7b, 0x52, 0xa7, 0x5a, 0x10, 0x08, 0xcd, 0xa6, 0x1b, 0xc9, 0xa1, 0x7d, 0xda, 0xd0, 0x00, 0x6f,
	0xae, 0xb9, 0x54, 0x26, 0x93, 0xc1, 0xcd, 0x15, 0x11, 0xdc, 0x7d, 0xd3, 0x22, 0x4f, 0x8c, 0x6e,
	0xee, 0x42, 0xd7, 0xa4, 0xbf, 0x63, 0x96, 0x06, 0xc3, 0x0a, 0x06, 0x7d, 0x16, 0x8b, 0xcd, 0x55,
	0xb3, 0xc6, 0xc1, 0xbf, 0x3a, 0x64, 0xe0, 0x4a, 0xf3, 0x5f, 0xeb, 0xb7, 0xd1, 0x62, 0xf7, 0x02,
	0x2d, 0xce, 0xb7, 0xb4, 0x68, 0xec, 0xc1, 0x33, 0x9b, 0x65, 0x2d, 0x04, 0x1f, 0xcb, 0x64, 0x12,
	0xd2, 0x3c, 0x2e, 0x32, 0xd3, 0x4b, 0x37, 0x04, 0x9c, 0x57, 0x1e, 0x26, 0x0f, 0x2a, 0x9b, 0x65,
	0x0d, 0xc2, 0x3e, 0xe4, 0x30, 0xd1, 0xa5, 0x7b, 0xc9, 0xf4, 0x21, 0x06, 0x63, 0xe5, 0x66, 0xc7,
	0x20, 0x9b, 0x49, 0xae, 0x1a, 0x05, 0xef, 0xa2, 0x6d, 0xee, 0xdc, 0x38, 0xf7, 0xd5, 0xf5, 0x07,
	0xf8, 0xb6, 0xb3, 0x1d, 0xc7, 0x77, 0x45, 0xfc, 0xa0, 0x50, 0x7c, 0x72, 0x66, 0x6e, 0x5c, 0xde,
	0x26, 0x6e, 0x72, 0x67, 0xc2, 0xd9, 0xa5, 0xc1, 0x6b, 0xe4, 0xc9, 0x47, 0x56, 0x3d, 0xea, 0x1e,
	0xf0, 0x87, 0x73, 0x1e, 0x1d, 0x9a, 0xf7, 0x6c, 0x1c, 0x07, 0x1f, 0xa0, 0x54, 0x37, 0x6f, 0x7a,
	0xaf, 0x91, 0x95, 0x89, 0xe0, 0x2c, 0x8f, 0x47, 0x67, 0x79, 0x04, 0xa9, 0x4f, 0x5f, 0x12, 0xaf,
	0x6c, 0xe2, 0xf4, 0x5d, 0x77, 0x2a, 0x6c, 0xaf, 0xf4, 0x6e, 0x93, 0x01, 0xd6, 0x46, 0xbb, 0xd3,
	0x91, 0xfc, 0xe6, 0xcd, 0x37, 0x9d, 0x99, 0xb0, 0xb5, 0x2e, 0xf8, 0x67, 0x87, 0x78, 0x8f, 0x9e,
	0x7e, 0xbe, 0xe0, 0x93, 0xc6, 0x07, 0x70, 0x6c, 0x7f, 0x03, 0x60, 0x52, 0x3a, 0x61, 0xe6, 0x52,
	0xa8, 0x67, 0xb0, 0xf8, 0xbc, 0xd1, 0x33, 0xd7, 0x6f, 0xff, 0x66, 0x09, 0xfa, 0x6e, 0xaf, 0xb5,
	0xcb, 0xfa, 0xad, 0x2c, 0x2a, 0x11, 0xb1, 0xa1, 0xbd, 0x5b, 0xd5, 0x18, 0x76, 0xeb, 0xf1, 0xa8,
	0x1a, 0xd7, 0x6f, 0x8e, 0x2e, 0xa5, 0x1f, 0xb0, 0xc5, 0x3b, 0x85, 0x88, 0x79, 0x9e, 0xf8, 0x4b,
	0xeb, 0xdd, 0x8d, 0xe5, 0xd0, 0x61, 0x82, 0x3f, 0xcd, 0xa3, 0xa9, 0xda, 0x6a, 0x71, 0xd3, 0x45,
	0xe7, 0xa2, 0x74, 0x31, 0x57, 0x3b, 0x34, 0x38, 0xba, 0x4f, 0x16, 0x13, 0x51, 0xd6, 0x17, 0xee,
	0x6e, 0x68, 0x21, 0xec, 0x48, 0x28, 0x4e, 0x98, 0x10, 0xd0, 0x08, 0x76, 0x14, 0x25, 0xb4, 0x90,
	0xaf, 0xd8, 0x10, 0x30, 0xb0, 0x99, 0xd9, 0xc2, 0x0f, 0xae, 0x67, 0xb6, 0xcc, 0x5f, 0xbf, 0x53,
	0x4d, 0x6c, 0x19, 0xd2, 0x08, 0x76, 0xd0, 0x4a, 0x4d, 0xef, 0xd5, 0x8d, 0x95, 0x85, 0x26, 0x9c,
	0x46, 0x8a, 0xaa, 0x4a, 0x1a, 0xff, 0x6f, 0x08, 0xfc, 0x75, 0x24, 0x52, 0xbc, 0xc8, 0xc1, 0x98,
	0xa6, 0x10, 0xd5, 0x04, 0xb6, 0xd4, 0x08, 0x30, 0x4e, 0xfb, 0xfa, 0x12, 0xd8, 0x30, 0xde, 0x8b,
	0x64, 0x35, 0xaa, 0xc4, 0x1e, 0x3d, 0xdd, 0x63, 0xd9, 0x4e, 0x51, 0xe5, 0xca, 0x54, 0xa4, 0x19,
	0x16, 0x72, 0x54, 0xce, 0x4e, 0x95, 0xbb, 0x50, 0x3f, 0xdf, 0xcd, 0xd2, 0x58, 0xe0, 0x2a, 0x51,
	0xaf, 0x5a, 0x35, 0x05, 0xae, 0xa1, 0x74, 0x16, 0x3b, 0x1a, 0x89, 0x68, 0x18, 0x9b, 0xe6, 0xa3,
	0xc6, 0xb0, 0x5b, 0x8f, 0xb5, 0x37, 0x98, 0x16, 0xdf, 0xa1, 0xf4, 0x2f, 0x4d, 0xc7, 0x5c, 0x31,
	0x11, 0x16, 0x29, 0xc3, 0x26, 0xbf, 0x17, 0xba, 0x14, 0xac, 0x60, 0xa7, 0x6a, 0x3b, 0xce, 0x78,
	0x0e, 0x59, 0xc6, 0xd3, 0x2b, 0x1c, 0x6a, 0xd6, 0x63, 0xaf, 0x3c, 0xe2, 0xb1, 0xc1, 0xc7, 0x1d,
	0xe2, 0xa1, 0x3b, 0xed, 0xb1, 0x6c, 0xcc, 0x84, 0x7d, 0xef, 0x7f, 0x7c, 0x0b, 0xeb, 0xbc, 0x4e,
	0x98, 0x20, 0xbb, 0x4e, 0x96, 0x73, 0x76, 0xb2, 0x83, 0x2f, 0x64, 0xe8, 0x54, 0x4b, 0x61, 0x43,
	0x80, 0x71, 0xf4, 0xe3, 0x19, 0x7a, 0xa9, 0xb9, 0x81, 0x37, 0x0c, 0x3e, 0x8a, 0xf2, 0x68, 0xba,
	0x43, 0x45, 0x0c, 0x0d, 0x2a, 0x74, 0x90, 0x3d, 0xf3, 0x28, 0xda, 0xa6, 0x83, 0xcf, 0x66, 0xc4,
	0x35, 0xef, 0xef, 0x8f, 0x17, 0x17, 0xa2, 0x92, 0xa5, 0x13, 0x54, 0xa3, 0x69, 0x21, 0x2c, 0xf6,
	0xbe, 0x4b, 0x16, 0x33, 0x96, 0x0d, 0xed, 0x8b, 0x59, 0x7f, 0xeb, 0xf2, 0xa6, 0x73, 0xbe, 0xa9,
	0x76, 0x7a, 0x81, 0x77, 0x9b, 0x5c, 0x83, 0x66, 0x6d, 0xc4, 0xd2, 0xc9, 0xfd, 0x22, 0xc2, 0x1f,
	0x6f, 0x46, 0x53, 0x2a, 0x58, 0x6c, 0x5a, 0xb9, 0x0b, 0x66, 0x6b, 0xe9, 0xf0, 0xeb, 0xcd, 0x23,
	0x55, 0x4d, 0x04, 0x9f, 0x2c, 0x92, 0x4b, 0x33, 0x7f, 0xf2, 0x9c, 0x2c, 0x76, 0x51, 0xbb, 0x79,
	0x8d, 0x2c, 0x30, 0x21, 0x32, 0xd3, 0x6d, 0x0e, 0x42, 0x83, 0xe0, 0x9b, 0x87, 0x52, 0xa7, 0x46,
	0x23, 0x5d, 0x8d, 0xf5, 0x59, 0x19, 0x15, 0x87, 0xa6, 0xb6, 0x1a, 0x04, 0xde, 0x32, 0x94, 0x3b,
	0x45, 0x1e, 0x31, 0x91, 0x33, 0x9d, 0xc0, 0x96, 0x42, 0x97, 0x82, 0x9d, 0x91, 0x60, 0x31, 0x57,
	0xb6, 0xa4, 0x69, 0x04, 0xd9, 0x32, 0xa2, 0x22, 0x36, 0x01, 0x8d, 0x63, 0xfd, 0x2c, 0x75, 0x6a,
	0xe2, 0x18, 0x86, 0xf6, 0x29, 0x08, 0x7f, 0x15, 0x23, 0xba, 0xaa, 0x5b, 0x5c, 0x97, 0x17, 0xdd,
	0x45, 0xe2, 0x18, 0x4e, 0xa0, 0x89, 0x6d, 0x1d, 0x61, 0x08, 0x4c, 0xca, 0x8e, 0x31, 0x22, 0x07,
	0x21, 0x0c, 0x61, 0xdf, 0xfb, 0x05, 0xcf, 0x31, 0xfc, 0xba, 0x21, 0x8e, 0x41, 0xdf, 0x29, 0x95,
	0x6a, 0x54, 0x32, 0x7a, 0x88, 0x81, 0xd7, 0x0d, 0x1b, 0x02, 0xad, 0x31, 0xa6, 0xe2, 0x21, 0x57,
	0x29, 0xc3, 0x98, 0x19, 0x84, 0x0d, 0x81, 0xb9, 0x71, 0x4c, 0xf1, 0x02, 0x7c, 0x45, 0x67, 0x27,
	0x03, 0xed, 0xcc, 0x4e, 0xae, 0xf0, 0x6a, 0xdc, 0x0b, 0x2d, 0x84, 0xdc, 0xc2, 0xe5, 0x76, 0x9a,
	0x16, 0x27, 0x7b, 0x45, 0x0c, 0xde, 0xea, 0x3f, 0x85, 0xaa, 0x9b, 0x61, 0xa1, 0x1d, 0xe1, 0xf2,
	0x6d, 0x5e, 0xfa, 0xd7, 0x70, 0x5a, 0x03, 0x90, 0x87, 0xcb, 0x77, 0x19, 0x15, 0x30, 0xf3, 0xb4,
	0x0e, 0x9d, 0x9a, 0x80, 0xd0, 0xe1, 0x72, 0x54, 0x95, 0x0c, 0xa7, 0x7d, 0x9c, 0x76, 0x18, 0xbd,
	0x1b, 0xd1, 0x8f, 0x8e, 0xfc, 0x67, 0xec, 0x6e, 0x43, 0x80, 0xbd, 0x8e, 0x79, 0x79, 0x9f, 0x1d,
	0xfb, 0xcf, 0x6a, 0x7b, 0x69, 0x04, 0x5a, 0x13, 0x10, 0x0d, 0xcf, 0xe9, 0xea, 0x06, 0x63, 0xf8,
	0x8a, 0xb4, 0xed, 0xd5, 0xd7, 0xf5, 0x57, 0xb4, 0x59, 0xb8, 0x8f, 0xf1, 0x5c, 0xdd, 0xbe, 0xb9,
	0xcb, 0xa5, 0xa2, 0x79, 0xc4, 0xfc, 0xe7, 0x51, 0xc3, 0x6d, 0x12, 0xb3, 0xa3, 0x76, 0x1b, 0xf4,
	0xfa, 0x35, 0x93, 0x1d, 0x1b, 0x0a, 0xae, 0x32, 0xb2, 0x64, 0x11, 0xa7, 0xa9, 0x36, 0xc5, 0x37,
	0xf4, 0x4f, 0x0a, 0x2e, 0x07, 0x11, 0xe7, 0xe2, 0x37, 0x4e, 0x4b, 0x2e, 0x18, 0x66, 0xf8, 0x75,
	0x3c, 0xf0, 0x82, 0x59, 0x6c, 0xb1, 0xa6, 0x45, 0xce, 0x20, 0x2d, 0x7e, 0x53, 0x7b, 0x9a, 0xc5,
	0xe0, 0x43, 0xef, 0x17, 0x63, 0xff, 0x05, 0xed, 0x43, 0xef, 0x17, 0x63, 0xac, 0xa0, 0x2c, 0xa6,
	0xe9, 0x30, 0xf6, 0xbf, 0x65, 0x2a, 0xa8, 0x86, 0x60, 0xb1, 0x94, 0x1d, 0xb3, 0xd4, 0xff, 0xb6,
	0xee, 0x6f, 0x11, 0x00, 0x3b, 0x2d, 0xf2, 0x42, 0xf8, 0xdf, 0xc1, 0x5e, 0x48, 0x83, 0x3b, 0x6b,
	0x7f, 0xf8, 0x7c, 0xad, 0xf3, 0xd9, 0xe7, 0x6b, 0x9d, 0xbf, 0x7d, 0xbe, 0xd6, 0xf9, 0xd9, 0x17,
	0x6b, 0x4f, 0x7c, 0xf6, 0xc5, 0xda, 0x13, 0x7f, 0xfe, 0x62, 0xed, 0x89, 0x1f, 0xcf, 0x6f, 0x7e,
	0xbf, 0x1c, 0x8f, 0x17, 0xf0, 0xbf, 0x15, 0x6e, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x0a,
	0x5a, 0x27, 0xc5, 0x20, 0x00, 0x00,
}

func (m *DeviceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InnerVersion) > 0 {
		i -= len(m.InnerVersion)
		copy(dAtA[i:], m.InnerVersion)
		i = encodeVarintData(dAtA, i, uint64(len(m.InnerVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.BaseBand) > 0 {
		i -= len(m.BaseBand)
		copy(dAtA[i:], m.BaseBand)
		i = encodeVarintData(dAtA, i, uint64(len(m.BaseBand)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AndroidId) > 0 {
		i -= len(m.AndroidId)
		copy(dAtA[i:], m.AndroidId)
		i = encodeVarintData(dAtA, i, uint64(len(m.AndroidId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BootId) > 0 {
		i -= len(m.BootId)
		copy(dAtA[i:], m.BootId)
		i = encodeVarintData(dAtA, i, uint64(len(m.BootId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Fingerprint) > 0 {
		i -= len(m.Fingerprint)
		copy(dAtA[i:], m.Fingerprint)
		i = encodeVarintData(dAtA, i, uint64(len(m.Fingerprint)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Incremental) > 0 {
		i -= len(m.Incremental)
		copy(dAtA[i:], m.Incremental)
		i = encodeVarintData(dAtA, i, uint64(len(m.Incremental)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Codename) > 0 {
		i -= len(m.Codename)
		copy(dAtA[i:], m.Codename)
		i = encodeVarintData(dAtA, i, uint64(len(m.Codename)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProcVersion) > 0 {
		i -= len(m.ProcVersion)
		copy(dAtA[i:], m.ProcVersion)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProcVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Bootloader) > 0 {
		i -= len(m.Bootloader)
		copy(dAtA[i:], m.Bootloader)
		i = encodeVarintData(dAtA, i, uint64(len(m.Bootloader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RptConfigList) > 0 {
		for iNdEx := len(m.RptConfigList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RptConfigList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConfigSeq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigSeq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigSeq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D50ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D50ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D50ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqMutualmarkLbsshare != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqMutualmarkLbsshare))
		i--
		dAtA[i] = 0x58
		i--
		dAtA[i] = 0xb0
		i--
		dAtA[i] = 0xc8
	}
	if m.ReqKsingSwitch != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqKsingSwitch))
		i--
		dAtA[i] = 0x49
		i--
		dAtA[i] = 0xdd
		i--
		dAtA[i] = 0xc8
	}
	if m.ReqMutualmarkScore != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqMutualmarkScore))
		i--
		dAtA[i] = 0x44
		i--
		dAtA[i] = 0xec
		i--
		dAtA[i] = 0xc8
	}
	if m.ReqMutualmarkAlienation != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqMutualmarkAlienation))
		i--
		dAtA[i] = 0x31
		i--
		dAtA[i] = 0xa8
		i--
		dAtA[i] = 0xc8
	}
	if m.ReqMusicSwitch != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqMusicSwitch))
		i--
		dAtA[i] = 0x2c
		i--
		dAtA[i] = 0xb7
		i--
		dAtA[i] = 0xc8
	}
	if len(m.UinList) > 0 {
		dAtA2 := make([]byte, len(m.UinList)*10)
		var j1 int
		for _, num1 := range m.UinList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintData(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x32
	}
	if m.ReqNum != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqNum))
		i--
		dAtA[i] = 0x28
	}
	if m.StartIndex != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.StartIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.StartTime != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxPkgSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MaxPkgSize))
		i--
		dAtA[i] = 0x10
	}
	if m.Appid != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Appid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D388ReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D388ReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D388ReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		i -= len(m.Extension)
		copy(dAtA[i:], m.Extension)
		i = encodeVarintData(dAtA, i, uint64(len(m.Extension)))
		i--
		dAtA[i] = 0x3e
		i--
		dAtA[i] = 0xca
	}
	if m.CommandId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CommandId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.MsgGetPttReq) > 0 {
		for iNdEx := len(m.MsgGetPttReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgGetPttReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.MsgTryUpPttReq) > 0 {
		for iNdEx := len(m.MsgTryUpPttReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgTryUpPttReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MsgTryUpImgReq) > 0 {
		for iNdEx := len(m.MsgTryUpImgReq) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgTryUpImgReq[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Subcmd != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Subcmd))
		i--
		dAtA[i] = 0x10
	}
	if m.NetType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NetType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *D388RespBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *D388RespBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *D388RespBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MsgGetPttUrlRsp) > 0 {
		for iNdEx := len(m.MsgGetPttUrlRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgGetPttUrlRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.MsgTryUpPttRsp) > 0 {
		for iNdEx := len(m.MsgTryUpPttRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgTryUpPttRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MsgTryUpImgRsp) > 0 {
		for iNdEx := len(m.MsgTryUpImgRsp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgTryUpImgRsp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SubCmd != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SubCmd))
		i--
		dAtA[i] = 0x10
	}
	if m.ClientIp != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ClientIp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPttUrlReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPttUrlReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPttUrlReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsAuto != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.IsAuto))
		i--
		dAtA[i] = 0x78
	}
	if m.ReqTransferType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqTransferType))
		i--
		dAtA[i] = 0x70
	}
	if m.BuId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.BuId))
		i--
		dAtA[i] = 0x68
	}
	if m.Codec != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Codec))
		i--
		dAtA[i] = 0x60
	}
	if len(m.FileKey) > 0 {
		i -= len(m.FileKey)
		copy(dAtA[i:], m.FileKey)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileKey)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintData(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x4a
	}
	if m.BuType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.BuType))
		i--
		dAtA[i] = 0x40
	}
	if m.InnerIp != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.InnerIp))
		i--
		dAtA[i] = 0x38
	}
	if m.ReqPlatformType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqPlatformType))
		i--
		dAtA[i] = 0x30
	}
	if m.ReqTerm != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqTerm))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x18
	}
	if m.DstUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPttUrlRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPttUrlRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPttUrlRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StrDomain) > 0 {
		i -= len(m.StrDomain)
		copy(dAtA[i:], m.StrDomain)
		i = encodeVarintData(dAtA, i, uint64(len(m.StrDomain)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.ClientIp6) > 0 {
		i -= len(m.ClientIp6)
		copy(dAtA[i:], m.ClientIp6)
		i = encodeVarintData(dAtA, i, uint64(len(m.ClientIp6)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.AllowRetry != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AllowRetry))
		i--
		dAtA[i] = 0x60
	}
	if m.TransferType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.TransferType))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DownPara) > 0 {
		i -= len(m.DownPara)
		copy(dAtA[i:], m.DownPara)
		i = encodeVarintData(dAtA, i, uint64(len(m.DownPara)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.DownDomain) > 0 {
		i -= len(m.DownDomain)
		copy(dAtA[i:], m.DownDomain)
		i = encodeVarintData(dAtA, i, uint64(len(m.DownDomain)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Uint32DownPort) > 0 {
		dAtA4 := make([]byte, len(m.Uint32DownPort)*10)
		var j3 int
		for _, num1 := range m.Uint32DownPort {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintData(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uint32DownIp) > 0 {
		dAtA6 := make([]byte, len(m.Uint32DownIp)*10)
		var j5 int
		for _, num1 := range m.Uint32DownIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintData(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BytesDownUrl) > 0 {
		i -= len(m.BytesDownUrl)
		copy(dAtA[i:], m.BytesDownUrl)
		i = encodeVarintData(dAtA, i, uint64(len(m.BytesDownUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FailMsg) > 0 {
		i -= len(m.FailMsg)
		copy(dAtA[i:], m.FailMsg)
		i = encodeVarintData(dAtA, i, uint64(len(m.FailMsg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Result != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x12
	}
	if m.FileId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReqDataHighwayHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDataHighwayHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReqDataHighwayHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ReqExtendinfo) > 0 {
		i -= len(m.ReqExtendinfo)
		copy(dAtA[i:], m.ReqExtendinfo)
		i = encodeVarintData(dAtA, i, uint64(len(m.ReqExtendinfo)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MsgSeghead != nil {
		{
			size, err := m.MsgSeghead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MsgBasehead != nil {
		{
			size, err := m.MsgBasehead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RspDataHighwayHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspDataHighwayHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspDataHighwayHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsReset != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.IsReset))
		i--
		dAtA[i] = 0x50
	}
	if m.Range != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Range))
		i--
		dAtA[i] = 0x48
	}
	if m.Timestamp != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x40
	}
	if len(m.RspExtendinfo) > 0 {
		i -= len(m.RspExtendinfo)
		copy(dAtA[i:], m.RspExtendinfo)
		i = encodeVarintData(dAtA, i, uint64(len(m.RspExtendinfo)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Htcost != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Htcost))
		i--
		dAtA[i] = 0x30
	}
	if m.Cachecost != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Cachecost))
		i--
		dAtA[i] = 0x28
	}
	if m.AllowRetry != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AllowRetry))
		i--
		dAtA[i] = 0x20
	}
	if m.ErrorCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgSeghead != nil {
		{
			size, err := m.MsgSeghead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MsgBasehead != nil {
		{
			size, err := m.MsgBasehead.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataHighwayHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataHighwayHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataHighwayHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LocaleId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LocaleId))
		i--
		dAtA[i] = 0x50
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintData(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x4a
	}
	if m.CommandId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CommandId))
		i--
		dAtA[i] = 0x40
	}
	if m.Dataflag != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Dataflag))
		i--
		dAtA[i] = 0x38
	}
	if m.Appid != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Appid))
		i--
		dAtA[i] = 0x30
	}
	if m.RetryTimes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.RetryTimes))
		i--
		dAtA[i] = 0x28
	}
	if m.Seq != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintData(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uin) > 0 {
		i -= len(m.Uin)
		copy(dAtA[i:], m.Uin)
		i = encodeVarintData(dAtA, i, uint64(len(m.Uin)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SegHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SegHead) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SegHead) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateCacheip != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.UpdateCacheip))
		i--
		dAtA[i] = 0x60
	}
	if m.QueryTimes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.QueryTimes))
		i--
		dAtA[i] = 0x58
	}
	if m.CacheAddr != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CacheAddr))
		i--
		dAtA[i] = 0x50
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Md5) > 0 {
		i -= len(m.Md5)
		copy(dAtA[i:], m.Md5)
		i = encodeVarintData(dAtA, i, uint64(len(m.Md5)))
		i--
		dAtA[i] = 0x42
	}
	if m.Flag != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Serviceticket) > 0 {
		i -= len(m.Serviceticket)
		copy(dAtA[i:], m.Serviceticket)
		i = encodeVarintData(dAtA, i, uint64(len(m.Serviceticket)))
		i--
		dAtA[i] = 0x32
	}
	if m.Rtcode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Rtcode))
		i--
		dAtA[i] = 0x28
	}
	if m.Datalength != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Datalength))
		i--
		dAtA[i] = 0x20
	}
	if m.Dataoffset != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Dataoffset))
		i--
		dAtA[i] = 0x18
	}
	if m.Filesize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Filesize))
		i--
		dAtA[i] = 0x10
	}
	if m.Serviceid != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Serviceid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TryUpImgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryUpImgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TryUpImgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransferUrl) > 0 {
		i -= len(m.TransferUrl)
		copy(dAtA[i:], m.TransferUrl)
		i = encodeVarintData(dAtA, i, uint64(len(m.TransferUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.SrvUpload != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SrvUpload))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.DstUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DstUin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.FileIndex) > 0 {
		i -= len(m.FileIndex)
		copy(dAtA[i:], m.FileIndex)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileIndex)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.OriginalPic != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.OriginalPic))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.AppPicType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AppPicType))
		i--
		dAtA[i] = 0x78
	}
	if m.InnerIp != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.InnerIp))
		i--
		dAtA[i] = 0x70
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintData(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x6a
	}
	if m.PicType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.PicType))
		i--
		dAtA[i] = 0x60
	}
	if m.PicHeight != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.PicHeight))
		i--
		dAtA[i] = 0x58
	}
	if m.PicWidth != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.PicWidth))
		i--
		dAtA[i] = 0x50
	}
	if m.BuType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.BuType))
		i--
		dAtA[i] = 0x48
	}
	if m.PlatformType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.PlatformType))
		i--
		dAtA[i] = 0x40
	}
	if m.SrcTerm != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SrcTerm))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x32
	}
	if m.FileSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TryUpImgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryUpImgResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TryUpImgResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Fid))
		i--
		dAtA[i] = 0x48
	}
	if len(m.UpUkey) > 0 {
		i -= len(m.UpUkey)
		copy(dAtA[i:], m.UpUkey)
		i = encodeVarintData(dAtA, i, uint64(len(m.UpUkey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Uint32UpPort) > 0 {
		dAtA12 := make([]byte, len(m.Uint32UpPort)*10)
		var j11 int
		for _, num1 := range m.Uint32UpPort {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintData(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uint32UpIp) > 0 {
		dAtA14 := make([]byte, len(m.Uint32UpIp)*10)
		var j13 int
		for _, num1 := range m.Uint32UpIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintData(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x32
	}
	if m.MsgImgInfo != nil {
		{
			size, err := m.MsgImgInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BoolFileExit {
		i--
		if m.BoolFileExit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.FailMsg) > 0 {
		i -= len(m.FailMsg)
		copy(dAtA[i:], m.FailMsg)
		i = encodeVarintData(dAtA, i, uint64(len(m.FailMsg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Result != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.FileId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TryUpPttReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryUpPttReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TryUpPttReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BuId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.BuId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.VoiceType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.VoiceType))
		i--
		dAtA[i] = 0x78
	}
	if m.Codec != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Codec))
		i--
		dAtA[i] = 0x70
	}
	if m.BoolNewUpChan {
		i--
		if m.BoolNewUpChan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.VoiceLength != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.VoiceLength))
		i--
		dAtA[i] = 0x60
	}
	if m.InnerIp != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.InnerIp))
		i--
		dAtA[i] = 0x58
	}
	if len(m.BuildVer) > 0 {
		i -= len(m.BuildVer)
		copy(dAtA[i:], m.BuildVer)
		i = encodeVarintData(dAtA, i, uint64(len(m.BuildVer)))
		i--
		dAtA[i] = 0x52
	}
	if m.BuType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.BuType))
		i--
		dAtA[i] = 0x48
	}
	if m.PlatformType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.PlatformType))
		i--
		dAtA[i] = 0x40
	}
	if m.SrcTerm != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SrcTerm))
		i--
		dAtA[i] = 0x38
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x32
	}
	if m.FileSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0x22
	}
	if m.FileId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SrcUin))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TryUpPttResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TryUpPttResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TryUpPttResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChannelType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ChannelType))
		i--
		dAtA[i] = 0x60
	}
	if len(m.FileKey) > 0 {
		i -= len(m.FileKey)
		copy(dAtA[i:], m.FileKey)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileKey)))
		i--
		dAtA[i] = 0x5a
	}
	if m.BlockSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.BlockSize))
		i--
		dAtA[i] = 0x50
	}
	if m.UpOffset != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.UpOffset))
		i--
		dAtA[i] = 0x48
	}
	if m.FileId2 != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileId2))
		i--
		dAtA[i] = 0x40
	}
	if len(m.UpUkey) > 0 {
		i -= len(m.UpUkey)
		copy(dAtA[i:], m.UpUkey)
		i = encodeVarintData(dAtA, i, uint64(len(m.UpUkey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Uint32UpPort) > 0 {
		dAtA17 := make([]byte, len(m.Uint32UpPort)*10)
		var j16 int
		for _, num1 := range m.Uint32UpPort {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintData(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Uint32UpIp) > 0 {
		dAtA19 := make([]byte, len(m.Uint32UpIp)*10)
		var j18 int
		for _, num1 := range m.Uint32UpIp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintData(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x2a
	}
	if m.BoolFileExit {
		i--
		if m.BoolFileExit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.FailMsg) > 0 {
		i -= len(m.FailMsg)
		copy(dAtA[i:], m.FailMsg)
		i = encodeVarintData(dAtA, i, uint64(len(m.FailMsg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Result != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.FileId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileHeight != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.FileWidth != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileWidth))
		i--
		dAtA[i] = 0x20
	}
	if m.FileSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x18
	}
	if m.FileType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FileMd5) > 0 {
		i -= len(m.FileMd5)
		copy(dAtA[i:], m.FileMd5)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileMd5)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintData(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MsgUid != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgUid))
		i--
		dAtA[i] = 0x28
	}
	if m.MsgSeq != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgSeq))
		i--
		dAtA[i] = 0x20
	}
	if m.MsgType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x18
	}
	if m.ToUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ToUin))
		i--
		dAtA[i] = 0x10
	}
	if m.FromUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FromUin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubD4) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubD4) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubD4) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Uin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sub8A) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sub8A) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sub8A) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reserved) > 0 {
		i -= len(m.Reserved)
		copy(dAtA[i:], m.Reserved)
		i = encodeVarintData(dAtA, i, uint64(len(m.Reserved)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LongMessageFlag != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LongMessageFlag))
		i--
		dAtA[i] = 0x20
	}
	if m.InstId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.InstId))
		i--
		dAtA[i] = 0x18
	}
	if m.AppId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AppId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MsgInfo) > 0 {
		for iNdEx := len(m.MsgInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MsgInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Sub8AMsgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sub8AMsgInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sub8AMsgInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DevSeq != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DevSeq))
		i--
		dAtA[i] = 0x48
	}
	if m.PkgIndex != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.PkgIndex))
		i--
		dAtA[i] = 0x40
	}
	if m.PkgNum != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.PkgNum))
		i--
		dAtA[i] = 0x38
	}
	if m.MsgRandom != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgRandom))
		i--
		dAtA[i] = 0x30
	}
	if m.MsgTime != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgTime))
		i--
		dAtA[i] = 0x28
	}
	if m.MsgUid != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgUid))
		i--
		dAtA[i] = 0x20
	}
	if m.MsgSeq != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgSeq))
		i--
		dAtA[i] = 0x18
	}
	if m.ToUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ToUin))
		i--
		dAtA[i] = 0x10
	}
	if m.FromUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FromUin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubB3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubB3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubB3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgAddFrdNotify != nil {
		{
			size, err := m.MsgAddFrdNotify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SubB3AddFrdNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubB3AddFrdNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubB3AddFrdNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nick) > 0 {
		i -= len(m.Nick)
		copy(dAtA[i:], m.Nick)
		i = encodeVarintData(dAtA, i, uint64(len(m.Nick)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Uin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sub44) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sub44) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sub44) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupSyncMsg != nil {
		{
			size, err := m.GroupSyncMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.FriendSyncMsg != nil {
		{
			size, err := m.FriendSyncMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Sub44FriendSyncMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sub44FriendSyncMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sub44FriendSyncMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StrWording) > 0 {
		for iNdEx := len(m.StrWording) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StrWording[iNdEx])
			copy(dAtA[i:], m.StrWording[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.StrWording[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.SourceSubId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SourceSubId))
		i--
		dAtA[i] = 0x38
	}
	if m.SourceId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SourceId))
		i--
		dAtA[i] = 0x30
	}
	if m.ProcessFlag != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ProcessFlag))
		i--
		dAtA[i] = 0x28
	}
	if m.Time != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x20
	}
	if m.ProcessType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ProcessType))
		i--
		dAtA[i] = 0x18
	}
	if m.FUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.FUin))
		i--
		dAtA[i] = 0x10
	}
	if m.Uin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sub44GroupSyncMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sub44GroupSyncMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sub44GroupSyncMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProcessFlag != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ProcessFlag))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.ExtAdminNum != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ExtAdminNum))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.InviterRole != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.InviterRole))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.ReqSrcSubId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqSrcSubId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.ReqSrcId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReqSrcId))
		i--
		dAtA[i] = 0x78
	}
	if m.CurMemCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CurMemCount))
		i--
		dAtA[i] = 0x70
	}
	if m.NextMaxMemCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NextMaxMemCount))
		i--
		dAtA[i] = 0x68
	}
	if m.CurMaxMemCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CurMaxMemCount))
		i--
		dAtA[i] = 0x60
	}
	if m.ActionTime != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ActionTime))
		i--
		dAtA[i] = 0x58
	}
	if m.ActionUin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ActionUin))
		i--
		dAtA[i] = 0x50
	}
	if m.MsgStatus != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgStatus))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AuthKey) > 0 {
		i -= len(m.AuthKey)
		copy(dAtA[i:], m.AuthKey)
		i = encodeVarintData(dAtA, i, uint64(len(m.AuthKey)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.MsgBuf) > 0 {
		i -= len(m.MsgBuf)
		copy(dAtA[i:], m.MsgBuf)
		i = encodeVarintData(dAtA, i, uint64(len(m.MsgBuf)))
		i--
		dAtA[i] = 0x3a
	}
	if m.OptUin2 != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.OptUin2))
		i--
		dAtA[i] = 0x30
	}
	if m.OptUin1 != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.OptUin1))
		i--
		dAtA[i] = 0x28
	}
	if m.GaCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GaCode))
		i--
		dAtA[i] = 0x20
	}
	if m.GrpCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GrpCode))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgSeq != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgSeq))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupMemberReqBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMemberReqBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMemberReqBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RichCardNameVer != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.RichCardNameVer))
		i--
		dAtA[i] = 0x28
	}
	if m.ClientType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ClientType))
		i--
		dAtA[i] = 0x20
	}
	if m.NewClient {
		i--
		if m.NewClient {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Uin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupMemberRspBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMemberRspBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMemberRspBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GroupType))
		i--
		dAtA[i] = 0x28
	}
	if m.BoolSelfLocationShared {
		i--
		if m.BoolSelfLocationShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MemInfo != nil {
		{
			size, err := m.MemInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SelfRole != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SelfRole))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupCode != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GroupCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupMemberInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMemberInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMemberInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Honor) > 0 {
		i -= len(m.Honor)
		copy(dAtA[i:], m.Honor)
		i = encodeVarintData(dAtA, i, uint64(len(m.Honor)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.Level != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.MedalId != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MedalId))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Job) > 0 {
		i -= len(m.Job)
		copy(dAtA[i:], m.Job)
		i = encodeVarintData(dAtA, i, uint64(len(m.Job)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if len(m.PhoneNum) > 0 {
		i -= len(m.PhoneNum)
		copy(dAtA[i:], m.PhoneNum)
		i = encodeVarintData(dAtA, i, uint64(len(m.PhoneNum)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.SpecialTitleExpireTime != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.SpecialTitleExpireTime))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if len(m.SpecialTitle) > 0 {
		i -= len(m.SpecialTitle)
		copy(dAtA[i:], m.SpecialTitle)
		i = encodeVarintData(dAtA, i, uint64(len(m.SpecialTitle)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.ConcernType != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ConcernType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Int64Distance != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Int64Distance))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.LocationShared {
		i--
		if m.LocationShared {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.Role != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.VipLev != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.VipLev))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.IsSuperQq {
		i--
		if m.IsSuperQq {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.IsSuperVip {
		i--
		if m.IsSuperVip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.IsYearVip {
		i--
		if m.IsYearVip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.IsVip {
		i--
		if m.IsVip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.IsAllowModCard {
		i--
		if m.IsAllowModCard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.GbarCnt != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.GbarCnt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.GbarUrl) > 0 {
		i -= len(m.GbarUrl)
		copy(dAtA[i:], m.GbarUrl)
		i = encodeVarintData(dAtA, i, uint64(len(m.GbarUrl)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.GbarTitle) > 0 {
		i -= len(m.GbarTitle)
		copy(dAtA[i:], m.GbarTitle)
		i = encodeVarintData(dAtA, i, uint64(len(m.GbarTitle)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.LastSpeak != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LastSpeak))
		i--
		dAtA[i] = 0x78
	}
	if m.Join != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Join))
		i--
		dAtA[i] = 0x70
	}
	if len(m.Lev) > 0 {
		i -= len(m.Lev)
		copy(dAtA[i:], m.Lev)
		i = encodeVarintData(dAtA, i, uint64(len(m.Lev)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Age != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Age))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Nick) > 0 {
		i -= len(m.Nick)
		copy(dAtA[i:], m.Nick)
		i = encodeVarintData(dAtA, i, uint64(len(m.Nick)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintData(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x52
	}
	if m.Sex != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Sex))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Card) > 0 {
		i -= len(m.Card)
		copy(dAtA[i:], m.Card)
		i = encodeVarintData(dAtA, i, uint64(len(m.Card)))
		i--
		dAtA[i] = 0x42
	}
	if m.Credit != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Credit))
		i--
		dAtA[i] = 0x38
	}
	if m.IsConcerned {
		i--
		if m.IsConcerned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Remark) > 0 {
		i -= len(m.Remark)
		copy(dAtA[i:], m.Remark)
		i = encodeVarintData(dAtA, i, uint64(len(m.Remark)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsFriend {
		i--
		if m.IsFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Errmsg) > 0 {
		i -= len(m.Errmsg)
		copy(dAtA[i:], m.Errmsg)
		i = encodeVarintData(dAtA, i, uint64(len(m.Errmsg)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Result != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.Uin != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Uin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	offset -= sovData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DeviceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Bootloader)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.ProcVersion)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Codename)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Incremental)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Fingerprint)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.BootId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.AndroidId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.BaseBand)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.InnerVersion)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *RequestBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RptConfigList) > 0 {
		for _, e := range m.RptConfigList {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *ConfigSeq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovData(uint64(m.Type))
	}
	if m.Version != 0 {
		n += 1 + sovData(uint64(m.Version))
	}
	return n
}

func (m *D50ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Appid != 0 {
		n += 1 + sovData(uint64(m.Appid))
	}
	if m.MaxPkgSize != 0 {
		n += 1 + sovData(uint64(m.MaxPkgSize))
	}
	if m.StartTime != 0 {
		n += 1 + sovData(uint64(m.StartTime))
	}
	if m.StartIndex != 0 {
		n += 1 + sovData(uint64(m.StartIndex))
	}
	if m.ReqNum != 0 {
		n += 1 + sovData(uint64(m.ReqNum))
	}
	if len(m.UinList) > 0 {
		l = 0
		for _, e := range m.UinList {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if m.ReqMusicSwitch != 0 {
		n += 3 + sovData(uint64(m.ReqMusicSwitch))
	}
	if m.ReqMutualmarkAlienation != 0 {
		n += 3 + sovData(uint64(m.ReqMutualmarkAlienation))
	}
	if m.ReqMutualmarkScore != 0 {
		n += 3 + sovData(uint64(m.ReqMutualmarkScore))
	}
	if m.ReqKsingSwitch != 0 {
		n += 3 + sovData(uint64(m.ReqKsingSwitch))
	}
	if m.ReqMutualmarkLbsshare != 0 {
		n += 3 + sovData(uint64(m.ReqMutualmarkLbsshare))
	}
	return n
}

func (m *D388ReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NetType != 0 {
		n += 1 + sovData(uint64(m.NetType))
	}
	if m.Subcmd != 0 {
		n += 1 + sovData(uint64(m.Subcmd))
	}
	if len(m.MsgTryUpImgReq) > 0 {
		for _, e := range m.MsgTryUpImgReq {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.MsgTryUpPttReq) > 0 {
		for _, e := range m.MsgTryUpPttReq {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.MsgGetPttReq) > 0 {
		for _, e := range m.MsgGetPttReq {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.CommandId != 0 {
		n += 1 + sovData(uint64(m.CommandId))
	}
	l = len(m.Extension)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	return n
}

func (m *D388RespBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientIp != 0 {
		n += 1 + sovData(uint64(m.ClientIp))
	}
	if m.SubCmd != 0 {
		n += 1 + sovData(uint64(m.SubCmd))
	}
	if len(m.MsgTryUpImgRsp) > 0 {
		for _, e := range m.MsgTryUpImgRsp {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.MsgTryUpPttRsp) > 0 {
		for _, e := range m.MsgTryUpPttRsp {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.MsgGetPttUrlRsp) > 0 {
		for _, e := range m.MsgGetPttUrlRsp {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *GetPttUrlReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupCode != 0 {
		n += 1 + sovData(uint64(m.GroupCode))
	}
	if m.DstUin != 0 {
		n += 1 + sovData(uint64(m.DstUin))
	}
	if m.FileId != 0 {
		n += 1 + sovData(uint64(m.FileId))
	}
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.ReqTerm != 0 {
		n += 1 + sovData(uint64(m.ReqTerm))
	}
	if m.ReqPlatformType != 0 {
		n += 1 + sovData(uint64(m.ReqPlatformType))
	}
	if m.InnerIp != 0 {
		n += 1 + sovData(uint64(m.InnerIp))
	}
	if m.BuType != 0 {
		n += 1 + sovData(uint64(m.BuType))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.FileKey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Codec != 0 {
		n += 1 + sovData(uint64(m.Codec))
	}
	if m.BuId != 0 {
		n += 1 + sovData(uint64(m.BuId))
	}
	if m.ReqTransferType != 0 {
		n += 1 + sovData(uint64(m.ReqTransferType))
	}
	if m.IsAuto != 0 {
		n += 1 + sovData(uint64(m.IsAuto))
	}
	return n
}

func (m *GetPttUrlRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovData(uint64(m.FileId))
	}
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovData(uint64(m.Result))
	}
	l = len(m.FailMsg)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.BytesDownUrl)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Uint32DownIp) > 0 {
		l = 0
		for _, e := range m.Uint32DownIp {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if len(m.Uint32DownPort) > 0 {
		l = 0
		for _, e := range m.Uint32DownPort {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	l = len(m.DownDomain)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.DownPara)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.TransferType != 0 {
		n += 1 + sovData(uint64(m.TransferType))
	}
	if m.AllowRetry != 0 {
		n += 1 + sovData(uint64(m.AllowRetry))
	}
	l = len(m.ClientIp6)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.StrDomain)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	return n
}

func (m *ReqDataHighwayHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgBasehead != nil {
		l = m.MsgBasehead.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.MsgSeghead != nil {
		l = m.MsgSeghead.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.ReqExtendinfo)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovData(uint64(m.Timestamp))
	}
	return n
}

func (m *RspDataHighwayHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgBasehead != nil {
		l = m.MsgBasehead.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.MsgSeghead != nil {
		l = m.MsgSeghead.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovData(uint64(m.ErrorCode))
	}
	if m.AllowRetry != 0 {
		n += 1 + sovData(uint64(m.AllowRetry))
	}
	if m.Cachecost != 0 {
		n += 1 + sovData(uint64(m.Cachecost))
	}
	if m.Htcost != 0 {
		n += 1 + sovData(uint64(m.Htcost))
	}
	l = len(m.RspExtendinfo)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovData(uint64(m.Timestamp))
	}
	if m.Range != 0 {
		n += 1 + sovData(uint64(m.Range))
	}
	if m.IsReset != 0 {
		n += 1 + sovData(uint64(m.IsReset))
	}
	return n
}

func (m *DataHighwayHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovData(uint64(m.Version))
	}
	l = len(m.Uin)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovData(uint64(m.Seq))
	}
	if m.RetryTimes != 0 {
		n += 1 + sovData(uint64(m.RetryTimes))
	}
	if m.Appid != 0 {
		n += 1 + sovData(uint64(m.Appid))
	}
	if m.Dataflag != 0 {
		n += 1 + sovData(uint64(m.Dataflag))
	}
	if m.CommandId != 0 {
		n += 1 + sovData(uint64(m.CommandId))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.LocaleId != 0 {
		n += 1 + sovData(uint64(m.LocaleId))
	}
	return n
}

func (m *SegHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Serviceid != 0 {
		n += 1 + sovData(uint64(m.Serviceid))
	}
	if m.Filesize != 0 {
		n += 1 + sovData(uint64(m.Filesize))
	}
	if m.Dataoffset != 0 {
		n += 1 + sovData(uint64(m.Dataoffset))
	}
	if m.Datalength != 0 {
		n += 1 + sovData(uint64(m.Datalength))
	}
	if m.Rtcode != 0 {
		n += 1 + sovData(uint64(m.Rtcode))
	}
	l = len(m.Serviceticket)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Flag != 0 {
		n += 1 + sovData(uint64(m.Flag))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.CacheAddr != 0 {
		n += 1 + sovData(uint64(m.CacheAddr))
	}
	if m.QueryTimes != 0 {
		n += 1 + sovData(uint64(m.QueryTimes))
	}
	if m.UpdateCacheip != 0 {
		n += 1 + sovData(uint64(m.UpdateCacheip))
	}
	return n
}

func (m *TryUpImgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupCode != 0 {
		n += 1 + sovData(uint64(m.GroupCode))
	}
	if m.SrcUin != 0 {
		n += 1 + sovData(uint64(m.SrcUin))
	}
	if m.FileId != 0 {
		n += 1 + sovData(uint64(m.FileId))
	}
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovData(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.SrcTerm != 0 {
		n += 1 + sovData(uint64(m.SrcTerm))
	}
	if m.PlatformType != 0 {
		n += 1 + sovData(uint64(m.PlatformType))
	}
	if m.BuType != 0 {
		n += 1 + sovData(uint64(m.BuType))
	}
	if m.PicWidth != 0 {
		n += 1 + sovData(uint64(m.PicWidth))
	}
	if m.PicHeight != 0 {
		n += 1 + sovData(uint64(m.PicHeight))
	}
	if m.PicType != 0 {
		n += 1 + sovData(uint64(m.PicType))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.InnerIp != 0 {
		n += 1 + sovData(uint64(m.InnerIp))
	}
	if m.AppPicType != 0 {
		n += 1 + sovData(uint64(m.AppPicType))
	}
	if m.OriginalPic != 0 {
		n += 2 + sovData(uint64(m.OriginalPic))
	}
	l = len(m.FileIndex)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.DstUin != 0 {
		n += 2 + sovData(uint64(m.DstUin))
	}
	if m.SrvUpload != 0 {
		n += 2 + sovData(uint64(m.SrvUpload))
	}
	l = len(m.TransferUrl)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	return n
}

func (m *TryUpImgResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovData(uint64(m.FileId))
	}
	if m.Result != 0 {
		n += 1 + sovData(uint64(m.Result))
	}
	l = len(m.FailMsg)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.BoolFileExit {
		n += 2
	}
	if m.MsgImgInfo != nil {
		l = m.MsgImgInfo.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Uint32UpIp) > 0 {
		l = 0
		for _, e := range m.Uint32UpIp {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if len(m.Uint32UpPort) > 0 {
		l = 0
		for _, e := range m.Uint32UpPort {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	l = len(m.UpUkey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Fid != 0 {
		n += 1 + sovData(uint64(m.Fid))
	}
	return n
}

func (m *TryUpPttReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupCode != 0 {
		n += 1 + sovData(uint64(m.GroupCode))
	}
	if m.SrcUin != 0 {
		n += 1 + sovData(uint64(m.SrcUin))
	}
	if m.FileId != 0 {
		n += 1 + sovData(uint64(m.FileId))
	}
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovData(uint64(m.FileSize))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.SrcTerm != 0 {
		n += 1 + sovData(uint64(m.SrcTerm))
	}
	if m.PlatformType != 0 {
		n += 1 + sovData(uint64(m.PlatformType))
	}
	if m.BuType != 0 {
		n += 1 + sovData(uint64(m.BuType))
	}
	l = len(m.BuildVer)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.InnerIp != 0 {
		n += 1 + sovData(uint64(m.InnerIp))
	}
	if m.VoiceLength != 0 {
		n += 1 + sovData(uint64(m.VoiceLength))
	}
	if m.BoolNewUpChan {
		n += 2
	}
	if m.Codec != 0 {
		n += 1 + sovData(uint64(m.Codec))
	}
	if m.VoiceType != 0 {
		n += 1 + sovData(uint64(m.VoiceType))
	}
	if m.BuId != 0 {
		n += 2 + sovData(uint64(m.BuId))
	}
	return n
}

func (m *TryUpPttResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovData(uint64(m.FileId))
	}
	if m.Result != 0 {
		n += 1 + sovData(uint64(m.Result))
	}
	l = len(m.FailMsg)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.BoolFileExit {
		n += 2
	}
	if len(m.Uint32UpIp) > 0 {
		l = 0
		for _, e := range m.Uint32UpIp {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if len(m.Uint32UpPort) > 0 {
		l = 0
		for _, e := range m.Uint32UpPort {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	l = len(m.UpUkey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.FileId2 != 0 {
		n += 1 + sovData(uint64(m.FileId2))
	}
	if m.UpOffset != 0 {
		n += 1 + sovData(uint64(m.UpOffset))
	}
	if m.BlockSize != 0 {
		n += 1 + sovData(uint64(m.BlockSize))
	}
	l = len(m.FileKey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.ChannelType != 0 {
		n += 1 + sovData(uint64(m.ChannelType))
	}
	return n
}

func (m *ImgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileMd5)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.FileType != 0 {
		n += 1 + sovData(uint64(m.FileType))
	}
	if m.FileSize != 0 {
		n += 1 + sovData(uint64(m.FileSize))
	}
	if m.FileWidth != 0 {
		n += 1 + sovData(uint64(m.FileWidth))
	}
	if m.FileHeight != 0 {
		n += 1 + sovData(uint64(m.FileHeight))
	}
	return n
}

func (m *DeleteMessageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *MessageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FromUin != 0 {
		n += 1 + sovData(uint64(m.FromUin))
	}
	if m.ToUin != 0 {
		n += 1 + sovData(uint64(m.ToUin))
	}
	if m.MsgType != 0 {
		n += 1 + sovData(uint64(m.MsgType))
	}
	if m.MsgSeq != 0 {
		n += 1 + sovData(uint64(m.MsgSeq))
	}
	if m.MsgUid != 0 {
		n += 1 + sovData(uint64(m.MsgUid))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *SubD4) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovData(uint64(m.Uin))
	}
	return n
}

func (m *Sub8A) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MsgInfo) > 0 {
		for _, e := range m.MsgInfo {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.AppId != 0 {
		n += 1 + sovData(uint64(m.AppId))
	}
	if m.InstId != 0 {
		n += 1 + sovData(uint64(m.InstId))
	}
	if m.LongMessageFlag != 0 {
		n += 1 + sovData(uint64(m.LongMessageFlag))
	}
	l = len(m.Reserved)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Sub8AMsgInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FromUin != 0 {
		n += 1 + sovData(uint64(m.FromUin))
	}
	if m.ToUin != 0 {
		n += 1 + sovData(uint64(m.ToUin))
	}
	if m.MsgSeq != 0 {
		n += 1 + sovData(uint64(m.MsgSeq))
	}
	if m.MsgUid != 0 {
		n += 1 + sovData(uint64(m.MsgUid))
	}
	if m.MsgTime != 0 {
		n += 1 + sovData(uint64(m.MsgTime))
	}
	if m.MsgRandom != 0 {
		n += 1 + sovData(uint64(m.MsgRandom))
	}
	if m.PkgNum != 0 {
		n += 1 + sovData(uint64(m.PkgNum))
	}
	if m.PkgIndex != 0 {
		n += 1 + sovData(uint64(m.PkgIndex))
	}
	if m.DevSeq != 0 {
		n += 1 + sovData(uint64(m.DevSeq))
	}
	return n
}

func (m *SubB3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovData(uint64(m.Type))
	}
	if m.MsgAddFrdNotify != nil {
		l = m.MsgAddFrdNotify.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *SubB3AddFrdNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovData(uint64(m.Uin))
	}
	l = len(m.Nick)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Sub44) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FriendSyncMsg != nil {
		l = m.FriendSyncMsg.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.GroupSyncMsg != nil {
		l = m.GroupSyncMsg.Size()
		n += 1 + l + sovData(uint64(l))
	}
	return n
}

func (m *Sub44FriendSyncMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovData(uint64(m.Uin))
	}
	if m.FUin != 0 {
		n += 1 + sovData(uint64(m.FUin))
	}
	if m.ProcessType != 0 {
		n += 1 + sovData(uint64(m.ProcessType))
	}
	if m.Time != 0 {
		n += 1 + sovData(uint64(m.Time))
	}
	if m.ProcessFlag != 0 {
		n += 1 + sovData(uint64(m.ProcessFlag))
	}
	if m.SourceId != 0 {
		n += 1 + sovData(uint64(m.SourceId))
	}
	if m.SourceSubId != 0 {
		n += 1 + sovData(uint64(m.SourceSubId))
	}
	if len(m.StrWording) > 0 {
		for _, s := range m.StrWording {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	return n
}

func (m *Sub44GroupSyncMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgType != 0 {
		n += 1 + sovData(uint64(m.MsgType))
	}
	if m.MsgSeq != 0 {
		n += 1 + sovData(uint64(m.MsgSeq))
	}
	if m.GrpCode != 0 {
		n += 1 + sovData(uint64(m.GrpCode))
	}
	if m.GaCode != 0 {
		n += 1 + sovData(uint64(m.GaCode))
	}
	if m.OptUin1 != 0 {
		n += 1 + sovData(uint64(m.OptUin1))
	}
	if m.OptUin2 != 0 {
		n += 1 + sovData(uint64(m.OptUin2))
	}
	l = len(m.MsgBuf)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.MsgStatus != 0 {
		n += 1 + sovData(uint64(m.MsgStatus))
	}
	if m.ActionUin != 0 {
		n += 1 + sovData(uint64(m.ActionUin))
	}
	if m.ActionTime != 0 {
		n += 1 + sovData(uint64(m.ActionTime))
	}
	if m.CurMaxMemCount != 0 {
		n += 1 + sovData(uint64(m.CurMaxMemCount))
	}
	if m.NextMaxMemCount != 0 {
		n += 1 + sovData(uint64(m.NextMaxMemCount))
	}
	if m.CurMemCount != 0 {
		n += 1 + sovData(uint64(m.CurMemCount))
	}
	if m.ReqSrcId != 0 {
		n += 1 + sovData(uint64(m.ReqSrcId))
	}
	if m.ReqSrcSubId != 0 {
		n += 2 + sovData(uint64(m.ReqSrcSubId))
	}
	if m.InviterRole != 0 {
		n += 2 + sovData(uint64(m.InviterRole))
	}
	if m.ExtAdminNum != 0 {
		n += 2 + sovData(uint64(m.ExtAdminNum))
	}
	if m.ProcessFlag != 0 {
		n += 2 + sovData(uint64(m.ProcessFlag))
	}
	return n
}

func (m *GroupMemberReqBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupCode != 0 {
		n += 1 + sovData(uint64(m.GroupCode))
	}
	if m.Uin != 0 {
		n += 1 + sovData(uint64(m.Uin))
	}
	if m.NewClient {
		n += 2
	}
	if m.ClientType != 0 {
		n += 1 + sovData(uint64(m.ClientType))
	}
	if m.RichCardNameVer != 0 {
		n += 1 + sovData(uint64(m.RichCardNameVer))
	}
	return n
}

func (m *GroupMemberRspBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupCode != 0 {
		n += 1 + sovData(uint64(m.GroupCode))
	}
	if m.SelfRole != 0 {
		n += 1 + sovData(uint64(m.SelfRole))
	}
	if m.MemInfo != nil {
		l = m.MemInfo.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.BoolSelfLocationShared {
		n += 2
	}
	if m.GroupType != 0 {
		n += 1 + sovData(uint64(m.GroupType))
	}
	return n
}

func (m *GroupMemberInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uin != 0 {
		n += 1 + sovData(uint64(m.Uin))
	}
	if m.Result != 0 {
		n += 1 + sovData(uint64(m.Result))
	}
	l = len(m.Errmsg)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.IsFriend {
		n += 2
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.IsConcerned {
		n += 2
	}
	if m.Credit != 0 {
		n += 1 + sovData(uint64(m.Credit))
	}
	l = len(m.Card)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovData(uint64(m.Sex))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Nick)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Age != 0 {
		n += 1 + sovData(uint64(m.Age))
	}
	l = len(m.Lev)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Join != 0 {
		n += 1 + sovData(uint64(m.Join))
	}
	if m.LastSpeak != 0 {
		n += 1 + sovData(uint64(m.LastSpeak))
	}
	l = len(m.GbarTitle)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.GbarUrl)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.GbarCnt != 0 {
		n += 2 + sovData(uint64(m.GbarCnt))
	}
	if m.IsAllowModCard {
		n += 3
	}
	if m.IsVip {
		n += 3
	}
	if m.IsYearVip {
		n += 3
	}
	if m.IsSuperVip {
		n += 3
	}
	if m.IsSuperQq {
		n += 3
	}
	if m.VipLev != 0 {
		n += 2 + sovData(uint64(m.VipLev))
	}
	if m.Role != 0 {
		n += 2 + sovData(uint64(m.Role))
	}
	if m.LocationShared {
		n += 3
	}
	if m.Int64Distance != 0 {
		n += 2 + sovData(uint64(m.Int64Distance))
	}
	if m.ConcernType != 0 {
		n += 2 + sovData(uint64(m.ConcernType))
	}
	l = len(m.SpecialTitle)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.SpecialTitleExpireTime != 0 {
		n += 2 + sovData(uint64(m.SpecialTitleExpireTime))
	}
	l = len(m.PhoneNum)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.Job)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.MedalId != 0 {
		n += 2 + sovData(uint64(m.MedalId))
	}
	if m.Level != 0 {
		n += 2 + sovData(uint64(m.Level))
	}
	l = len(m.Honor)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	return n
}

func sovData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DeviceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootloader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bootloader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Incremental = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BootId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseBand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseBand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InnerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RptConfigList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RptConfigList = append(m.RptConfigList, &ConfigSeq{})
			if err := m.RptConfigList[len(m.RptConfigList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigSeq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigSeq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigSeq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D50ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D50ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D50ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPkgSize", wireType)
			}
			m.MaxPkgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPkgSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartIndex", wireType)
			}
			m.StartIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqNum", wireType)
			}
			m.ReqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UinList = append(m.UinList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UinList) == 0 {
					m.UinList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UinList = append(m.UinList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UinList", wireType)
			}
		case 91001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMusicSwitch", wireType)
			}
			m.ReqMusicSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMusicSwitch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMutualmarkAlienation", wireType)
			}
			m.ReqMutualmarkAlienation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMutualmarkAlienation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 141001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMutualmarkScore", wireType)
			}
			m.ReqMutualmarkScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMutualmarkScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 151001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqKsingSwitch", wireType)
			}
			m.ReqKsingSwitch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqKsingSwitch |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 181001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMutualmarkLbsshare", wireType)
			}
			m.ReqMutualmarkLbsshare = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMutualmarkLbsshare |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D388ReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D388ReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D388ReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetType", wireType)
			}
			m.NetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subcmd", wireType)
			}
			m.Subcmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subcmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTryUpImgReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTryUpImgReq = append(m.MsgTryUpImgReq, &TryUpImgReq{})
			if err := m.MsgTryUpImgReq[len(m.MsgTryUpImgReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTryUpPttReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTryUpPttReq = append(m.MsgTryUpPttReq, &TryUpPttReq{})
			if err := m.MsgTryUpPttReq[len(m.MsgTryUpPttReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgGetPttReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgGetPttReq = append(m.MsgGetPttReq, &GetPttUrlReq{})
			if err := m.MsgGetPttReq[len(m.MsgGetPttReq)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandId", wireType)
			}
			m.CommandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommandId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 1001:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension[:0], dAtA[iNdEx:postIndex]...)
			if m.Extension == nil {
				m.Extension = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *D388RespBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: D388RespBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: D388RespBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			m.ClientIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCmd", wireType)
			}
			m.SubCmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTryUpImgRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTryUpImgRsp = append(m.MsgTryUpImgRsp, &TryUpImgResp{})
			if err := m.MsgTryUpImgRsp[len(m.MsgTryUpImgRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTryUpPttRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTryUpPttRsp = append(m.MsgTryUpPttRsp, &TryUpPttResp{})
			if err := m.MsgTryUpPttRsp[len(m.MsgTryUpPttRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgGetPttUrlRsp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgGetPttUrlRsp = append(m.MsgGetPttUrlRsp, &GetPttUrlRsp{})
			if err := m.MsgGetPttUrlRsp[len(m.MsgGetPttUrlRsp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPttUrlReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPttUrlReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPttUrlReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqTerm", wireType)
			}
			m.ReqTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqTerm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqPlatformType", wireType)
			}
			m.ReqPlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqPlatformType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIp", wireType)
			}
			m.InnerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuType", wireType)
			}
			m.BuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = append(m.BuildVer[:0], dAtA[iNdEx:postIndex]...)
			if m.BuildVer == nil {
				m.BuildVer = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileKey = append(m.FileKey[:0], dAtA[iNdEx:postIndex]...)
			if m.FileKey == nil {
				m.FileKey = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			m.Codec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuId", wireType)
			}
			m.BuId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqTransferType", wireType)
			}
			m.ReqTransferType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqTransferType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAuto", wireType)
			}
			m.IsAuto = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsAuto |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPttUrlRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPttUrlRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPttUrlRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailMsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailMsg = append(m.FailMsg[:0], dAtA[iNdEx:postIndex]...)
			if m.FailMsg == nil {
				m.FailMsg = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesDownUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesDownUrl = append(m.BytesDownUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesDownUrl == nil {
				m.BytesDownUrl = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32DownIp = append(m.Uint32DownIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32DownIp) == 0 {
					m.Uint32DownIp = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32DownIp = append(m.Uint32DownIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32DownIp", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32DownPort = append(m.Uint32DownPort, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32DownPort) == 0 {
					m.Uint32DownPort = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32DownPort = append(m.Uint32DownPort, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32DownPort", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownDomain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownDomain = append(m.DownDomain[:0], dAtA[iNdEx:postIndex]...)
			if m.DownDomain == nil {
				m.DownDomain = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPara", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPara = append(m.DownPara[:0], dAtA[iNdEx:postIndex]...)
			if m.DownPara == nil {
				m.DownPara = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferType", wireType)
			}
			m.TransferType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowRetry", wireType)
			}
			m.AllowRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowRetry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp6", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp6 = append(m.ClientIp6[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientIp6 == nil {
				m.ClientIp6 = []byte{}
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrDomain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StrDomain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDataHighwayHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDataHighwayHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDataHighwayHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgBasehead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgBasehead == nil {
				m.MsgBasehead = &DataHighwayHead{}
			}
			if err := m.MsgBasehead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeghead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgSeghead == nil {
				m.MsgSeghead = &SegHead{}
			}
			if err := m.MsgSeghead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqExtendinfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqExtendinfo = append(m.ReqExtendinfo[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqExtendinfo == nil {
				m.ReqExtendinfo = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspDataHighwayHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspDataHighwayHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspDataHighwayHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgBasehead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgBasehead == nil {
				m.MsgBasehead = &DataHighwayHead{}
			}
			if err := m.MsgBasehead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeghead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgSeghead == nil {
				m.MsgSeghead = &SegHead{}
			}
			if err := m.MsgSeghead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowRetry", wireType)
			}
			m.AllowRetry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllowRetry |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cachecost", wireType)
			}
			m.Cachecost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cachecost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Htcost", wireType)
			}
			m.Htcost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Htcost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspExtendinfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RspExtendinfo = append(m.RspExtendinfo[:0], dAtA[iNdEx:postIndex]...)
			if m.RspExtendinfo == nil {
				m.RspExtendinfo = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			m.Range = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Range |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReset", wireType)
			}
			m.IsReset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsReset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataHighwayHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataHighwayHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataHighwayHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryTimes", wireType)
			}
			m.RetryTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Appid", wireType)
			}
			m.Appid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Appid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataflag", wireType)
			}
			m.Dataflag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dataflag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandId", wireType)
			}
			m.CommandId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommandId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocaleId", wireType)
			}
			m.LocaleId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocaleId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SegHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SegHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SegHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serviceid", wireType)
			}
			m.Serviceid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Serviceid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filesize", wireType)
			}
			m.Filesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filesize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dataoffset", wireType)
			}
			m.Dataoffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dataoffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datalength", wireType)
			}
			m.Datalength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Datalength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtcode", wireType)
			}
			m.Rtcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtcode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serviceticket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serviceticket = append(m.Serviceticket[:0], dAtA[iNdEx:postIndex]...)
			if m.Serviceticket == nil {
				m.Serviceticket = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = append(m.Md5[:0], dAtA[iNdEx:postIndex]...)
			if m.Md5 == nil {
				m.Md5 = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheAddr", wireType)
			}
			m.CacheAddr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CacheAddr |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryTimes", wireType)
			}
			m.QueryTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCacheip", wireType)
			}
			m.UpdateCacheip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateCacheip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryUpImgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryUpImgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryUpImgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTerm", wireType)
			}
			m.SrcTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcTerm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuType", wireType)
			}
			m.BuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicWidth", wireType)
			}
			m.PicWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicHeight", wireType)
			}
			m.PicHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PicType", wireType)
			}
			m.PicType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PicType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIp", wireType)
			}
			m.InnerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppPicType", wireType)
			}
			m.AppPicType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppPicType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalPic", wireType)
			}
			m.OriginalPic = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginalPic |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileIndex = append(m.FileIndex[:0], dAtA[iNdEx:postIndex]...)
			if m.FileIndex == nil {
				m.FileIndex = []byte{}
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUin", wireType)
			}
			m.DstUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvUpload", wireType)
			}
			m.SrvUpload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrvUpload |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferUrl = append(m.TransferUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.TransferUrl == nil {
				m.TransferUrl = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryUpImgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryUpImgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryUpImgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolFileExit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolFileExit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgImgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgImgInfo == nil {
				m.MsgImgInfo = &ImgInfo{}
			}
			if err := m.MsgImgInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpIp = append(m.Uint32UpIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpIp) == 0 {
					m.Uint32UpIp = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpIp = append(m.Uint32UpIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpIp", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpPort = append(m.Uint32UpPort, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpPort) == 0 {
					m.Uint32UpPort = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpPort = append(m.Uint32UpPort, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpPort", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpUkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpUkey = append(m.UpUkey[:0], dAtA[iNdEx:postIndex]...)
			if m.UpUkey == nil {
				m.UpUkey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryUpPttReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryUpPttReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryUpPttReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUin", wireType)
			}
			m.SrcUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = append(m.FileName[:0], dAtA[iNdEx:postIndex]...)
			if m.FileName == nil {
				m.FileName = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTerm", wireType)
			}
			m.SrcTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcTerm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformType", wireType)
			}
			m.PlatformType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatformType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuType", wireType)
			}
			m.BuType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InnerIp", wireType)
			}
			m.InnerIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InnerIp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceLength", wireType)
			}
			m.VoiceLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoiceLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolNewUpChan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolNewUpChan = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codec", wireType)
			}
			m.Codec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Codec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoiceType", wireType)
			}
			m.VoiceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VoiceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuId", wireType)
			}
			m.BuId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryUpPttResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryUpPttResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryUpPttResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolFileExit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolFileExit = bool(v != 0)
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpIp = append(m.Uint32UpIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpIp) == 0 {
					m.Uint32UpIp = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpIp = append(m.Uint32UpIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpIp", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uint32UpPort = append(m.Uint32UpPort, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Uint32UpPort) == 0 {
					m.Uint32UpPort = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uint32UpPort = append(m.Uint32UpPort, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint32UpPort", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpUkey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpUkey = append(m.UpUkey[:0], dAtA[iNdEx:postIndex]...)
			if m.UpUkey == nil {
				m.UpUkey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId2", wireType)
			}
			m.FileId2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId2 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpOffset", wireType)
			}
			m.UpOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileKey = append(m.FileKey[:0], dAtA[iNdEx:postIndex]...)
			if m.FileKey == nil {
				m.FileKey = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelType", wireType)
			}
			m.ChannelType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileMd5", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileMd5 = append(m.FileMd5[:0], dAtA[iNdEx:postIndex]...)
			if m.FileMd5 == nil {
				m.FileMd5 = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileWidth", wireType)
			}
			m.FileWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileWidth |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHeight", wireType)
			}
			m.FileHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileHeight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &MessageItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUin", wireType)
			}
			m.FromUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUid", wireType)
			}
			m.MsgUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubD4) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubD4: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubD4: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub8A) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub8A: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub8A: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgInfo = append(m.MsgInfo, &Sub8AMsgInfo{})
			if err := m.MsgInfo[len(m.MsgInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			m.AppId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstId", wireType)
			}
			m.InstId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LongMessageFlag", wireType)
			}
			m.LongMessageFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LongMessageFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved = append(m.Reserved[:0], dAtA[iNdEx:postIndex]...)
			if m.Reserved == nil {
				m.Reserved = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub8AMsgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub8AMsgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub8AMsgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUin", wireType)
			}
			m.FromUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUin", wireType)
			}
			m.ToUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUid", wireType)
			}
			m.MsgUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgUid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTime", wireType)
			}
			m.MsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgRandom", wireType)
			}
			m.MsgRandom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgRandom |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgNum", wireType)
			}
			m.PkgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgIndex", wireType)
			}
			m.PkgIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PkgIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevSeq", wireType)
			}
			m.DevSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevSeq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubB3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubB3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubB3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgAddFrdNotify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgAddFrdNotify == nil {
				m.MsgAddFrdNotify = &SubB3AddFrdNotify{}
			}
			if err := m.MsgAddFrdNotify.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubB3AddFrdNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubB3AddFrdNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubB3AddFrdNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nick = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub44) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub44: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub44: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendSyncMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FriendSyncMsg == nil {
				m.FriendSyncMsg = &Sub44FriendSyncMsg{}
			}
			if err := m.FriendSyncMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSyncMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupSyncMsg == nil {
				m.GroupSyncMsg = &Sub44GroupSyncMsg{}
			}
			if err := m.GroupSyncMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub44FriendSyncMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub44FriendSyncMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub44FriendSyncMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FUin", wireType)
			}
			m.FUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessType", wireType)
			}
			m.ProcessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessFlag", wireType)
			}
			m.ProcessFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			m.SourceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSubId", wireType)
			}
			m.SourceSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceSubId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrWording", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StrWording = append(m.StrWording, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sub44GroupSyncMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sub44GroupSyncMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sub44GroupSyncMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSeq", wireType)
			}
			m.MsgSeq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSeq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpCode", wireType)
			}
			m.GrpCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GrpCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GaCode", wireType)
			}
			m.GaCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GaCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUin1", wireType)
			}
			m.OptUin1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUin1 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptUin2", wireType)
			}
			m.OptUin2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptUin2 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgBuf = append(m.MsgBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.MsgBuf == nil {
				m.MsgBuf = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgStatus", wireType)
			}
			m.MsgStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionUin", wireType)
			}
			m.ActionUin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionUin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionTime", wireType)
			}
			m.ActionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActionTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMaxMemCount", wireType)
			}
			m.CurMaxMemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurMaxMemCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextMaxMemCount", wireType)
			}
			m.NextMaxMemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextMaxMemCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurMemCount", wireType)
			}
			m.CurMemCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurMemCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqSrcId", wireType)
			}
			m.ReqSrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqSrcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqSrcSubId", wireType)
			}
			m.ReqSrcSubId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqSrcSubId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviterRole", wireType)
			}
			m.InviterRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviterRole |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtAdminNum", wireType)
			}
			m.ExtAdminNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtAdminNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessFlag", wireType)
			}
			m.ProcessFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessFlag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMemberReqBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMemberReqBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMemberReqBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewClient", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewClient = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RichCardNameVer", wireType)
			}
			m.RichCardNameVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RichCardNameVer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMemberRspBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMemberRspBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMemberRspBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupCode", wireType)
			}
			m.GroupCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfRole", wireType)
			}
			m.SelfRole = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfRole |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MemInfo == nil {
				m.MemInfo = &GroupMemberInfo{}
			}
			if err := m.MemInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolSelfLocationShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BoolSelfLocationShared = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupType", wireType)
			}
			m.GroupType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMemberInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMemberInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMemberInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uin", wireType)
			}
			m.Uin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errmsg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errmsg = append(m.Errmsg[:0], dAtA[iNdEx:postIndex]...)
			if m.Errmsg == nil {
				m.Errmsg = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFriend = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = append(m.Remark[:0], dAtA[iNdEx:postIndex]...)
			if m.Remark == nil {
				m.Remark = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConcerned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConcerned = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credit", wireType)
			}
			m.Credit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Credit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Card = append(m.Card[:0], dAtA[iNdEx:postIndex]...)
			if m.Card == nil {
				m.Card = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = append(m.Location[:0], dAtA[iNdEx:postIndex]...)
			if m.Location == nil {
				m.Location = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nick", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nick = append(m.Nick[:0], dAtA[iNdEx:postIndex]...)
			if m.Nick == nil {
				m.Nick = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Age", wireType)
			}
			m.Age = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Age |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lev", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lev = append(m.Lev[:0], dAtA[iNdEx:postIndex]...)
			if m.Lev == nil {
				m.Lev = []byte{}
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			m.Join = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Join |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSpeak", wireType)
			}
			m.LastSpeak = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSpeak |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GbarTitle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GbarTitle = append(m.GbarTitle[:0], dAtA[iNdEx:postIndex]...)
			if m.GbarTitle == nil {
				m.GbarTitle = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GbarUrl", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GbarUrl = append(m.GbarUrl[:0], dAtA[iNdEx:postIndex]...)
			if m.GbarUrl == nil {
				m.GbarUrl = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GbarCnt", wireType)
			}
			m.GbarCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GbarCnt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowModCard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowModCard = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVip = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsYearVip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsYearVip = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuperVip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuperVip = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuperQq", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSuperQq = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipLev", wireType)
			}
			m.VipLev = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VipLev |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationShared", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocationShared = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int64Distance", wireType)
			}
			m.Int64Distance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Int64Distance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcernType", wireType)
			}
			m.ConcernType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConcernType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialTitle", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SpecialTitle = append(m.SpecialTitle[:0], dAtA[iNdEx:postIndex]...)
			if m.SpecialTitle == nil {
				m.SpecialTitle = []byte{}
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecialTitleExpireTime", wireType)
			}
			m.SpecialTitleExpireTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpecialTitleExpireTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNum = append(m.PhoneNum[:0], dAtA[iNdEx:postIndex]...)
			if m.PhoneNum == nil {
				m.PhoneNum = []byte{}
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Job = append(m.Job[:0], dAtA[iNdEx:postIndex]...)
			if m.Job == nil {
				m.Job = []byte{}
			}
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MedalId", wireType)
			}
			m.MedalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MedalId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Honor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Honor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupData
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthData
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthData        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupData = fmt.Errorf("proto: unexpected end of group")
)
